{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-formly-templates-material.min.js","webpack:///webpack/bootstrap bf319401c7087a02f574","webpack:///./index.js","webpack:///external \"angular\"","webpack:///../~/angular-animate/angular-animate.js","webpack:///../~/angular-animate/index.js","webpack:///../~/angular-aria/angular-aria.js","webpack:///../~/angular-aria/index.js","webpack:///../~/angular-material/angular-material.js","webpack:///../~/angular-material/index.js","webpack:///./angular-fix/index.js","webpack:///./index.common.js","webpack:///./run/mdInputContainerFlexManipulator.js","webpack:///./types/checkbox.js","webpack:///./types/input.js","webpack:///./types/multiCheckbox.js","webpack:///./types/radio.js","webpack:///./types/select.js","webpack:///./types/textarea.js","webpack:///./wrappers/mdInputContainer.js","webpack:///./wrappers/mdLabel.js","webpack:///./types/checkbox.html","webpack:///./types/multiCheckbox.html","webpack:///./types/radio.html","webpack:///./types/select.html","webpack:///./wrappers/mdLabel.html","webpack:///external {\"root\":\"apiCheck\",\"amd\":\"api-check\",\"commonjs\":\"api-check\",\"commonjs2\":\"api-check\"}","webpack:///external {\"root\":\"ngFormly\",\"amd\":\"angular-formly\",\"commonjs\":\"angular-formly\",\"commonjs2\":\"angular-formly\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_24__","__WEBPACK_EXTERNAL_MODULE_25__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_indexCommon","_indexCommon2","window","angular","undefined","directive","NG_ANIMATE_CHILDREN","scope","element","attrs","val","ngAnimateChildren","isString","length","data","$watch","$$rAF","$document","bod","body","fn","offsetWidth","config","$provide","$animateProvider","extractElementNode","i","elm","nodeType","ELEMENT_NODE","prepareElement","stripCommentsFromElement","isMatchingElement","elm1","elm2","$$jqLite","noop","forEach","selectors","$$selectors","isArray","isObject","NG_ANIMATE_STATE","NG_ANIMATE_CLASS_NAME","rootAnimateState","running","decorator","$delegate","$$q","$injector","$sniffer","$rootElement","$$asyncCallback","$rootScope","$templateRequest","$$$jqLite","classBasedAnimationsBlocked","setter","structural","disabled","runAnimationPostDigest","cancelFn","defer","promise","$$cancelFn","$$postDigest","resolve","parseAnimateOptions","options","tempClasses","split","resolveElementClasses","cache","runningAnimations","lookup","selector","s","hasClasses","create","attr","className","toAdd","toRemove","classes","status","hasClass","matchingAnimation","event","push","join","name","matches","flagMap","substr","transitions","animations","get","klass","selectorFactoryName","animationRunner","animationEvent","registerAnimation","animationFactory","afterFn","beforeFn","charAt","toUpperCase","after","before","run","fns","cancellations","allCompleteFn","afterAnimationComplete","index","count","animation","progress","classNameAdd","classNameRemove","from","to","node","isSetClassOperation","isClassBased","currentClassName","isAnimatableClassName","beforeComplete","beforeCancel","afterComplete","afterCancel","animationLookup","replace","created","applyStyles","css","extend","cancel","performAnimation","parentElement","afterElement","domOperation","doneCallback","fireDOMCallback","animationPhase","eventName","elementEvents","triggerHandler","fireBeforeCallbackAsync","fireAfterCallbackAsync","fireDoneCallbackAsync","fireDOMOperation","hasBeenRun","closeAnimation","runner","removeClass","cleanup","localAnimationCount","noopCancel","_data","events","parent","animationsDisabled","ngAnimateState","active","totalActiveAnimations","totalActive","lastAnimation","last","skipAnimation","animationsToCancel","current","operation","one","e","state","activeLeaveAnimation","addClass","globalAnimationCounter","cancelled","cancelChildAnimations","nodes","isFunction","getElementsByClassName","querySelectorAll","removeAnimations","removeData","allowChildAnimations","parentRunningAnimation","hasParent","isRoot","animateChildrenFlag","isDefined","deregisterWatch","totalPendingRequests","oldVal","classNameFilter","test","animate","done","enter","leave","move","setClass","add","remove","STORAGE_KEY","$$setClassImmediately","hasCache","elementNode","parentNode","$$addClassImmediately","$$removeClassImmediately","enabled","arguments","register","$window","$timeout","$$animateReflow","clearCacheAfterReflow","cancelAnimationReflow","animationReflowQueue","lookupCache","afterReflow","callback","animationCloseHandler","totalTime","animationElementQueue","futureTimestamp","Date","now","closingTimestamp","closingTimer","closeAllAnimations","elements","elementData","NG_ANIMATE_CSS_DATA_KEY","closeAnimationFns","getElementAnimationDetails","cacheKey","transitionDuration","transitionDelay","animationDuration","animationDelay","elementStyles","getComputedStyle","transitionDurationStyle","TRANSITION_PROP","DURATION_KEY","Math","max","parseMaxTime","transitionDelayStyle","DELAY_KEY","ANIMATION_PROP","aDuration","parseInt","ANIMATION_ITERATION_COUNT_KEY","total","str","maxValue","values","parseFloat","getCacheKey","parentID","NG_ANIMATE_PARENT_KEY","parentCounter","getAttribute","animateSetup","styles","indexOf","eventCacheKey","itemIndex","stagger","staggerClassName","staggerCacheKey","applyClasses","formerData","timings","blockTransition","blockAnimation","blockTransitions","blockAnimations","animateRun","activeAnimationComplete","onEnd","off","css3AnimationEvents","onAnimationProgress","activeClassName","pendingClassName","staggerTimeout","animateClose","appliedStyles","style","removeProperty","stopPropagation","ev","originalEvent","timeStamp","$manualTimeStamp","elapsedTime","toFixed","ELAPSED_TIME_MAX_DECIMAL_PLACES","startTime","maxDelayTime","maxDuration","prefix","staggerTime","transitionStaggerDelay","animationStaggerDelay","CSS_PREFIX","round","keys","maxDelay","ONE_SECOND","oldStyle","setAttribute","ANIMATIONEND_EVENT","TRANSITIONEND_EVENT","animationTime","CLOSING_TIME_BUFFER","on","bool","PROPERTY_KEY","ANIMATION_PLAYSTATE_KEY","animateBefore","animateAfter","animationComplete","preReflowCancellation","suffixClasses","suffix","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","animationCompleted","beforeSetClass","cancellationMethod","beforeAddClass","beforeRemoveClass","$AriaProvider","watchExpr","attrName","ariaAttr","negate","elem","ariaCamelName","$normalize","boolVal","ariaHidden","ariaChecked","ariaDisabled","ariaRequired","ariaInvalid","ariaMultiline","ariaValue","tabindex","bindKeypress","newConfig","$get","key","$$watchExpr","ngAriaModule","provider","$aria","shouldAttachAttr","normalizedAttr","shouldAttachRole","role","nodeName","getShape","type","restrict","priority","link","ngModel","ngAriaWatchModelValue","$modelValue","getRadioReaction","needsTabIndex","newVal","$viewValue","ngAriaCheckboxReaction","$isEmpty","shape","min","$validators","required","$error","$invalid","ngMessages","$parse","compile","ngClick","isNodeOneOf","nodeTypeArray","nodeBlackList","ngKeypress","$event","keyCode","$apply","MdCoreConfigure","$mdThemingProvider","rAFDecorator","theme","primaryPalette","accentPalette","warnPalette","backgroundPalette","throttle","cb","queueArgs","alreadyQueued","queueCb","context","apply","$inject","MdConstantFactory","vendorProperty","webkit","substring","vendorPrefix","KEY_CODE","ENTER","ESCAPE","SPACE","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","TAB","BACKSPACE","DELETE","CSS","TRANSITIONEND","ANIMATIONEND","TRANSFORM","TRANSFORM_ORIGIN","TRANSITION","TRANSITION_DURATION","ANIMATION_PLAY_STATE","ANIMATION_DURATION","ANIMATION_NAME","ANIMATION_TIMING","ANIMATION_DIRECTION","MEDIA","sm","gt-sm","md","gt-md","lg","gt-lg","MEDIA_PRIORITY","MdIterator","items","reloop","getItems","concat","_items","inRange","hasNext","item","hasPrevious","itemAt","findBy","filter","isNumber","splice","contains","first","findSubsequentItem","backwards","validate","limit","trueFn","curIndex","nextIndex","foundItem","isUndefined","Array","prototype","slice","next","bind","previous","iterator","mdMediaFactory","$mdConstant","$mdMedia","query","validated","queries","result","results","mqls","matchMedia","addListener","onQueryChange","media","$evalAsync","getQuery","getResponsiveAttribute","mediaName","normalizedName","getNormalizedName","watchResponsiveAttributes","attrNames","watchFn","unwatchFns","$observe","normalizeCache","nextUniqueId","$cacheFactory","$q","getNode","el","Util","performance","clientRect","offsetParent","isOffsetRect","document","nodeRect","getBoundingClientRect","offsetRect","left","top","width","height","nodesToArray","disableScrollAround","disableElementScroll","disableKeyNav","preventDefault","zIndex","isNaN","scrollMask","appendChild","removeChild","_enableScrolling","disableBodyScroll","restoreStyle","scrollOffset","scrollTop","position","overflowY","restoreBody","restoreElement","enableScrolling","method","floatingScrollbars","cached","tempNode","childNodes","forceFocus","addEventListener","focusOnClick","target","$focus","focus","stopImmediatePropagation","removeEventListener","newEvent","createEvent","initMouseEvent","$material","dispatchEvent","transitionEndPromise","opts","finished","deferred","timeout","fakeNgModel","$fake","$setTouched","$setViewValue","$render","$viewChangeListeners","$parsers","$formatters","debounce","func","wait","invokeApply","timer","args","delay","recent","time","start","nextUid","disconnectScope","$root","$$destroyed","$parent","$$disconnected","$$childHead","$$nextSibling","$$childTail","$$prevSibling","reconnectScope","child","getClosest","tagName","onlyParent","extractElementByName","len","toLowerCase","initOptionalProperties","defaults","$$isolateBindings","binding","optional","hasKey","hasOwnProperty","blur","AriaService","$log","expect","defaultValue","hasAttribute","childHasAttribute","trim","warn","expectAsync","defaultValueGetter","expectWithText","getText","text","isHidden","currentStyle","display","hasChildren","hasChildNodes","hasAttr","children","service","mdCompilerService","$http","$compile","$controller","$templateCache","templateUrl","template","controller","controllerAs","locals","transformTemplate","identity","bindToController","invoke","$template","then","response","when","all","html","contents","linkFn","$scope","invokeCtrl","instance","ctrl","MdGestureProvider","MdGesture","$$MdGestureHandler","handlerName","handler","HANDLERS","Error","registerElement","addHandler","definition","self","userAgent","navigator","vendor","opera","isIos","match","isAndroid","hasJQuery","jQuery","isHijackingClicks","forceSkipClickHijack","maxDistance","pointer","distance","onStart","onCancel","registeredParent","pos","x","y","onMove","dx","dy","sqrt","minDistance","horizontal","cancelMultiplier","shouldStartDrag","shouldCancel","dragPointer","dispatchDragMove","abs","distanceX","distanceY","makeStartPointer","updatePointerState","isRunning","minVelocity","velocityX","eventType","directionX","GestureHandler","MdGestureHandler","jQueryDispatchEvent","srcEvent","eventPointer","eventObj","Event","clientX","clientY","screenX","screenY","pageX","pageY","ctrlKey","altKey","shiftKey","metaKey","trigger","nativeDispatchEvent","detail","button","relatedTarget","initCustomEvent","parentTarget","getNearestParent","parentTargetOptions","$mdGesture","end","onDestroy","attachToDocument","runHandlers","handlerEvent","gestureStart","lastPointer","typesMatch","endTime","gestureMove","gestureEnd","isInitialized","isKeyClick","isIonicTap","START_EVENTS","MOVE_EVENTS","END_EVENTS","point","getEventPoint","startPointer","startX","startY","directionY","duration","velocityY","touches","changedTouches","skipClickHijack","InterimElementProvider","createInterimElementProvider","interimFactoryName","setDefaults","providerConfig","optionsFactory","methods","EXPOSED_METHODS","addMethod","customMethods","addPreset","presets","argOption","$$interimElement","$animate","showInterimElement","_options","interimElementService","show","defaultOptions","invokeFactory","defaultVal","publicService","defaultMethods","hide","Preset","presetDefaults","presetMethods","$type","methodName","arg","InterimElementFactory","$interpolate","$mdCompiler","$mdTheming","replaceInterpolationSymbols","startSymbol","endSymbol","usesStandardSymbols","processTemplate","stack","interimElement","InterimElement","shift","reason","reject","hideTimeout","showDone","removeDone","preserveScope","$new","isolateScope","onShow","onRemove","compilePromise","skipCompile","compileData","startHideTimeout","hideDelay","querySelector","themable","ret","onComplete","cancelTimeout","$destroy","ComponentRegistry","isValidID","handle","instances","pendings","notFoundError","error","getInstances","j","$$mdHandle","deregister","resolveWhen","dfd","MdButtonInkRipple","$mdInkRipple","attach","elementOptions","optionsForElement","isMenuItem","fitRipple","center","dimBackground","MdCheckboxInkRipple","MdListInkRipple","outline","rippleSize","InkRippleDirective","$mdButtonInkRipple","$mdCheckboxInkRipple","InkRippleService","getRippleContainer","container","append","parseColor","color","hexToRGBA","hex","dig","red","grn","blu","rgbToRGBA","removeElement","ripples","backgroundColor","updateElement","states","elemIsActive","isActive","elemIsHeld","isHeld","animating","marginLeft","marginTop","createRipple","getRippleElement","counter","unshift","getRippleSize","multiplier","size","rect","prop","pow","fullRipple","getRippleCss","rgbaToRGB","borderColor","colorElement","borderWidth","onPressDown","isRippleAllowed","onPressUp","ripple","isDisabled","grandparent","ancestor","mousedown","hover","mousedownPauseTime","isActiveExpr","rippleSizeSetting","newValue","attrNoDirective","MdTabInkRipple","constant","50","100","200","300","400","500","600","700","800","900","A100","A200","A400","A700","contrastDefaultColor","contrastDarkColors","contrastStrongLightColors","pink","purple","deep-purple","indigo","blue","light-blue","contrastLightColors","cyan","teal","green","light-green","lime","yellow","amber","orange","deep-orange","brown","grey","1000","blue-grey","ThemingProvider","$mdColorPalette","definePalette","map","PALETTES","checkPaletteValid","themingProvider","extendPalette","missingColors","VALID_HUE_VALUES","field","registerTheme","inheritFrom","THEMES","parentTheme","Theme","colors","colorType","hues","setDark","isDark","foregroundPalette","LIGHT_FOREGROUND","DARK_FOREGROUND","foregroundShadow","DARK_SHADOW","LIGHT_SHADOW","newDefaultHues","DARK_DEFAULT_HUES","LIGHT_DEFAULT_HUES","oldDefaultHues","newDefaults","oldDefaults","hueName","dark","THEME_COLOR_TYPES","defaultHues","paletteName","hueValue","console","ThemingService","registered","themeName","applyTheme","inherit","changeTheme","oldTheme","attrThemeValue","alwaysWatchTheme","$mdTheme","defaultTheme","setDefaultTheme","alwaysWatch","_LIGHT_DEFAULT_HUES","_DARK_DEFAULT_HUES","_PALETTES","_THEMES","_parseRules","parseRules","_rgba","rgba","ThemingDirective","pre","$setTheme","mdTheme","ThemableDirective","rules","checkValidPalette","generatedRules","themeNameRegex","RegExp","hueRegex","simpleVariableRegex","palette","hue","opacity","newRule","_","hueType","generateThemes","sanitizePalette","defaultContrast","lightColors","strongLightColors","darkColors","getContrastColor","DARK_CONTRAST_COLOR","STRONG_LIGHT_CONTRAST_COLOR","LIGHT_CONTRAST_COLOR","rgbValue","colorToRgbaArray","contrast","head","getElementsByTagName","firstChild","firstElementChild","themeCss","has","rulesByType","rule","ruleMatchRegex","DEFAULT_COLOR_TYPE","GENERATED","styleStrings","createElement","createTextNode","insertBefore","primary","accent","clr","rgbArray","copy","pop","1","2","3","4","hue-1","hue-2","hue-3","background","defaultDefaultHues","BackdropDirective","MdBottomSheetDirective","MdBottomSheetProvider","$$interimElementProvider","bottomSheetDefaults","$mdUtil","$mdBottomSheet","backdrop","bottomSheet","BottomSheet","targetEvent","disableParentScroll","lastOverflow","focusable","escapeToClose","rootElementKeyupCallback","onDragStart","onDrag","transform","PADDING","onDragEnd","CLOSING_VELOCITY","distanceRemaining","MdButtonDirective","$mdAria","isAnchor","href","ngHref","ngLink","uiSref","getTemplate","postLink","elementHasText","textContent","ngDisabled","mouseActive","transclude","mdCardDirective","$element","$attr","MdCheckboxDirective","inputDirective","tElement","tAttrs","ngModelCtrl","expr","htmlAttr","valueOpts","keypressHandler","which","listener","viewValue","ngChecked","checked","render","CHECKED_CSS","$eval","true","false","mdContentDirective","ContentController","$broadcast","iosScrollFix","$materialScrollFixed","scrollHeight","offsetHeight","MdDialogDirective","content","clientHeight","MdDialogProvider","advancedDialogOptions","$mdDialog","abort","dialogDefaultOptions","trapFocus","dialog","findCloseButton","closeButton","actionButtons","popInTarget","hasBackdrop","computeFrom","documentElement","parentOffset","elementToFocus","find","configureAria","dialogPopIn","applyAriaToSiblings","clickOutsideToClose","dialogClickOutsideCallback","focusOnOpen","dialogPopOut","tabIndex","dialogContent","dialogId","ariaLabel","words","walkDOM","attribute","clickElement","dialogEl","transformToClickElement","clickRect","dialogRect","scaleX","scaleY","MdFabActionsDirective","attributes","controllers","open","close","wrap","MdDividerDirective","MdFabSpeedDialDirective","FabSpeedDialLink","prepend","FabSpeedDialController","setupDefaults","vm","direction","isOpen","setupListeners","setupWatchers","newDir","oldDir","MdFabSpeedDialFlingAnimation","runAnimation","variablesElement","startZIndex","newPosition","axis","scrollWidth","MdFabSpeedDialScaleAnimation","offsetDelay","MdFabToolbarDirective","FabToolbarController","MdFabToolbarAnimation","backgroundElement","triggerElement","iconElement","actions","getPropertyValue","scale","borderRadius","right","action","GridListDirective","$mdGridLayout","watchMedia","invalidateLayout","layoutIfMediaMatch","unwatchMedia","layoutDelegate","unwatchAttrs","removeListener","tilesInvalidated","tiles","getTileElements","props","tileSpans","getTileSpans","colCount","getColumnCount","rowMode","getRowMode","rowHeight","getRowHeight","gutter","getGutter","equals","lastLayoutProps","tilePositions","rowCount","grid","getGridStyle","ps","getTileStyle","spans","reflow","mdOnLayout","exprStr","hShare","hGutterShare","hUnit","UNIT","share","gutterShare","POSITION","unit","offset","col","DIMENSION","span","paddingTop","row","vShare","vUnit","vGutterShare","paddingBottom","ele","tileElements","$attrs","applyDefaultUnit","whRatio","$on","GridListController","layoutInvalidated","$timeout_","GridLayoutFactory","GridLayout","layoutInfo","gridStyles","layoutTime","mapTime","reflowTime","calculateGridFor","updateFn","info","positioning","animatorFn","animator","defaultAnimator","tileCount","GridTileAnimator","t","reserveSpace","curCol","nextRow","spaceTracker","findEnd","adjustRow","curRow","cols","by","newSpaceTracker","tracker","animateWith","customAnimator","GridTileDirective","gridCtrl","invalidateTiles","$index","newIdx","oldIdx","GridTileCaptionDirective","layout","MdFabTriggerDirective","mdIconDirective","$mdIcon","parentsHaveText","prepareForFontIcon","svgIcon","svgSrc","fontIcon","fontSet","label","alt","mdSvgIcon","mdSvgSrc","attrVal","empty","svg","MdIconProvider","ConfigurationItem","url","viewBoxSize","defaultViewBoxSize","MdIconService","getIcon","iconCache","clone","urlRegex","loadByURL","cacheIcon","loadByID","loadFromIconSet","announceIdNotFound","announceNotFound","findRegisteredFontSet","alias","useDefault","defaultFontSet","fontSets","it","icon","isIcon","Icon","iconConfig","extractFromSet","set","iconName","lastIndexOf","iconSetConfig","setName","msg","err","message","statusText","prepare","prepareAndStyle","fit","preserveAspectRatio","viewBox","pointer-events","cloneSVG","cloneNode","iconSet","defaultIconSet","defaultIconSize","iconSize","preloadIcons","iconProvider","svgRegistry","asset","put","mdInputContainerDirective","ContainerCtrl","isErrorGetter","mdIsError","delegateClick","input","setFocused","isFocused","toggleClass","setHasValue","hasValue","setInvalid","isInvalid","hasLabelAndInput","labelDirective","containerCtrl","mdNoFloat","inputTextareaDirective","ctrls","ngModelPipelineCheckValue","inputCheckValue","validity","badInput","setupTextarea","pipelineListener","onChangeTextarea","growTextarea","getHeight","line","onScroll","isReadonly","readonly","$touched","mdMaxlengthDirective","renderCharCount","charCountEl","maxlength","$set","mdMaxlength","lastElementChild","modelValue","placeholderDirective","inputContainer","blackListElements","placeholderText","placeholder","removeAttr","mdListDirective","tEl","mdListItemDirective","proxiedTypes","setupToggleAria","toggle","toggleType","toggleTypes","wrapIn","copiedAttrs","removeAttribute","eq","secondaryItem","buttonWrapper","classList","isProxiedElement","computeProxies","proxies","computeClickable","hasClick","attachRipple","proxy","proxyOnBlur","click","hasProxiedElement","proxyElement","MdListController","$mdListInkRipple","MenuDirective","$mdMenu","templateElement","mdMenuCtrl","menuContainer","menuContents","init","MenuController","setMenuContainer","$mdOpenMenu","skipFocus","positionMode","attachment","mdPositionMode","offsets","mdOffset","MenuProvider","menuDefaultOptions","buildOpts","alreadyOpen","isRemoved","menuContentEl","handleResizing","resizeFn","positionMenu","showMenu","activateInteraction","focusMenuItem","focusTarget","restoreScroll","menuEl","currentItem","currentIndex","didFocus","attemptFocus","activeElement","clamp","bounds","bottom","containerNode","alignTarget","alignTargetRect","existingOffsets","openMenuNode","openMenuNodeRect","boundryNode","boundryNodeRect","originNode","originNodeRect","MENU_EDGE_MARGIN","transformOrigin","MdProgressCircularDirective","circle","diameter","mdDiameter","percentValue","MdProgressLinearDirective","bar1Style","bar2Style","mdMode","clamped","transforms","ceil","makeTransform","translateX","toString","mdRadioGroupDirective","linkRadioGroup","setFocus","keydownListener","rgCtrl","selectPrevious","selectNext","form","RadioGroupController","_radioButtonRenderFns","createRadioGroupControllerProto","_ngModelCtrl","rbRender","setViewValue","getViewValue","changeSelectedButton","setActiveDescendant","radioId","increment","buttons","selected","mdRadioButtonDirective","lastChecked","buildAriaID","ariaId","aria-checked","SelectDirective","$mdSelect","labelEl","spanWrapper","mdOnOpen","autofillClone","ng-model","aria-hidden","newEl","innerHTML","selectTemplate","multiple","setAriaLabel","labelText","syncLabelText","selectContainer","selectMenuCtrl","mdSelectCtrl","setLabelText","selectedLabels","createSelect","selectEl","selectScope","handleKeypress","allowedCodes","openSelect","optNodeForKeyboardSearch","optionCtrl","isMultiple","deselect","select","hashKey","refreshViewValue","loadingAsync","selectedText","formCtrl","customLabel","$removeControl","originalRender","setIsPlaceholder","triggerClose","mdOnClose","deregisterWatcher","parser","prevVal","setMultiple","aria-disabled","ariaAttrs","aria-expanded","SelectMenuDirective","preLink","aria-multiselectable","selectCtrl","keyListener","clickListener","option","optionHashKey","hashGetter","isSelected","SelectMenuController","renderMultiple","newSelectedValues","oldSelected","newSelectedHashes","deselected","hash","renderSingular","deregisterCollectionWatch","validateArray","$watchCollection","clearSearchTimeout","optNodes","optText","searchStr","CLEAR_SEARCH_AFTER","clearTimeout","setTimeout","String","fromCharCode","search","$options","trackBy","trackByLocals","trackByParsed","valueScope","$value","$$mdSelectId","selectNextId","selectedOptionEls","hashedValue","setSelected","addOption","removeOption","OptionDirective","setOptionValue","oldValue","oldHashKey","newHashKey","aria-selected","ngValue","OptionController","OptgroupDirective","labelElement","SelectProvider","selectDefaultOptions","focusOption","optionsArray","optionNodes","focusedNode","newOption","focusNextOption","focusPrevOption","checkCloseMenu","restoreFocus","optNode","contentEl","animateSelect","$$loadingAsyncDone","resizefn","mdSelect","centeredNode","targetNode","selectNode","contentNode","parentRect","targetRect","shouldOpenAroundTarget","SELECT_EDGE_MARGIN","spaceAvailable","maxWidth","isScrollable","selectedNode","optgroupNodes","selectMenuRect","centeredRect","getOffsetRect","centeredStyle","paddingLeft","paddingRight","scrollBuffer","floor","minWidth","containerRect","n","offsetLeft","offsetTop","SidenavService","$mdComponentRegistry","waitForInstance","errorMsg","isLockedOpen","callbackFn","SidenavFocusDirective","sidenavCtrl","focusElement","SidenavDirective","updateIsLocked","isLocked","updateIsOpen","onKeyDown","triggeringElement","focusEl","lastParentOverFlow","toggleOpen","isEscape","isLockedOpenParsed","mdIsLockedOpen","$media","destroy","$toggleOpen","SidenavController","mdComponentId","SliderDirective","updateAll","refreshSliderDimensions","ngModelRender","redrawTicks","updateMin","updateMax","updateStep","step","updateAriaDisabled","mdDiscrete","numSteps","tickCanvas","trackTicksStyle","tickContainer","tickCtx","getContext","fillStyle","dimensions","getSliderDimensions","fillRect","sliderDimensions","trackContainer","throttledRefreshDimensions","changeAmount","setModelValue","minMaxValidator","stepValidator","percent","setSliderPercent","thumbText","formattedValue","activeTrack","thumbContainer","isDisabledGetter","exactVal","percentToValue","positionToPercent","closestVal","valueToPercent","isDragging","setSliderFromEvent","isDiscrete","adjustThumbPosition","doSlide","isDisabledParsed","thumb","stopDisabledWatch","debouncedUpdateAll","MdSubheaderDirective","$mdSticky","getContent","outerHTML","stickyClone","MdSticky","setupSticky","contentCtrl","stickyBaseoffset","debouncedRefreshElements","refreshElements","refreshPosition","sort","a","b","currentScrollTop","setCurrentItem","isScrollingDown","prevScrollTop","translate","prev","setStickyState","amount","translateY","setupAugmentedScrollEvents","checkStickySupport","$el","stickyProp","testEl","stickyProps","z-index","loopScrollEvent","lastScrollTime","SCROLL_END_DELAY","isScrolling","browserStickySupport","$$sticky","getDirective","DirectiveFactory","directiveName","MdSwitch","mdCheckboxDirective","checkboxLink","checkboxDirective","disabledGetter","drag","isChanged","applyModelValue","switchContainer","MdToastDirective","MdToastProvider","toastDefaultOptions","$mdToast","activeToastContent","toastOpenClass","onSwipe","gesture","newContent","mdToolbarDirective","setupScrollShrink","onMdContentLoad","newContentEl","contentElement","debouncedContentScroll","updateToolbarHeight","toolbarHeight","margin","shrinkSpeedFactor","onContentScroll","debouncedUpdateHeight","mdShrinkSpeedFactor","mdScrollShrink","MdTooltipDirective","manipulateElement","bindEvents","configureWatchers","addAriaLabel","mdDelay","TOOLTIP_SHOW_DELAY","visible","debouncedOnResize","isVisible","showTooltip","hideTooltip","detach","getParentWithPointerEvents","getNearestContentElement","hasComputedStyleValue","computedStyles","enterHandler","setVisible","leaveHandler","autohide","queued","tooltipParent","positionTooltip","positionBackground","tipRect","fitInParent","TOOLTIP_WINDOW_EDGE_SPACE","getPosition","dir","mdDirection","MdAutocompleteCtrl","searchText","selectedItem","gatherElements","moveDropdown","positionDropdown","correctHorizontalAlignment","dropdown","ul","MENU_PADDING","hrect","$","vrect","snap","bot","MAX_HEIGHT","maxHeight","pin","autofocus","isRequired","handleSearchText","registerSelectedItemWatcher","selectedItemChange","handleSelectedItemChange","main","li","getSnapTarget","getAngularElements","handleHiddenChange","hidden","oldHidden","onListEnter","noBlur","onListLeave","hasFocus","onMouseup","previousSelectedItem","getDisplayValue","itemChange","getItemScope","selectedItemWatchers","unregisterSelectedItemWatcher","previousSearchText","getDefaultIndex","textChange","isMinLengthMet","handleQuery","loading","shouldHide","updateMessages","minLength","keydown","updateScroll","getMinLength","itemText","itemName","autoselect","getCurrentDisplayValue","clearValue","fetchResults","handleResults","term","itemExpr","success","messages","getCountMessage","lastCount","hgt","noCache","itemParts","itemsExpr","clear","listEnter","listLeave","mouseUp","ITEM_HEIGHT","MdAutocomplete","inputName","inputMinlength","inputMaxlength","floatingLabel","menuClass","getItemTemplate","templateTag","getNoItemsTemplate","getInputElement","mdFloatingLabel","leftover","noItemsTemplate","itemTemplate","MdHighlightCtrl","unsafeText","flags","watcher","regex","getRegExp","sanitize","MdHighlight","terminal","mdHighlightText","MdAutocompleteListItem","$mdAutocompleteCtrl","newScope","mdAutocompleteListItem","MdAutocompleteParentScope","MdChip","DELETE_HINT_TEMPLATE","selectedChip","MdChipRemove","removeChip","$$replacedScope","MdChipTransclude","$mdChipsCtrl","$chip","mdChipTransclude","MdChipsCtrl","userInputNgModelCtrl","userInputElement","deleteHint","deleteButtonLabel","chipBuffer","useMdOnAppend","inputKeydown","getChipBuffer","requireMatch","appendChip","resetChipBuffer","selectAndFocusChipSafe","chipKeydown","removeAndSelectAdjacentChip","onFocus","getPlaceholder","useSecondary","secondaryPlaceholder","selIndex","getAdjacentChipIndex","resetSelectedChip","newChip","mdOnAppend","useMdOnAppendExpression","removeChipAndFocusInput","selectChip","focusChip","selectAndFocusChip","configureNgModel","onInputFocus","inputHasFocus","onInputBlur","configureUserInput","inputElement","configureAutocomplete","MdChips","getTemplateByQuery","userTemplate","chipRemoveTemplate","CHIP_REMOVE_TEMPLATE","chipContentsTemplate","CHIP_DEFAULT_TEMPLATE","chipInputTemplate","CHIP_INPUT_TEMPLATE","staticChips","mdChipsCtrl","compiledStaticChips","MD_CHIPS_TEMPLATE","MdContactChipsCtrl","queryContact","contactQuery","$query","filterSelected","filterSelectedContacts","contact","contacts","MdContactChips","MD_CONTACT_CHIPS_TEMPLATE","contactName","contactImage","contactEmail","MdTab","tabs","insertTab","getIndex","refreshIndex","newIndex","updateTabOrder","removeTab","getLabel","getLabelAttribute","getLabelElement","getElementContents","MdTabItem","MdTabLabel","MdTabScroll","mdTabScroll","MdTabsController","$mdTabInkRipple","selectedIndex","compileTemplate","updateHeightFromContent","adjustOffset","updatePagination","$mdTabsTemplate","handleWindowResize","paging","updateInkBarStyles","noInkBar","handleSelectedIndexChange","destroyed","handleHasContent","hasContent","handleOffsetChange","shouldCenterTabs","handleFocusIndexChange","oldIndex","redirectFocus","getNearestSafeIndex","lastSelectedIndex","handleResizeWhenVisible","incrementSelectedIndex","locked","focusIndex","lastClick","scroll","shouldPaginate","fixOffset","wheelDelta","nextPage","tab","viewportWidth","canvas","clientWidth","totalWidth","previousPage","tabData","proto","isLeft","isRight","shouldRender","noDisconnect","processQueue","updateHasContent","getElements","wrapper","dummies","inkBar","contentsWrapper","canPageBack","canPageForward","lastTab","shouldStretchTabs","stretchTabs","centerTabs","noPagination","canvasWidth","maxOffset","focusItem","inc","queue","dynamicHeight","tabContent","contentHeight","tabsHeight","newHeight","currentHeight","updateInkBarClassName","ink","MdTabs","swipeContent","MdTemplate","handleScope","disconnect","reconnect","compileScope","connected","version","_angularFix","_angularFix2","_angularFormly","_angularFormly2","_angularMaterial","_angularMaterial2","_runMdInputContainerFlexManipulator","_runMdInputContainerFlexManipulator2","_typesCheckbox","_typesCheckbox2","_typesInput","_typesInput2","_typesMultiCheckbox","_typesMultiCheckbox2","_typesRadio","_typesRadio2","_typesSelect","_typesSelect2","_typesTextarea","_typesTextarea2","_wrappersMdLabel","_wrappersMdLabel2","_wrappersMdInputContainer","_wrappersMdInputContainer2","ngModuleName","ngModule","output","configFns","configFn","runFns","runFn","addMdInputContainerFlexManipulator","formlyConfig","templateManipulators","postWrapper","templateOptions","flex","mdInputContainer","addCheckboxType","formlyConfigProvider","formlyMaterialApiCheck","setType","apiCheck","string","apiCheckInstance","addInputType","ngModelAttrs","bound","noFormControl","arrayOf","object","labelProp","valueProp","setModel","model","multiCheckbox","checkbox","change","v","addRadioType","addSelectType","groupProp","addTextareaType","rows","number","addMdInputContainerWrapper","setWrapper","addMdLabelWrapper"],"mappings":"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","file":"dist/angular-formly-templates-material.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"), require(\"angular-formly\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\", \"angular-formly\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesMaterial\"] = factory(require(\"angular\"), require(\"api-check\"), require(\"angular-formly\"));\n\telse\n\t\troot[\"ngFormlyTemplatesMaterial\"] = factory(root[\"angular\"], root[\"apiCheck\"], root[\"ngFormly\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","//! angular-formly-templates-material version 1.0.0-beta.0 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"), require(\"angular-formly\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\", \"angular-formly\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesMaterial\"] = factory(require(\"angular\"), require(\"api-check\"), require(\"angular-formly\"));\n\telse\n\t\troot[\"ngFormlyTemplatesMaterial\"] = factory(root[\"angular\"], root[\"apiCheck\"], root[\"ngFormly\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _indexCommon = __webpack_require__(9);\n\t\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.3.15\n\t * (c) 2010-2014 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular, undefined) {'use strict';\n\t\n\t/* jshint maxlen: false */\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngAnimate\n\t * @description\n\t *\n\t * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.\n\t *\n\t * <div doc-module-components=\"ngAnimate\"></div>\n\t *\n\t * # Usage\n\t *\n\t * To see animations in action, all that is required is to define the appropriate CSS classes\n\t * or to register a JavaScript animation via the `myModule.animation()` function. The directives that support animation automatically are:\n\t * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation\n\t * by using the `$animate` service.\n\t *\n\t * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:\n\t *\n\t * | Directive                                                                                                | Supported Animations                                                     |\n\t * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n\t * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n\t * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n\t * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n\t * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n\t * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n\t * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n\t * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n\t * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n\t * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n\t * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n\t *\n\t * You can find out more information about animations upon visiting each directive page.\n\t *\n\t * Below is an example of how to apply animations to a directive that supports animation hooks:\n\t *\n\t * ```html\n\t * <style type=\"text/css\">\n\t * .slide.ng-enter, .slide.ng-leave {\n\t *   -webkit-transition:0.5s linear all;\n\t *   transition:0.5s linear all;\n\t * }\n\t *\n\t * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/\n\t * .slide.ng-enter.ng-enter-active { } /&#42; terminal animations for enter &#42;/\n\t * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/\n\t * .slide.ng-leave.ng-leave-active { } /&#42; terminal animations for leave &#42;/\n\t * </style>\n\t *\n\t * <!--\n\t * the animate service will automatically add .ng-enter and .ng-leave to the element\n\t * to trigger the CSS transition/animations\n\t * -->\n\t * <ANY class=\"slide\" ng-include=\"...\"></ANY>\n\t * ```\n\t *\n\t * Keep in mind that, by default, if an animation is running, any child elements cannot be animated\n\t * until the parent element's animation has completed. This blocking feature can be overridden by\n\t * placing the `ng-animate-children` attribute on a parent container tag.\n\t *\n\t * ```html\n\t * <div class=\"slide-animation\" ng-if=\"on\" ng-animate-children>\n\t *   <div class=\"fade-animation\" ng-if=\"on\">\n\t *     <div class=\"explode-animation\" ng-if=\"on\">\n\t *        ...\n\t *     </div>\n\t *   </div>\n\t * </div>\n\t * ```\n\t *\n\t * When the `on` expression value changes and an animation is triggered then each of the elements within\n\t * will all animate without the block being applied to child elements.\n\t *\n\t * ## Are animations run when the application starts?\n\t * No they are not. When an application is bootstrapped Angular will disable animations from running to avoid\n\t * a frenzy of animations from being triggered as soon as the browser has rendered the screen. For this to work,\n\t * Angular will wait for two digest cycles until enabling animations. From there on, any animation-triggering\n\t * layout changes in the application will trigger animations as normal.\n\t *\n\t * In addition, upon bootstrap, if the routing system or any directives or load remote data (via $http) then Angular\n\t * will automatically extend the wait time to enable animations once **all** of the outbound HTTP requests\n\t * are complete.\n\t *\n\t * ## CSS-defined Animations\n\t * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes\n\t * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported\n\t * and can be used to play along with this naming structure.\n\t *\n\t * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:\n\t *\n\t * ```html\n\t * <style type=\"text/css\">\n\t * /&#42;\n\t *  The animate class is apart of the element and the ng-enter class\n\t *  is attached to the element once the enter animation event is triggered\n\t * &#42;/\n\t * .reveal-animation.ng-enter {\n\t *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/\n\t *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/\n\t *\n\t *  /&#42; The animation preparation code &#42;/\n\t *  opacity: 0;\n\t * }\n\t *\n\t * /&#42;\n\t *  Keep in mind that you want to combine both CSS\n\t *  classes together to avoid any CSS-specificity\n\t *  conflicts\n\t * &#42;/\n\t * .reveal-animation.ng-enter.ng-enter-active {\n\t *  /&#42; The animation code itself &#42;/\n\t *  opacity: 1;\n\t * }\n\t * </style>\n\t *\n\t * <div class=\"view-container\">\n\t *   <div ng-view class=\"reveal-animation\"></div>\n\t * </div>\n\t * ```\n\t *\n\t * The following code below demonstrates how to perform animations using **CSS animations** with Angular:\n\t *\n\t * ```html\n\t * <style type=\"text/css\">\n\t * .reveal-animation.ng-enter {\n\t *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/\n\t *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/\n\t * }\n\t * @-webkit-keyframes enter_sequence {\n\t *   from { opacity:0; }\n\t *   to { opacity:1; }\n\t * }\n\t * @keyframes enter_sequence {\n\t *   from { opacity:0; }\n\t *   to { opacity:1; }\n\t * }\n\t * </style>\n\t *\n\t * <div class=\"view-container\">\n\t *   <div ng-view class=\"reveal-animation\"></div>\n\t * </div>\n\t * ```\n\t *\n\t * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.\n\t *\n\t * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add\n\t * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically\n\t * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be\n\t * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end\n\t * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element\n\t * has no CSS transition/animation classes applied to it.\n\t *\n\t * ### Structural transition animations\n\t *\n\t * Structural transitions (such as enter, leave and move) will always apply a `0s none` transition\n\t * value to force the browser into rendering the styles defined in the setup (`.ng-enter`, `.ng-leave`\n\t * or `.ng-move`) class. This means that any active transition animations operating on the element\n\t * will be cut off to make way for the enter, leave or move animation.\n\t *\n\t * ### Class-based transition animations\n\t *\n\t * Class-based transitions refer to transition animations that are triggered when a CSS class is\n\t * added to or removed from the element (via `$animate.addClass`, `$animate.removeClass`,\n\t * `$animate.setClass`, or by directives such as `ngClass`, `ngModel` and `form`).\n\t * They are different when compared to structural animations since they **do not cancel existing\n\t * animations** nor do they **block successive transitions** from rendering on the same element.\n\t * This distinction allows for **multiple class-based transitions** to be performed on the same element.\n\t *\n\t * In addition to ngAnimate supporting the default (natural) functionality of class-based transition\n\t * animations, ngAnimate also decorates the element with starting and ending CSS classes to aid the\n\t * developer in further styling the element throughout the transition animation. Earlier versions\n\t * of ngAnimate may have caused natural CSS transitions to break and not render properly due to\n\t * $animate temporarily blocking transitions using `0s none` in order to allow the setup CSS class\n\t * (the `-add` or `-remove` class) to be applied without triggering an animation. However, as of\n\t * **version 1.3**, this workaround has been removed with ngAnimate and all non-ngAnimate CSS\n\t * class transitions are compatible with ngAnimate.\n\t *\n\t * There is, however, one special case when dealing with class-based transitions in ngAnimate.\n\t * When rendering class-based transitions that make use of the setup and active CSS classes\n\t * (e.g. `.fade-add` and `.fade-add-active` for when `.fade` is added) be sure to define\n\t * the transition value **on the active CSS class** and not the setup class.\n\t *\n\t * ```css\n\t * .fade-add {\n\t *   /&#42; remember to place a 0s transition here\n\t *      to ensure that the styles are applied instantly\n\t *      even if the element already has a transition style &#42;/\n\t *   transition:0s linear all;\n\t *\n\t *   /&#42; starting CSS styles &#42;/\n\t *   opacity:1;\n\t * }\n\t * .fade-add.fade-add-active {\n\t *   /&#42; this will be the length of the animation &#42;/\n\t *   transition:1s linear all;\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * The setup CSS class (in this case `.fade-add`) also has a transition style property, however, it\n\t * has a duration of zero. This may not be required, however, incase the browser is unable to render\n\t * the styling present in this CSS class instantly then it could be that the browser is attempting\n\t * to perform an unnecessary transition.\n\t *\n\t * This workaround, however, does not apply to  standard class-based transitions that are rendered\n\t * when a CSS class containing a transition is applied to an element:\n\t *\n\t * ```css\n\t * /&#42; this works as expected &#42;/\n\t * .fade {\n\t *   transition:1s linear all;\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * Please keep this in mind when coding the CSS markup that will be used within class-based transitions.\n\t * Also, try not to mix the two class-based animation flavors together since the CSS code may become\n\t * overly complex.\n\t *\n\t *\n\t * ### Preventing Collisions With Third Party Libraries\n\t *\n\t * Some third-party frameworks place animation duration defaults across many element or className\n\t * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n\t * is expecting actual animations on these elements and has to wait for their completion.\n\t *\n\t * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n\t *\n\t * ```css\n\t * /&#42; prefixed with animate- &#42;/\n\t * .animate-fade-add.animate-fade-add-active {\n\t *   transition:1s linear all;\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * You then configure `$animate` to enforce this prefix:\n\t *\n\t * ```js\n\t * $animateProvider.classNameFilter(/animate-/);\n\t * ```\n\t * </div>\n\t *\n\t * ### CSS Staggering Animations\n\t * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n\t * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n\t * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n\t * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n\t * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n\t *\n\t * ```css\n\t * .my-animation.ng-enter {\n\t *   /&#42; standard transition code &#42;/\n\t *   -webkit-transition: 1s linear all;\n\t *   transition: 1s linear all;\n\t *   opacity:0;\n\t * }\n\t * .my-animation.ng-enter-stagger {\n\t *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n\t *   -webkit-transition-delay: 0.1s;\n\t *   transition-delay: 0.1s;\n\t *\n\t *   /&#42; in case the stagger doesn't work then these two values\n\t *    must be set to 0 to avoid an accidental CSS inheritance &#42;/\n\t *   -webkit-transition-duration: 0s;\n\t *   transition-duration: 0s;\n\t * }\n\t * .my-animation.ng-enter.ng-enter-active {\n\t *   /&#42; standard transition styles &#42;/\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n\t * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n\t * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n\t * will also be reset if more than 10ms has passed after the last animation has been fired.\n\t *\n\t * The following code will issue the **ng-leave-stagger** event on the element provided:\n\t *\n\t * ```js\n\t * var kids = parent.children();\n\t *\n\t * $animate.leave(kids[0]); //stagger index=0\n\t * $animate.leave(kids[1]); //stagger index=1\n\t * $animate.leave(kids[2]); //stagger index=2\n\t * $animate.leave(kids[3]); //stagger index=3\n\t * $animate.leave(kids[4]); //stagger index=4\n\t *\n\t * $timeout(function() {\n\t *   //stagger has reset itself\n\t *   $animate.leave(kids[5]); //stagger index=0\n\t *   $animate.leave(kids[6]); //stagger index=1\n\t * }, 100, false);\n\t * ```\n\t *\n\t * Stagger animations are currently only supported within CSS-defined animations.\n\t *\n\t * ## JavaScript-defined Animations\n\t * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not\n\t * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.\n\t *\n\t * ```js\n\t * //!annotate=\"YourApp\" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.\n\t * var ngModule = angular.module('YourApp', ['ngAnimate']);\n\t * ngModule.animation('.my-crazy-animation', function() {\n\t *   return {\n\t *     enter: function(element, done) {\n\t *       //run the animation here and call done when the animation is complete\n\t *       return function(cancelled) {\n\t *         //this (optional) function will be called when the animation\n\t *         //completes or when the animation is cancelled (the cancelled\n\t *         //flag will be set to true if cancelled).\n\t *       };\n\t *     },\n\t *     leave: function(element, done) { },\n\t *     move: function(element, done) { },\n\t *\n\t *     //animation that can be triggered before the class is added\n\t *     beforeAddClass: function(element, className, done) { },\n\t *\n\t *     //animation that can be triggered after the class is added\n\t *     addClass: function(element, className, done) { },\n\t *\n\t *     //animation that can be triggered before the class is removed\n\t *     beforeRemoveClass: function(element, className, done) { },\n\t *\n\t *     //animation that can be triggered after the class is removed\n\t *     removeClass: function(element, className, done) { }\n\t *   };\n\t * });\n\t * ```\n\t *\n\t * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run\n\t * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits\n\t * the element's CSS class attribute value and then run the matching animation event function (if found).\n\t * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will\n\t * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).\n\t *\n\t * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.\n\t * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,\n\t * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation\n\t * or transition code that is defined via a stylesheet).\n\t *\n\t *\n\t * ### Applying Directive-specific Styles to an Animation\n\t * In some cases a directive or service may want to provide `$animate` with extra details that the animation will\n\t * include into its animation. Let's say for example we wanted to render an animation that animates an element\n\t * towards the mouse coordinates as to where the user clicked last. By collecting the X/Y coordinates of the click\n\t * (via the event parameter) we can set the `top` and `left` styles into an object and pass that into our function\n\t * call to `$animate.addClass`.\n\t *\n\t * ```js\n\t * canvas.on('click', function(e) {\n\t *   $animate.addClass(element, 'on', {\n\t *     to: {\n\t *       left : e.client.x + 'px',\n\t *       top : e.client.y + 'px'\n\t *     }\n\t *   }):\n\t * });\n\t * ```\n\t *\n\t * Now when the animation runs, and a transition or keyframe animation is picked up, then the animation itself will\n\t * also include and transition the styling of the `left` and `top` properties into its running animation. If we want\n\t * to provide some starting animation values then we can do so by placing the starting animations styles into an object\n\t * called `from` in the same object as the `to` animations.\n\t *\n\t * ```js\n\t * canvas.on('click', function(e) {\n\t *   $animate.addClass(element, 'on', {\n\t *     from: {\n\t *        position: 'absolute',\n\t *        left: '0px',\n\t *        top: '0px'\n\t *     },\n\t *     to: {\n\t *       left : e.client.x + 'px',\n\t *       top : e.client.y + 'px'\n\t *     }\n\t *   }):\n\t * });\n\t * ```\n\t *\n\t * Once the animation is complete or cancelled then the union of both the before and after styles are applied to the\n\t * element. If `ngAnimate` is not present then the styles will be applied immediately.\n\t *\n\t */\n\t\n\tangular.module('ngAnimate', ['ng'])\n\t\n\t  /**\n\t   * @ngdoc provider\n\t   * @name $animateProvider\n\t   * @description\n\t   *\n\t   * The `$animateProvider` allows developers to register JavaScript animation event handlers directly inside of a module.\n\t   * When an animation is triggered, the $animate service will query the $animate service to find any animations that match\n\t   * the provided name value.\n\t   *\n\t   * Requires the {@link ngAnimate `ngAnimate`} module to be installed.\n\t   *\n\t   * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.\n\t   *\n\t   */\n\t  .directive('ngAnimateChildren', function() {\n\t    var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';\n\t    return function(scope, element, attrs) {\n\t      var val = attrs.ngAnimateChildren;\n\t      if (angular.isString(val) && val.length === 0) { //empty attribute\n\t        element.data(NG_ANIMATE_CHILDREN, true);\n\t      } else {\n\t        scope.$watch(val, function(value) {\n\t          element.data(NG_ANIMATE_CHILDREN, !!value);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  //this private service is only used within CSS-enabled animations\n\t  //IE8 + IE9 do not support rAF natively, but that is fine since they\n\t  //also don't support transitions and keyframes which means that the code\n\t  //below will never be used by the two browsers.\n\t  .factory('$$animateReflow', ['$$rAF', '$document', function($$rAF, $document) {\n\t    var bod = $document[0].body;\n\t    return function(fn) {\n\t      //the returned function acts as the cancellation function\n\t      return $$rAF(function() {\n\t        //the line below will force the browser to perform a repaint\n\t        //so that all the animated elements within the animation frame\n\t        //will be properly updated and drawn on screen. This is\n\t        //required to perform multi-class CSS based animations with\n\t        //Firefox. DO NOT REMOVE THIS LINE.\n\t        var a = bod.offsetWidth + 1;\n\t        fn();\n\t      });\n\t    };\n\t  }])\n\t\n\t  .config(['$provide', '$animateProvider', function($provide, $animateProvider) {\n\t    var noop = angular.noop;\n\t    var forEach = angular.forEach;\n\t    var selectors = $animateProvider.$$selectors;\n\t    var isArray = angular.isArray;\n\t    var isString = angular.isString;\n\t    var isObject = angular.isObject;\n\t\n\t    var ELEMENT_NODE = 1;\n\t    var NG_ANIMATE_STATE = '$$ngAnimateState';\n\t    var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';\n\t    var NG_ANIMATE_CLASS_NAME = 'ng-animate';\n\t    var rootAnimateState = {running: true};\n\t\n\t    function extractElementNode(element) {\n\t      for (var i = 0; i < element.length; i++) {\n\t        var elm = element[i];\n\t        if (elm.nodeType == ELEMENT_NODE) {\n\t          return elm;\n\t        }\n\t      }\n\t    }\n\t\n\t    function prepareElement(element) {\n\t      return element && angular.element(element);\n\t    }\n\t\n\t    function stripCommentsFromElement(element) {\n\t      return angular.element(extractElementNode(element));\n\t    }\n\t\n\t    function isMatchingElement(elm1, elm2) {\n\t      return extractElementNode(elm1) == extractElementNode(elm2);\n\t    }\n\t    var $$jqLite;\n\t    $provide.decorator('$animate',\n\t        ['$delegate', '$$q', '$injector', '$sniffer', '$rootElement', '$$asyncCallback', '$rootScope', '$document', '$templateRequest', '$$jqLite',\n\t function($delegate,   $$q,   $injector,   $sniffer,   $rootElement,   $$asyncCallback,   $rootScope,   $document,   $templateRequest,   $$$jqLite) {\n\t\n\t      $$jqLite = $$$jqLite;\n\t      $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);\n\t\n\t      // Wait until all directive and route-related templates are downloaded and\n\t      // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n\t      // all of the remote templates being currently downloaded. If there are no\n\t      // templates currently downloading then the watcher will still fire anyway.\n\t      var deregisterWatch = $rootScope.$watch(\n\t        function() { return $templateRequest.totalPendingRequests; },\n\t        function(val, oldVal) {\n\t          if (val !== 0) return;\n\t          deregisterWatch();\n\t\n\t          // Now that all templates have been downloaded, $animate will wait until\n\t          // the post digest queue is empty before enabling animations. By having two\n\t          // calls to $postDigest calls we can ensure that the flag is enabled at the\n\t          // very end of the post digest queue. Since all of the animations in $animate\n\t          // use $postDigest, it's important that the code below executes at the end.\n\t          // This basically means that the page is fully downloaded and compiled before\n\t          // any animations are triggered.\n\t          $rootScope.$$postDigest(function() {\n\t            $rootScope.$$postDigest(function() {\n\t              rootAnimateState.running = false;\n\t            });\n\t          });\n\t        }\n\t      );\n\t\n\t      var globalAnimationCounter = 0;\n\t      var classNameFilter = $animateProvider.classNameFilter();\n\t      var isAnimatableClassName = !classNameFilter\n\t              ? function() { return true; }\n\t              : function(className) {\n\t                return classNameFilter.test(className);\n\t              };\n\t\n\t      function classBasedAnimationsBlocked(element, setter) {\n\t        var data = element.data(NG_ANIMATE_STATE) || {};\n\t        if (setter) {\n\t          data.running = true;\n\t          data.structural = true;\n\t          element.data(NG_ANIMATE_STATE, data);\n\t        }\n\t        return data.disabled || (data.running && data.structural);\n\t      }\n\t\n\t      function runAnimationPostDigest(fn) {\n\t        var cancelFn, defer = $$q.defer();\n\t        defer.promise.$$cancelFn = function() {\n\t          cancelFn && cancelFn();\n\t        };\n\t        $rootScope.$$postDigest(function() {\n\t          cancelFn = fn(function() {\n\t            defer.resolve();\n\t          });\n\t        });\n\t        return defer.promise;\n\t      }\n\t\n\t      function parseAnimateOptions(options) {\n\t        // some plugin code may still be passing in the callback\n\t        // function as the last param for the $animate methods so\n\t        // it's best to only allow string or array values for now\n\t        if (isObject(options)) {\n\t          if (options.tempClasses && isString(options.tempClasses)) {\n\t            options.tempClasses = options.tempClasses.split(/\\s+/);\n\t          }\n\t          return options;\n\t        }\n\t      }\n\t\n\t      function resolveElementClasses(element, cache, runningAnimations) {\n\t        runningAnimations = runningAnimations || {};\n\t\n\t        var lookup = {};\n\t        forEach(runningAnimations, function(data, selector) {\n\t          forEach(selector.split(' '), function(s) {\n\t            lookup[s]=data;\n\t          });\n\t        });\n\t\n\t        var hasClasses = Object.create(null);\n\t        forEach((element.attr('class') || '').split(/\\s+/), function(className) {\n\t          hasClasses[className] = true;\n\t        });\n\t\n\t        var toAdd = [], toRemove = [];\n\t        forEach((cache && cache.classes) || [], function(status, className) {\n\t          var hasClass = hasClasses[className];\n\t          var matchingAnimation = lookup[className] || {};\n\t\n\t          // When addClass and removeClass is called then $animate will check to\n\t          // see if addClass and removeClass cancel each other out. When there are\n\t          // more calls to removeClass than addClass then the count falls below 0\n\t          // and then the removeClass animation will be allowed. Otherwise if the\n\t          // count is above 0 then that means an addClass animation will commence.\n\t          // Once an animation is allowed then the code will also check to see if\n\t          // there exists any on-going animation that is already adding or remvoing\n\t          // the matching CSS class.\n\t          if (status === false) {\n\t            //does it have the class or will it have the class\n\t            if (hasClass || matchingAnimation.event == 'addClass') {\n\t              toRemove.push(className);\n\t            }\n\t          } else if (status === true) {\n\t            //is the class missing or will it be removed?\n\t            if (!hasClass || matchingAnimation.event == 'removeClass') {\n\t              toAdd.push(className);\n\t            }\n\t          }\n\t        });\n\t\n\t        return (toAdd.length + toRemove.length) > 0 && [toAdd.join(' '), toRemove.join(' ')];\n\t      }\n\t\n\t      function lookup(name) {\n\t        if (name) {\n\t          var matches = [],\n\t              flagMap = {},\n\t              classes = name.substr(1).split('.');\n\t\n\t          //the empty string value is the default animation\n\t          //operation which performs CSS transition and keyframe\n\t          //animations sniffing. This is always included for each\n\t          //element animation procedure if the browser supports\n\t          //transitions and/or keyframe animations. The default\n\t          //animation is added to the top of the list to prevent\n\t          //any previous animations from affecting the element styling\n\t          //prior to the element being animated.\n\t          if ($sniffer.transitions || $sniffer.animations) {\n\t            matches.push($injector.get(selectors['']));\n\t          }\n\t\n\t          for (var i=0; i < classes.length; i++) {\n\t            var klass = classes[i],\n\t                selectorFactoryName = selectors[klass];\n\t            if (selectorFactoryName && !flagMap[klass]) {\n\t              matches.push($injector.get(selectorFactoryName));\n\t              flagMap[klass] = true;\n\t            }\n\t          }\n\t          return matches;\n\t        }\n\t      }\n\t\n\t      function animationRunner(element, animationEvent, className, options) {\n\t        //transcluded directives may sometimes fire an animation using only comment nodes\n\t        //best to catch this early on to prevent any animation operations from occurring\n\t        var node = element[0];\n\t        if (!node) {\n\t          return;\n\t        }\n\t\n\t        if (options) {\n\t          options.to = options.to || {};\n\t          options.from = options.from || {};\n\t        }\n\t\n\t        var classNameAdd;\n\t        var classNameRemove;\n\t        if (isArray(className)) {\n\t          classNameAdd = className[0];\n\t          classNameRemove = className[1];\n\t          if (!classNameAdd) {\n\t            className = classNameRemove;\n\t            animationEvent = 'removeClass';\n\t          } else if (!classNameRemove) {\n\t            className = classNameAdd;\n\t            animationEvent = 'addClass';\n\t          } else {\n\t            className = classNameAdd + ' ' + classNameRemove;\n\t          }\n\t        }\n\t\n\t        var isSetClassOperation = animationEvent == 'setClass';\n\t        var isClassBased = isSetClassOperation\n\t                           || animationEvent == 'addClass'\n\t                           || animationEvent == 'removeClass'\n\t                           || animationEvent == 'animate';\n\t\n\t        var currentClassName = element.attr('class');\n\t        var classes = currentClassName + ' ' + className;\n\t        if (!isAnimatableClassName(classes)) {\n\t          return;\n\t        }\n\t\n\t        var beforeComplete = noop,\n\t            beforeCancel = [],\n\t            before = [],\n\t            afterComplete = noop,\n\t            afterCancel = [],\n\t            after = [];\n\t\n\t        var animationLookup = (' ' + classes).replace(/\\s+/g,'.');\n\t        forEach(lookup(animationLookup), function(animationFactory) {\n\t          var created = registerAnimation(animationFactory, animationEvent);\n\t          if (!created && isSetClassOperation) {\n\t            registerAnimation(animationFactory, 'addClass');\n\t            registerAnimation(animationFactory, 'removeClass');\n\t          }\n\t        });\n\t\n\t        function registerAnimation(animationFactory, event) {\n\t          var afterFn = animationFactory[event];\n\t          var beforeFn = animationFactory['before' + event.charAt(0).toUpperCase() + event.substr(1)];\n\t          if (afterFn || beforeFn) {\n\t            if (event == 'leave') {\n\t              beforeFn = afterFn;\n\t              //when set as null then animation knows to skip this phase\n\t              afterFn = null;\n\t            }\n\t            after.push({\n\t              event: event, fn: afterFn\n\t            });\n\t            before.push({\n\t              event: event, fn: beforeFn\n\t            });\n\t            return true;\n\t          }\n\t        }\n\t\n\t        function run(fns, cancellations, allCompleteFn) {\n\t          var animations = [];\n\t          forEach(fns, function(animation) {\n\t            animation.fn && animations.push(animation);\n\t          });\n\t\n\t          var count = 0;\n\t          function afterAnimationComplete(index) {\n\t            if (cancellations) {\n\t              (cancellations[index] || noop)();\n\t              if (++count < animations.length) return;\n\t              cancellations = null;\n\t            }\n\t            allCompleteFn();\n\t          }\n\t\n\t          //The code below adds directly to the array in order to work with\n\t          //both sync and async animations. Sync animations are when the done()\n\t          //operation is called right away. DO NOT REFACTOR!\n\t          forEach(animations, function(animation, index) {\n\t            var progress = function() {\n\t              afterAnimationComplete(index);\n\t            };\n\t            switch (animation.event) {\n\t              case 'setClass':\n\t                cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));\n\t                break;\n\t              case 'animate':\n\t                cancellations.push(animation.fn(element, className, options.from, options.to, progress));\n\t                break;\n\t              case 'addClass':\n\t                cancellations.push(animation.fn(element, classNameAdd || className,     progress, options));\n\t                break;\n\t              case 'removeClass':\n\t                cancellations.push(animation.fn(element, classNameRemove || className,  progress, options));\n\t                break;\n\t              default:\n\t                cancellations.push(animation.fn(element, progress, options));\n\t                break;\n\t            }\n\t          });\n\t\n\t          if (cancellations && cancellations.length === 0) {\n\t            allCompleteFn();\n\t          }\n\t        }\n\t\n\t        return {\n\t          node: node,\n\t          event: animationEvent,\n\t          className: className,\n\t          isClassBased: isClassBased,\n\t          isSetClassOperation: isSetClassOperation,\n\t          applyStyles: function() {\n\t            if (options) {\n\t              element.css(angular.extend(options.from || {}, options.to || {}));\n\t            }\n\t          },\n\t          before: function(allCompleteFn) {\n\t            beforeComplete = allCompleteFn;\n\t            run(before, beforeCancel, function() {\n\t              beforeComplete = noop;\n\t              allCompleteFn();\n\t            });\n\t          },\n\t          after: function(allCompleteFn) {\n\t            afterComplete = allCompleteFn;\n\t            run(after, afterCancel, function() {\n\t              afterComplete = noop;\n\t              allCompleteFn();\n\t            });\n\t          },\n\t          cancel: function() {\n\t            if (beforeCancel) {\n\t              forEach(beforeCancel, function(cancelFn) {\n\t                (cancelFn || noop)(true);\n\t              });\n\t              beforeComplete(true);\n\t            }\n\t            if (afterCancel) {\n\t              forEach(afterCancel, function(cancelFn) {\n\t                (cancelFn || noop)(true);\n\t              });\n\t              afterComplete(true);\n\t            }\n\t          }\n\t        };\n\t      }\n\t\n\t      /**\n\t       * @ngdoc service\n\t       * @name $animate\n\t       * @kind object\n\t       *\n\t       * @description\n\t       * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.\n\t       * When any of these operations are run, the $animate service\n\t       * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)\n\t       * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.\n\t       *\n\t       * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives\n\t       * will work out of the box without any extra configuration.\n\t       *\n\t       * Requires the {@link ngAnimate `ngAnimate`} module to be installed.\n\t       *\n\t       * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.\n\t       * ## Callback Promises\n\t       * With AngularJS 1.3, each of the animation methods, on the `$animate` service, return a promise when called. The\n\t       * promise itself is then resolved once the animation has completed itself, has been cancelled or has been\n\t       * skipped due to animations being disabled. (Note that even if the animation is cancelled it will still\n\t       * call the resolve function of the animation.)\n\t       *\n\t       * ```js\n\t       * $animate.enter(element, container).then(function() {\n\t       *   //...this is called once the animation is complete...\n\t       * });\n\t       * ```\n\t       *\n\t       * Also note that, due to the nature of the callback promise, if any Angular-specific code (like changing the scope,\n\t       * location of the page, etc...) is executed within the callback promise then be sure to wrap the code using\n\t       * `$scope.$apply(...)`;\n\t       *\n\t       * ```js\n\t       * $animate.leave(element).then(function() {\n\t       *   $scope.$apply(function() {\n\t       *     $location.path('/new-page');\n\t       *   });\n\t       * });\n\t       * ```\n\t       *\n\t       * An animation can also be cancelled by calling the `$animate.cancel(promise)` method with the provided\n\t       * promise that was returned when the animation was started.\n\t       *\n\t       * ```js\n\t       * var promise = $animate.addClass(element, 'super-long-animation');\n\t       * promise.then(function() {\n\t       *   //this will still be called even if cancelled\n\t       * });\n\t       *\n\t       * element.on('click', function() {\n\t       *   //tooo lazy to wait for the animation to end\n\t       *   $animate.cancel(promise);\n\t       * });\n\t       * ```\n\t       *\n\t       * (Keep in mind that the promise cancellation is unique to `$animate` since promises in\n\t       * general cannot be cancelled.)\n\t       *\n\t       */\n\t      return {\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#animate\n\t         * @kind function\n\t         *\n\t         * @description\n\t         * Performs an inline animation on the element which applies the provided `to` and `from` CSS styles to the element.\n\t         * If any detected CSS transition, keyframe or JavaScript matches the provided `className` value then the animation\n\t         * will take on the provided styles. For example, if a transition animation is set for the given className then the\n\t         * provided `from` and `to` styles will be applied alongside the given transition. If a JavaScript animation is\n\t         * detected then the provided styles will be given in as function paramters.\n\t         *\n\t         * ```js\n\t         * ngModule.animation('.my-inline-animation', function() {\n\t         *   return {\n\t         *     animate : function(element, className, from, to, done) {\n\t         *       //styles\n\t         *     }\n\t         *   }\n\t         * });\n\t         * ```\n\t         *\n\t         * Below is a breakdown of each step that occurs during the `animate` animation:\n\t         *\n\t         * | Animation Step                                                                                                        | What the element class attribute looks like                  |\n\t         * |-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------|\n\t         * | 1. `$animate.animate(...)` is called                                                                                  | `class=\"my-animation\"`                                       |\n\t         * | 2. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                            |\n\t         * | 3. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                            |\n\t         * | 4. the `className` class value is added to the element                                                                | `class=\"my-animation ng-animate className\"`                  |\n\t         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate className\"`                  |\n\t         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.className` class styling is applied right away| `class=\"my-animation ng-animate className\"`                  |\n\t         * | 7. `$animate` applies the provided collection of `from` CSS styles to the element                                     | `class=\"my-animation ng-animate className\"`                  |\n\t         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate className\"`                  |\n\t         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate className\"`                  |\n\t         * | 10. the `className-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate className className-active\"` |\n\t         * | 11. `$animate` applies the collection of `to` CSS styles to the element which are then handled by the transition      | `class=\"my-animation ng-animate className className-active\"` |\n\t         * | 12. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate className className-active\"` |\n\t         * | 13. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                       |\n\t         * | 14. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                       |\n\t         *\n\t         * @param {DOMElement} element the element that will be the focus of the enter animation\n\t         * @param {object} from a collection of CSS styles that will be applied to the element at the start of the animation\n\t         * @param {object} to a collection of CSS styles that the element will animate towards\n\t         * @param {string=} className an optional CSS class that will be added to the element for the duration of the animation (the default class is `ng-inline-animate`)\n\t         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        animate: function(element, from, to, className, options) {\n\t          className = className || 'ng-inline-animate';\n\t          options = parseAnimateOptions(options) || {};\n\t          options.from = to ? from : null;\n\t          options.to   = to ? to : from;\n\t\n\t          return runAnimationPostDigest(function(done) {\n\t            return performAnimation('animate', className, stripCommentsFromElement(element), null, null, noop, options, done);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#enter\n\t         * @kind function\n\t         *\n\t         * @description\n\t         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once\n\t         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:\n\t         *\n\t         * Below is a breakdown of each step that occurs during enter animation:\n\t         *\n\t         * | Animation Step                                                                                                        | What the element class attribute looks like                |\n\t         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|\n\t         * | 1. `$animate.enter(...)` is called                                                                                    | `class=\"my-animation\"`                                     |\n\t         * | 2. element is inserted into the `parentElement` element or beside the `afterElement` element                          | `class=\"my-animation\"`                                     |\n\t         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                          |\n\t         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                          |\n\t         * | 5. the `.ng-enter` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-enter\"`                 |\n\t         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate ng-enter\"`                 |\n\t         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-enter` class styling is applied right away | `class=\"my-animation ng-animate ng-enter\"`                 |\n\t         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate ng-enter\"`                 |\n\t         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate ng-enter\"`                 |\n\t         * | 10. the `.ng-enter-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate ng-enter ng-enter-active\"` |\n\t         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate ng-enter ng-enter-active\"` |\n\t         * | 12. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                     |\n\t         * | 13. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                     |\n\t         *\n\t         * @param {DOMElement} element the element that will be the focus of the enter animation\n\t         * @param {DOMElement} parentElement the parent element of the element that will be the focus of the enter animation\n\t         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation\n\t         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        enter: function(element, parentElement, afterElement, options) {\n\t          options = parseAnimateOptions(options);\n\t          element = angular.element(element);\n\t          parentElement = prepareElement(parentElement);\n\t          afterElement = prepareElement(afterElement);\n\t\n\t          classBasedAnimationsBlocked(element, true);\n\t          $delegate.enter(element, parentElement, afterElement);\n\t          return runAnimationPostDigest(function(done) {\n\t            return performAnimation('enter', 'ng-enter', stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#leave\n\t         * @kind function\n\t         *\n\t         * @description\n\t         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once\n\t         * the animation is started, the following CSS classes will be added for the duration of the animation:\n\t         *\n\t         * Below is a breakdown of each step that occurs during leave animation:\n\t         *\n\t         * | Animation Step                                                                                                        | What the element class attribute looks like                |\n\t         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|\n\t         * | 1. `$animate.leave(...)` is called                                                                                    | `class=\"my-animation\"`                                     |\n\t         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                          |\n\t         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                          |\n\t         * | 4. the `.ng-leave` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-leave\"`                 |\n\t         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate ng-leave\"`                 |\n\t         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.ng-leave` class styling is applied right away | `class=\"my-animation ng-animate ng-leave\"`                 |\n\t         * | 7. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate ng-leave\"`                 |\n\t         * | 8. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate ng-leave\"`                 |\n\t         * | 9. the `.ng-leave-active` class is added (this triggers the CSS transition/animation)                                 | `class=\"my-animation ng-animate ng-leave ng-leave-active\"` |\n\t         * | 10. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate ng-leave ng-leave-active\"` |\n\t         * | 11. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                     |\n\t         * | 12. The element is removed from the DOM                                                                               | ...                                                        |\n\t         * | 13. The returned promise is resolved.                                                                                 | ...                                                        |\n\t         *\n\t         * @param {DOMElement} element the element that will be the focus of the leave animation\n\t         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        leave: function(element, options) {\n\t          options = parseAnimateOptions(options);\n\t          element = angular.element(element);\n\t\n\t          cancelChildAnimations(element);\n\t          classBasedAnimationsBlocked(element, true);\n\t          return runAnimationPostDigest(function(done) {\n\t            return performAnimation('leave', 'ng-leave', stripCommentsFromElement(element), null, null, function() {\n\t              $delegate.leave(element);\n\t            }, options, done);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#move\n\t         * @kind function\n\t         *\n\t         * @description\n\t         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or\n\t         * add the element directly after the afterElement element if present. Then the move animation will be run. Once\n\t         * the animation is started, the following CSS classes will be added for the duration of the animation:\n\t         *\n\t         * Below is a breakdown of each step that occurs during move animation:\n\t         *\n\t         * | Animation Step                                                                                                       | What the element class attribute looks like              |\n\t         * |----------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|\n\t         * | 1. `$animate.move(...)` is called                                                                                    | `class=\"my-animation\"`                                   |\n\t         * | 2. element is moved into the parentElement element or beside the afterElement element                                | `class=\"my-animation\"`                                   |\n\t         * | 3. `$animate` waits for the next digest to start the animation                                                       | `class=\"my-animation ng-animate\"`                        |\n\t         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class=\"my-animation ng-animate\"`                        |\n\t         * | 5. the `.ng-move` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-move\"`                |\n\t         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class=\"my-animation ng-animate ng-move\"`                |\n\t         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-move` class styling is applied right away | `class=\"my-animation ng-animate ng-move\"`                |\n\t         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class=\"my-animation ng-animate ng-move\"`                |\n\t         * | 9. `$animate` removes the CSS transition block placed on the element                                                 | `class=\"my-animation ng-animate ng-move\"`                |\n\t         * | 10. the `.ng-move-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate ng-move ng-move-active\"` |\n\t         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                          | `class=\"my-animation ng-animate ng-move ng-move-active\"` |\n\t         * | 12. The animation ends and all generated CSS classes are removed from the element                                    | `class=\"my-animation\"`                                   |\n\t         * | 13. The returned promise is resolved.                                                                                | `class=\"my-animation\"`                                   |\n\t         *\n\t         * @param {DOMElement} element the element that will be the focus of the move animation\n\t         * @param {DOMElement} parentElement the parentElement element of the element that will be the focus of the move animation\n\t         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation\n\t         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        move: function(element, parentElement, afterElement, options) {\n\t          options = parseAnimateOptions(options);\n\t          element = angular.element(element);\n\t          parentElement = prepareElement(parentElement);\n\t          afterElement = prepareElement(afterElement);\n\t\n\t          cancelChildAnimations(element);\n\t          classBasedAnimationsBlocked(element, true);\n\t          $delegate.move(element, parentElement, afterElement);\n\t          return runAnimationPostDigest(function(done) {\n\t            return performAnimation('move', 'ng-move', stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#addClass\n\t         *\n\t         * @description\n\t         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.\n\t         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide\n\t         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions\n\t         * or keyframes are defined on the -add-active or base CSS class).\n\t         *\n\t         * Below is a breakdown of each step that occurs during addClass animation:\n\t         *\n\t         * | Animation Step                                                                                         | What the element class attribute looks like                        |\n\t         * |--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n\t         * | 1. `$animate.addClass(element, 'super')` is called                                                     | `class=\"my-animation\"`                                             |\n\t         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                           | `class=\"my-animation ng-animate\"`                                  |\n\t         * | 3. the `.super-add` class is added to the element                                                      | `class=\"my-animation ng-animate super-add\"`                        |\n\t         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                              | `class=\"my-animation ng-animate super-add\"`                        |\n\t         * | 5. the `.super` and `.super-add-active` classes are added (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n\t         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay          | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n\t         * | 7. `$animate` waits for the animation to complete (via events and timeout)                             | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n\t         * | 8. The animation ends and all generated CSS classes are removed from the element                       | `class=\"my-animation super\"`                                       |\n\t         * | 9. The super class is kept on the element                                                              | `class=\"my-animation super\"`                                       |\n\t         * | 10. The returned promise is resolved.                                                                  | `class=\"my-animation super\"`                                       |\n\t         *\n\t         * @param {DOMElement} element the element that will be animated\n\t         * @param {string} className the CSS class that will be added to the element and then animated\n\t         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        addClass: function(element, className, options) {\n\t          return this.setClass(element, className, [], options);\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#removeClass\n\t         *\n\t         * @description\n\t         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value\n\t         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in\n\t         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if\n\t         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).\n\t         *\n\t         * Below is a breakdown of each step that occurs during removeClass animation:\n\t         *\n\t         * | Animation Step                                                                                                       | What the element class attribute looks like                        |\n\t         * |----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n\t         * | 1. `$animate.removeClass(element, 'super')` is called                                                                | `class=\"my-animation super\"`                                       |\n\t         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class=\"my-animation super ng-animate\"`                            |\n\t         * | 3. the `.super-remove` class is added to the element                                                                 | `class=\"my-animation super ng-animate super-remove\"`               |\n\t         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class=\"my-animation super ng-animate super-remove\"`               |\n\t         * | 5. the `.super-remove-active` classes are added and `.super` is removed (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n\t         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n\t         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n\t         * | 8. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                             |\n\t         * | 9. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                             |\n\t         *\n\t         *\n\t         * @param {DOMElement} element the element that will be animated\n\t         * @param {string} className the CSS class that will be animated and then removed from the element\n\t         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t        */\n\t        removeClass: function(element, className, options) {\n\t          return this.setClass(element, [], className, options);\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @ngdoc method\n\t         * @name $animate#setClass\n\t         *\n\t         * @description Adds and/or removes the given CSS classes to and from the element.\n\t         * Once complete, the `done()` callback will be fired (if provided).\n\t         *\n\t         * | Animation Step                                                                                                                               | What the element class attribute looks like                                            |\n\t         * |----------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|\n\t         * | 1. `$animate.setClass(element, 'on', 'off')` is called                                                                                       | `class=\"my-animation off\"`                                                             |\n\t         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                                                 | `class=\"my-animation ng-animate off\"`                                                  |\n\t         * | 3. the `.on-add` and `.off-remove` classes are added to the element                                                                          | `class=\"my-animation ng-animate on-add off-remove off\"`                                |\n\t         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                                                    | `class=\"my-animation ng-animate on-add off-remove off\"`                                |\n\t         * | 5. the `.on`, `.on-add-active` and `.off-remove-active` classes are added and `.off` is removed (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n\t         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                                                | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n\t         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                                                   | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n\t         * | 8. The animation ends and all generated CSS classes are removed from the element                                                             | `class=\"my-animation on\"`                                                              |\n\t         * | 9. The returned promise is resolved.                                                                                                         | `class=\"my-animation on\"`                                                              |\n\t         *\n\t         * @param {DOMElement} element the element which will have its CSS classes changed\n\t         *   removed from it\n\t         * @param {string} add the CSS classes which will be added to the element\n\t         * @param {string} remove the CSS class which will be removed from the element\n\t         *   CSS classes have been set on the element\n\t         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n\t         * @return {Promise} the animation callback promise\n\t         */\n\t        setClass: function(element, add, remove, options) {\n\t          options = parseAnimateOptions(options);\n\t\n\t          var STORAGE_KEY = '$$animateClasses';\n\t          element = angular.element(element);\n\t          element = stripCommentsFromElement(element);\n\t\n\t          if (classBasedAnimationsBlocked(element)) {\n\t            return $delegate.$$setClassImmediately(element, add, remove, options);\n\t          }\n\t\n\t          // we're using a combined array for both the add and remove\n\t          // operations since the ORDER OF addClass and removeClass matters\n\t          var classes, cache = element.data(STORAGE_KEY);\n\t          var hasCache = !!cache;\n\t          if (!cache) {\n\t            cache = {};\n\t            cache.classes = {};\n\t          }\n\t          classes = cache.classes;\n\t\n\t          add = isArray(add) ? add : add.split(' ');\n\t          forEach(add, function(c) {\n\t            if (c && c.length) {\n\t              classes[c] = true;\n\t            }\n\t          });\n\t\n\t          remove = isArray(remove) ? remove : remove.split(' ');\n\t          forEach(remove, function(c) {\n\t            if (c && c.length) {\n\t              classes[c] = false;\n\t            }\n\t          });\n\t\n\t          if (hasCache) {\n\t            if (options && cache.options) {\n\t              cache.options = angular.extend(cache.options || {}, options);\n\t            }\n\t\n\t            //the digest cycle will combine all the animations into one function\n\t            return cache.promise;\n\t          } else {\n\t            element.data(STORAGE_KEY, cache = {\n\t              classes: classes,\n\t              options: options\n\t            });\n\t          }\n\t\n\t          return cache.promise = runAnimationPostDigest(function(done) {\n\t            var parentElement = element.parent();\n\t            var elementNode = extractElementNode(element);\n\t            var parentNode = elementNode.parentNode;\n\t            // TODO(matsko): move this code into the animationsDisabled() function once #8092 is fixed\n\t            if (!parentNode || parentNode['$$NG_REMOVED'] || elementNode['$$NG_REMOVED']) {\n\t              done();\n\t              return;\n\t            }\n\t\n\t            var cache = element.data(STORAGE_KEY);\n\t            element.removeData(STORAGE_KEY);\n\t\n\t            var state = element.data(NG_ANIMATE_STATE) || {};\n\t            var classes = resolveElementClasses(element, cache, state.active);\n\t            return !classes\n\t              ? done()\n\t              : performAnimation('setClass', classes, element, parentElement, null, function() {\n\t                  if (classes[0]) $delegate.$$addClassImmediately(element, classes[0]);\n\t                  if (classes[1]) $delegate.$$removeClassImmediately(element, classes[1]);\n\t                }, cache.options, done);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#cancel\n\t         * @kind function\n\t         *\n\t         * @param {Promise} animationPromise The animation promise that is returned when an animation is started.\n\t         *\n\t         * @description\n\t         * Cancels the provided animation.\n\t        */\n\t        cancel: function(promise) {\n\t          promise.$$cancelFn();\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $animate#enabled\n\t         * @kind function\n\t         *\n\t         * @param {boolean=} value If provided then set the animation on or off.\n\t         * @param {DOMElement=} element If provided then the element will be used to represent the enable/disable operation\n\t         * @return {boolean} Current animation state.\n\t         *\n\t         * @description\n\t         * Globally enables/disables animations.\n\t         *\n\t        */\n\t        enabled: function(value, element) {\n\t          switch (arguments.length) {\n\t            case 2:\n\t              if (value) {\n\t                cleanup(element);\n\t              } else {\n\t                var data = element.data(NG_ANIMATE_STATE) || {};\n\t                data.disabled = true;\n\t                element.data(NG_ANIMATE_STATE, data);\n\t              }\n\t            break;\n\t\n\t            case 1:\n\t              rootAnimateState.disabled = !value;\n\t            break;\n\t\n\t            default:\n\t              value = !rootAnimateState.disabled;\n\t            break;\n\t          }\n\t          return !!value;\n\t         }\n\t      };\n\t\n\t      /*\n\t        all animations call this shared animation triggering function internally.\n\t        The animationEvent variable refers to the JavaScript animation event that will be triggered\n\t        and the className value is the name of the animation that will be applied within the\n\t        CSS code. Element, `parentElement` and `afterElement` are provided DOM elements for the animation\n\t        and the onComplete callback will be fired once the animation is fully complete.\n\t      */\n\t      function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {\n\t        var noopCancel = noop;\n\t        var runner = animationRunner(element, animationEvent, className, options);\n\t        if (!runner) {\n\t          fireDOMOperation();\n\t          fireBeforeCallbackAsync();\n\t          fireAfterCallbackAsync();\n\t          closeAnimation();\n\t          return noopCancel;\n\t        }\n\t\n\t        animationEvent = runner.event;\n\t        className = runner.className;\n\t        var elementEvents = angular.element._data(runner.node);\n\t        elementEvents = elementEvents && elementEvents.events;\n\t\n\t        if (!parentElement) {\n\t          parentElement = afterElement ? afterElement.parent() : element.parent();\n\t        }\n\t\n\t        //skip the animation if animations are disabled, a parent is already being animated,\n\t        //the element is not currently attached to the document body or then completely close\n\t        //the animation if any matching animations are not found at all.\n\t        //NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case an animation was found.\n\t        if (animationsDisabled(element, parentElement)) {\n\t          fireDOMOperation();\n\t          fireBeforeCallbackAsync();\n\t          fireAfterCallbackAsync();\n\t          closeAnimation();\n\t          return noopCancel;\n\t        }\n\t\n\t        var ngAnimateState  = element.data(NG_ANIMATE_STATE) || {};\n\t        var runningAnimations     = ngAnimateState.active || {};\n\t        var totalActiveAnimations = ngAnimateState.totalActive || 0;\n\t        var lastAnimation         = ngAnimateState.last;\n\t        var skipAnimation = false;\n\t\n\t        if (totalActiveAnimations > 0) {\n\t          var animationsToCancel = [];\n\t          if (!runner.isClassBased) {\n\t            if (animationEvent == 'leave' && runningAnimations['ng-leave']) {\n\t              skipAnimation = true;\n\t            } else {\n\t              //cancel all animations when a structural animation takes place\n\t              for (var klass in runningAnimations) {\n\t                animationsToCancel.push(runningAnimations[klass]);\n\t              }\n\t              ngAnimateState = {};\n\t              cleanup(element, true);\n\t            }\n\t          } else if (lastAnimation.event == 'setClass') {\n\t            animationsToCancel.push(lastAnimation);\n\t            cleanup(element, className);\n\t          } else if (runningAnimations[className]) {\n\t            var current = runningAnimations[className];\n\t            if (current.event == animationEvent) {\n\t              skipAnimation = true;\n\t            } else {\n\t              animationsToCancel.push(current);\n\t              cleanup(element, className);\n\t            }\n\t          }\n\t\n\t          if (animationsToCancel.length > 0) {\n\t            forEach(animationsToCancel, function(operation) {\n\t              operation.cancel();\n\t            });\n\t          }\n\t        }\n\t\n\t        if (runner.isClassBased\n\t            && !runner.isSetClassOperation\n\t            && animationEvent != 'animate'\n\t            && !skipAnimation) {\n\t          skipAnimation = (animationEvent == 'addClass') == element.hasClass(className); //opposite of XOR\n\t        }\n\t\n\t        if (skipAnimation) {\n\t          fireDOMOperation();\n\t          fireBeforeCallbackAsync();\n\t          fireAfterCallbackAsync();\n\t          fireDoneCallbackAsync();\n\t          return noopCancel;\n\t        }\n\t\n\t        runningAnimations     = ngAnimateState.active || {};\n\t        totalActiveAnimations = ngAnimateState.totalActive || 0;\n\t\n\t        if (animationEvent == 'leave') {\n\t          //there's no need to ever remove the listener since the element\n\t          //will be removed (destroyed) after the leave animation ends or\n\t          //is cancelled midway\n\t          element.one('$destroy', function(e) {\n\t            var element = angular.element(this);\n\t            var state = element.data(NG_ANIMATE_STATE);\n\t            if (state) {\n\t              var activeLeaveAnimation = state.active['ng-leave'];\n\t              if (activeLeaveAnimation) {\n\t                activeLeaveAnimation.cancel();\n\t                cleanup(element, 'ng-leave');\n\t              }\n\t            }\n\t          });\n\t        }\n\t\n\t        //the ng-animate class does nothing, but it's here to allow for\n\t        //parent animations to find and cancel child animations when needed\n\t        $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME);\n\t        if (options && options.tempClasses) {\n\t          forEach(options.tempClasses, function(className) {\n\t            $$jqLite.addClass(element, className);\n\t          });\n\t        }\n\t\n\t        var localAnimationCount = globalAnimationCounter++;\n\t        totalActiveAnimations++;\n\t        runningAnimations[className] = runner;\n\t\n\t        element.data(NG_ANIMATE_STATE, {\n\t          last: runner,\n\t          active: runningAnimations,\n\t          index: localAnimationCount,\n\t          totalActive: totalActiveAnimations\n\t        });\n\t\n\t        //first we run the before animations and when all of those are complete\n\t        //then we perform the DOM operation and run the next set of animations\n\t        fireBeforeCallbackAsync();\n\t        runner.before(function(cancelled) {\n\t          var data = element.data(NG_ANIMATE_STATE);\n\t          cancelled = cancelled ||\n\t                        !data || !data.active[className] ||\n\t                        (runner.isClassBased && data.active[className].event != animationEvent);\n\t\n\t          fireDOMOperation();\n\t          if (cancelled === true) {\n\t            closeAnimation();\n\t          } else {\n\t            fireAfterCallbackAsync();\n\t            runner.after(closeAnimation);\n\t          }\n\t        });\n\t\n\t        return runner.cancel;\n\t\n\t        function fireDOMCallback(animationPhase) {\n\t          var eventName = '$animate:' + animationPhase;\n\t          if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {\n\t            $$asyncCallback(function() {\n\t              element.triggerHandler(eventName, {\n\t                event: animationEvent,\n\t                className: className\n\t              });\n\t            });\n\t          }\n\t        }\n\t\n\t        function fireBeforeCallbackAsync() {\n\t          fireDOMCallback('before');\n\t        }\n\t\n\t        function fireAfterCallbackAsync() {\n\t          fireDOMCallback('after');\n\t        }\n\t\n\t        function fireDoneCallbackAsync() {\n\t          fireDOMCallback('close');\n\t          doneCallback();\n\t        }\n\t\n\t        //it is less complicated to use a flag than managing and canceling\n\t        //timeouts containing multiple callbacks.\n\t        function fireDOMOperation() {\n\t          if (!fireDOMOperation.hasBeenRun) {\n\t            fireDOMOperation.hasBeenRun = true;\n\t            domOperation();\n\t          }\n\t        }\n\t\n\t        function closeAnimation() {\n\t          if (!closeAnimation.hasBeenRun) {\n\t            if (runner) { //the runner doesn't exist if it fails to instantiate\n\t              runner.applyStyles();\n\t            }\n\t\n\t            closeAnimation.hasBeenRun = true;\n\t            if (options && options.tempClasses) {\n\t              forEach(options.tempClasses, function(className) {\n\t                $$jqLite.removeClass(element, className);\n\t              });\n\t            }\n\t\n\t            var data = element.data(NG_ANIMATE_STATE);\n\t            if (data) {\n\t\n\t              /* only structural animations wait for reflow before removing an\n\t                 animation, but class-based animations don't. An example of this\n\t                 failing would be when a parent HTML tag has a ng-class attribute\n\t                 causing ALL directives below to skip animations during the digest */\n\t              if (runner && runner.isClassBased) {\n\t                cleanup(element, className);\n\t              } else {\n\t                $$asyncCallback(function() {\n\t                  var data = element.data(NG_ANIMATE_STATE) || {};\n\t                  if (localAnimationCount == data.index) {\n\t                    cleanup(element, className, animationEvent);\n\t                  }\n\t                });\n\t                element.data(NG_ANIMATE_STATE, data);\n\t              }\n\t            }\n\t            fireDoneCallbackAsync();\n\t          }\n\t        }\n\t      }\n\t\n\t      function cancelChildAnimations(element) {\n\t        var node = extractElementNode(element);\n\t        if (node) {\n\t          var nodes = angular.isFunction(node.getElementsByClassName) ?\n\t            node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) :\n\t            node.querySelectorAll('.' + NG_ANIMATE_CLASS_NAME);\n\t          forEach(nodes, function(element) {\n\t            element = angular.element(element);\n\t            var data = element.data(NG_ANIMATE_STATE);\n\t            if (data && data.active) {\n\t              forEach(data.active, function(runner) {\n\t                runner.cancel();\n\t              });\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      function cleanup(element, className) {\n\t        if (isMatchingElement(element, $rootElement)) {\n\t          if (!rootAnimateState.disabled) {\n\t            rootAnimateState.running = false;\n\t            rootAnimateState.structural = false;\n\t          }\n\t        } else if (className) {\n\t          var data = element.data(NG_ANIMATE_STATE) || {};\n\t\n\t          var removeAnimations = className === true;\n\t          if (!removeAnimations && data.active && data.active[className]) {\n\t            data.totalActive--;\n\t            delete data.active[className];\n\t          }\n\t\n\t          if (removeAnimations || !data.totalActive) {\n\t            $$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME);\n\t            element.removeData(NG_ANIMATE_STATE);\n\t          }\n\t        }\n\t      }\n\t\n\t      function animationsDisabled(element, parentElement) {\n\t        if (rootAnimateState.disabled) {\n\t          return true;\n\t        }\n\t\n\t        if (isMatchingElement(element, $rootElement)) {\n\t          return rootAnimateState.running;\n\t        }\n\t\n\t        var allowChildAnimations, parentRunningAnimation, hasParent;\n\t        do {\n\t          //the element did not reach the root element which means that it\n\t          //is not apart of the DOM. Therefore there is no reason to do\n\t          //any animations on it\n\t          if (parentElement.length === 0) break;\n\t\n\t          var isRoot = isMatchingElement(parentElement, $rootElement);\n\t          var state = isRoot ? rootAnimateState : (parentElement.data(NG_ANIMATE_STATE) || {});\n\t          if (state.disabled) {\n\t            return true;\n\t          }\n\t\n\t          //no matter what, for an animation to work it must reach the root element\n\t          //this implies that the element is attached to the DOM when the animation is run\n\t          if (isRoot) {\n\t            hasParent = true;\n\t          }\n\t\n\t          //once a flag is found that is strictly false then everything before\n\t          //it will be discarded and all child animations will be restricted\n\t          if (allowChildAnimations !== false) {\n\t            var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);\n\t            if (angular.isDefined(animateChildrenFlag)) {\n\t              allowChildAnimations = animateChildrenFlag;\n\t            }\n\t          }\n\t\n\t          parentRunningAnimation = parentRunningAnimation ||\n\t                                   state.running ||\n\t                                   (state.last && !state.last.isClassBased);\n\t        }\n\t        while (parentElement = parentElement.parent());\n\t\n\t        return !hasParent || (!allowChildAnimations && parentRunningAnimation);\n\t      }\n\t    }]);\n\t\n\t    $animateProvider.register('', ['$window', '$sniffer', '$timeout', '$$animateReflow',\n\t                           function($window,   $sniffer,   $timeout,   $$animateReflow) {\n\t      // Detect proper transitionend/animationend event names.\n\t      var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\t\n\t      // If unprefixed events are not supported but webkit-prefixed are, use the latter.\n\t      // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n\t      // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n\t      // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n\t      // Register both events in case `window.onanimationend` is not supported because of that,\n\t      // do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n\t      // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n\t      // therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition\n\t      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n\t        CSS_PREFIX = '-webkit-';\n\t        TRANSITION_PROP = 'WebkitTransition';\n\t        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n\t      } else {\n\t        TRANSITION_PROP = 'transition';\n\t        TRANSITIONEND_EVENT = 'transitionend';\n\t      }\n\t\n\t      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n\t        CSS_PREFIX = '-webkit-';\n\t        ANIMATION_PROP = 'WebkitAnimation';\n\t        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n\t      } else {\n\t        ANIMATION_PROP = 'animation';\n\t        ANIMATIONEND_EVENT = 'animationend';\n\t      }\n\t\n\t      var DURATION_KEY = 'Duration';\n\t      var PROPERTY_KEY = 'Property';\n\t      var DELAY_KEY = 'Delay';\n\t      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\n\t      var ANIMATION_PLAYSTATE_KEY = 'PlayState';\n\t      var NG_ANIMATE_PARENT_KEY = '$$ngAnimateKey';\n\t      var NG_ANIMATE_CSS_DATA_KEY = '$$ngAnimateCSS3Data';\n\t      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n\t      var CLOSING_TIME_BUFFER = 1.5;\n\t      var ONE_SECOND = 1000;\n\t\n\t      var lookupCache = {};\n\t      var parentCounter = 0;\n\t      var animationReflowQueue = [];\n\t      var cancelAnimationReflow;\n\t      function clearCacheAfterReflow() {\n\t        if (!cancelAnimationReflow) {\n\t          cancelAnimationReflow = $$animateReflow(function() {\n\t            animationReflowQueue = [];\n\t            cancelAnimationReflow = null;\n\t            lookupCache = {};\n\t          });\n\t        }\n\t      }\n\t\n\t      function afterReflow(element, callback) {\n\t        if (cancelAnimationReflow) {\n\t          cancelAnimationReflow();\n\t        }\n\t        animationReflowQueue.push(callback);\n\t        cancelAnimationReflow = $$animateReflow(function() {\n\t          forEach(animationReflowQueue, function(fn) {\n\t            fn();\n\t          });\n\t\n\t          animationReflowQueue = [];\n\t          cancelAnimationReflow = null;\n\t          lookupCache = {};\n\t        });\n\t      }\n\t\n\t      var closingTimer = null;\n\t      var closingTimestamp = 0;\n\t      var animationElementQueue = [];\n\t      function animationCloseHandler(element, totalTime) {\n\t        var node = extractElementNode(element);\n\t        element = angular.element(node);\n\t\n\t        //this item will be garbage collected by the closing\n\t        //animation timeout\n\t        animationElementQueue.push(element);\n\t\n\t        //but it may not need to cancel out the existing timeout\n\t        //if the timestamp is less than the previous one\n\t        var futureTimestamp = Date.now() + totalTime;\n\t        if (futureTimestamp <= closingTimestamp) {\n\t          return;\n\t        }\n\t\n\t        $timeout.cancel(closingTimer);\n\t\n\t        closingTimestamp = futureTimestamp;\n\t        closingTimer = $timeout(function() {\n\t          closeAllAnimations(animationElementQueue);\n\t          animationElementQueue = [];\n\t        }, totalTime, false);\n\t      }\n\t\n\t      function closeAllAnimations(elements) {\n\t        forEach(elements, function(element) {\n\t          var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);\n\t          if (elementData) {\n\t            forEach(elementData.closeAnimationFns, function(fn) {\n\t              fn();\n\t            });\n\t          }\n\t        });\n\t      }\n\t\n\t      function getElementAnimationDetails(element, cacheKey) {\n\t        var data = cacheKey ? lookupCache[cacheKey] : null;\n\t        if (!data) {\n\t          var transitionDuration = 0;\n\t          var transitionDelay = 0;\n\t          var animationDuration = 0;\n\t          var animationDelay = 0;\n\t\n\t          //we want all the styles defined before and after\n\t          forEach(element, function(element) {\n\t            if (element.nodeType == ELEMENT_NODE) {\n\t              var elementStyles = $window.getComputedStyle(element) || {};\n\t\n\t              var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];\n\t              transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);\n\t\n\t              var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];\n\t              transitionDelay  = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);\n\t\n\t              var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];\n\t              animationDelay   = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);\n\t\n\t              var aDuration  = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);\n\t\n\t              if (aDuration > 0) {\n\t                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;\n\t              }\n\t              animationDuration = Math.max(aDuration, animationDuration);\n\t            }\n\t          });\n\t          data = {\n\t            total: 0,\n\t            transitionDelay: transitionDelay,\n\t            transitionDuration: transitionDuration,\n\t            animationDelay: animationDelay,\n\t            animationDuration: animationDuration\n\t          };\n\t          if (cacheKey) {\n\t            lookupCache[cacheKey] = data;\n\t          }\n\t        }\n\t        return data;\n\t      }\n\t\n\t      function parseMaxTime(str) {\n\t        var maxValue = 0;\n\t        var values = isString(str) ?\n\t          str.split(/\\s*,\\s*/) :\n\t          [];\n\t        forEach(values, function(value) {\n\t          maxValue = Math.max(parseFloat(value) || 0, maxValue);\n\t        });\n\t        return maxValue;\n\t      }\n\t\n\t      function getCacheKey(element) {\n\t        var parentElement = element.parent();\n\t        var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);\n\t        if (!parentID) {\n\t          parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);\n\t          parentID = parentCounter;\n\t        }\n\t        return parentID + '-' + extractElementNode(element).getAttribute('class');\n\t      }\n\t\n\t      function animateSetup(animationEvent, element, className, styles) {\n\t        var structural = ['ng-enter','ng-leave','ng-move'].indexOf(className) >= 0;\n\t\n\t        var cacheKey = getCacheKey(element);\n\t        var eventCacheKey = cacheKey + ' ' + className;\n\t        var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;\n\t\n\t        var stagger = {};\n\t        if (itemIndex > 0) {\n\t          var staggerClassName = className + '-stagger';\n\t          var staggerCacheKey = cacheKey + ' ' + staggerClassName;\n\t          var applyClasses = !lookupCache[staggerCacheKey];\n\t\n\t          applyClasses && $$jqLite.addClass(element, staggerClassName);\n\t\n\t          stagger = getElementAnimationDetails(element, staggerCacheKey);\n\t\n\t          applyClasses && $$jqLite.removeClass(element, staggerClassName);\n\t        }\n\t\n\t        $$jqLite.addClass(element, className);\n\t\n\t        var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};\n\t        var timings = getElementAnimationDetails(element, eventCacheKey);\n\t        var transitionDuration = timings.transitionDuration;\n\t        var animationDuration = timings.animationDuration;\n\t\n\t        if (structural && transitionDuration === 0 && animationDuration === 0) {\n\t          $$jqLite.removeClass(element, className);\n\t          return false;\n\t        }\n\t\n\t        var blockTransition = styles || (structural && transitionDuration > 0);\n\t        var blockAnimation = animationDuration > 0 &&\n\t                             stagger.animationDelay > 0 &&\n\t                             stagger.animationDuration === 0;\n\t\n\t        var closeAnimationFns = formerData.closeAnimationFns || [];\n\t        element.data(NG_ANIMATE_CSS_DATA_KEY, {\n\t          stagger: stagger,\n\t          cacheKey: eventCacheKey,\n\t          running: formerData.running || 0,\n\t          itemIndex: itemIndex,\n\t          blockTransition: blockTransition,\n\t          closeAnimationFns: closeAnimationFns\n\t        });\n\t\n\t        var node = extractElementNode(element);\n\t\n\t        if (blockTransition) {\n\t          blockTransitions(node, true);\n\t          if (styles) {\n\t            element.css(styles);\n\t          }\n\t        }\n\t\n\t        if (blockAnimation) {\n\t          blockAnimations(node, true);\n\t        }\n\t\n\t        return true;\n\t      }\n\t\n\t      function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {\n\t        var node = extractElementNode(element);\n\t        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);\n\t        if (node.getAttribute('class').indexOf(className) == -1 || !elementData) {\n\t          activeAnimationComplete();\n\t          return;\n\t        }\n\t\n\t        var activeClassName = '';\n\t        var pendingClassName = '';\n\t        forEach(className.split(' '), function(klass, i) {\n\t          var prefix = (i > 0 ? ' ' : '') + klass;\n\t          activeClassName += prefix + '-active';\n\t          pendingClassName += prefix + '-pending';\n\t        });\n\t\n\t        var style = '';\n\t        var appliedStyles = [];\n\t        var itemIndex = elementData.itemIndex;\n\t        var stagger = elementData.stagger;\n\t        var staggerTime = 0;\n\t        if (itemIndex > 0) {\n\t          var transitionStaggerDelay = 0;\n\t          if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {\n\t            transitionStaggerDelay = stagger.transitionDelay * itemIndex;\n\t          }\n\t\n\t          var animationStaggerDelay = 0;\n\t          if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {\n\t            animationStaggerDelay = stagger.animationDelay * itemIndex;\n\t            appliedStyles.push(CSS_PREFIX + 'animation-play-state');\n\t          }\n\t\n\t          staggerTime = Math.round(Math.max(transitionStaggerDelay, animationStaggerDelay) * 100) / 100;\n\t        }\n\t\n\t        if (!staggerTime) {\n\t          $$jqLite.addClass(element, activeClassName);\n\t          if (elementData.blockTransition) {\n\t            blockTransitions(node, false);\n\t          }\n\t        }\n\t\n\t        var eventCacheKey = elementData.cacheKey + ' ' + activeClassName;\n\t        var timings = getElementAnimationDetails(element, eventCacheKey);\n\t        var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);\n\t        if (maxDuration === 0) {\n\t          $$jqLite.removeClass(element, activeClassName);\n\t          animateClose(element, className);\n\t          activeAnimationComplete();\n\t          return;\n\t        }\n\t\n\t        if (!staggerTime && styles && Object.keys(styles).length > 0) {\n\t          if (!timings.transitionDuration) {\n\t            element.css('transition', timings.animationDuration + 's linear all');\n\t            appliedStyles.push('transition');\n\t          }\n\t          element.css(styles);\n\t        }\n\t\n\t        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);\n\t        var maxDelayTime = maxDelay * ONE_SECOND;\n\t\n\t        if (appliedStyles.length > 0) {\n\t          //the element being animated may sometimes contain comment nodes in\n\t          //the jqLite object, so we're safe to use a single variable to house\n\t          //the styles since there is always only one element being animated\n\t          var oldStyle = node.getAttribute('style') || '';\n\t          if (oldStyle.charAt(oldStyle.length - 1) !== ';') {\n\t            oldStyle += ';';\n\t          }\n\t          node.setAttribute('style', oldStyle + ' ' + style);\n\t        }\n\t\n\t        var startTime = Date.now();\n\t        var css3AnimationEvents = ANIMATIONEND_EVENT + ' ' + TRANSITIONEND_EVENT;\n\t        var animationTime     = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;\n\t        var totalTime         = (staggerTime + animationTime) * ONE_SECOND;\n\t\n\t        var staggerTimeout;\n\t        if (staggerTime > 0) {\n\t          $$jqLite.addClass(element, pendingClassName);\n\t          staggerTimeout = $timeout(function() {\n\t            staggerTimeout = null;\n\t\n\t            if (timings.transitionDuration > 0) {\n\t              blockTransitions(node, false);\n\t            }\n\t            if (timings.animationDuration > 0) {\n\t              blockAnimations(node, false);\n\t            }\n\t\n\t            $$jqLite.addClass(element, activeClassName);\n\t            $$jqLite.removeClass(element, pendingClassName);\n\t\n\t            if (styles) {\n\t              if (timings.transitionDuration === 0) {\n\t                element.css('transition', timings.animationDuration + 's linear all');\n\t              }\n\t              element.css(styles);\n\t              appliedStyles.push('transition');\n\t            }\n\t          }, staggerTime * ONE_SECOND, false);\n\t        }\n\t\n\t        element.on(css3AnimationEvents, onAnimationProgress);\n\t        elementData.closeAnimationFns.push(function() {\n\t          onEnd();\n\t          activeAnimationComplete();\n\t        });\n\t\n\t        elementData.running++;\n\t        animationCloseHandler(element, totalTime);\n\t        return onEnd;\n\t\n\t        // This will automatically be called by $animate so\n\t        // there is no need to attach this internally to the\n\t        // timeout done method.\n\t        function onEnd() {\n\t          element.off(css3AnimationEvents, onAnimationProgress);\n\t          $$jqLite.removeClass(element, activeClassName);\n\t          $$jqLite.removeClass(element, pendingClassName);\n\t          if (staggerTimeout) {\n\t            $timeout.cancel(staggerTimeout);\n\t          }\n\t          animateClose(element, className);\n\t          var node = extractElementNode(element);\n\t          for (var i in appliedStyles) {\n\t            node.style.removeProperty(appliedStyles[i]);\n\t          }\n\t        }\n\t\n\t        function onAnimationProgress(event) {\n\t          event.stopPropagation();\n\t          var ev = event.originalEvent || event;\n\t          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\t\n\t          /* Firefox (or possibly just Gecko) likes to not round values up\n\t           * when a ms measurement is used for the animation */\n\t          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\t\n\t          /* $manualTimeStamp is a mocked timeStamp value which is set\n\t           * within browserTrigger(). This is only here so that tests can\n\t           * mock animations properly. Real events fallback to event.timeStamp,\n\t           * or, if they don't, then a timeStamp is automatically created for them.\n\t           * We're checking to see if the timeStamp surpasses the expected delay,\n\t           * but we're using elapsedTime instead of the timeStamp on the 2nd\n\t           * pre-condition since animations sometimes close off early */\n\t          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n\t            activeAnimationComplete();\n\t          }\n\t        }\n\t      }\n\t\n\t      function blockTransitions(node, bool) {\n\t        node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? 'none' : '';\n\t      }\n\t\n\t      function blockAnimations(node, bool) {\n\t        node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? 'paused' : '';\n\t      }\n\t\n\t      function animateBefore(animationEvent, element, className, styles) {\n\t        if (animateSetup(animationEvent, element, className, styles)) {\n\t          return function(cancelled) {\n\t            cancelled && animateClose(element, className);\n\t          };\n\t        }\n\t      }\n\t\n\t      function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {\n\t        if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {\n\t          return animateRun(animationEvent, element, className, afterAnimationComplete, styles);\n\t        } else {\n\t          animateClose(element, className);\n\t          afterAnimationComplete();\n\t        }\n\t      }\n\t\n\t      function animate(animationEvent, element, className, animationComplete, options) {\n\t        //If the animateSetup function doesn't bother returning a\n\t        //cancellation function then it means that there is no animation\n\t        //to perform at all\n\t        var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);\n\t        if (!preReflowCancellation) {\n\t          clearCacheAfterReflow();\n\t          animationComplete();\n\t          return;\n\t        }\n\t\n\t        //There are two cancellation functions: one is before the first\n\t        //reflow animation and the second is during the active state\n\t        //animation. The first function will take care of removing the\n\t        //data from the element which will not make the 2nd animation\n\t        //happen in the first place\n\t        var cancel = preReflowCancellation;\n\t        afterReflow(element, function() {\n\t          //once the reflow is complete then we point cancel to\n\t          //the new cancellation function which will remove all of the\n\t          //animation properties from the active animation\n\t          cancel = animateAfter(animationEvent, element, className, animationComplete, options.to);\n\t        });\n\t\n\t        return function(cancelled) {\n\t          (cancel || noop)(cancelled);\n\t        };\n\t      }\n\t\n\t      function animateClose(element, className) {\n\t        $$jqLite.removeClass(element, className);\n\t        var data = element.data(NG_ANIMATE_CSS_DATA_KEY);\n\t        if (data) {\n\t          if (data.running) {\n\t            data.running--;\n\t          }\n\t          if (!data.running || data.running === 0) {\n\t            element.removeData(NG_ANIMATE_CSS_DATA_KEY);\n\t          }\n\t        }\n\t      }\n\t\n\t      return {\n\t        animate: function(element, className, from, to, animationCompleted, options) {\n\t          options = options || {};\n\t          options.from = from;\n\t          options.to = to;\n\t          return animate('animate', element, className, animationCompleted, options);\n\t        },\n\t\n\t        enter: function(element, animationCompleted, options) {\n\t          options = options || {};\n\t          return animate('enter', element, 'ng-enter', animationCompleted, options);\n\t        },\n\t\n\t        leave: function(element, animationCompleted, options) {\n\t          options = options || {};\n\t          return animate('leave', element, 'ng-leave', animationCompleted, options);\n\t        },\n\t\n\t        move: function(element, animationCompleted, options) {\n\t          options = options || {};\n\t          return animate('move', element, 'ng-move', animationCompleted, options);\n\t        },\n\t\n\t        beforeSetClass: function(element, add, remove, animationCompleted, options) {\n\t          options = options || {};\n\t          var className = suffixClasses(remove, '-remove') + ' ' +\n\t                          suffixClasses(add, '-add');\n\t          var cancellationMethod = animateBefore('setClass', element, className, options.from);\n\t          if (cancellationMethod) {\n\t            afterReflow(element, animationCompleted);\n\t            return cancellationMethod;\n\t          }\n\t          clearCacheAfterReflow();\n\t          animationCompleted();\n\t        },\n\t\n\t        beforeAddClass: function(element, className, animationCompleted, options) {\n\t          options = options || {};\n\t          var cancellationMethod = animateBefore('addClass', element, suffixClasses(className, '-add'), options.from);\n\t          if (cancellationMethod) {\n\t            afterReflow(element, animationCompleted);\n\t            return cancellationMethod;\n\t          }\n\t          clearCacheAfterReflow();\n\t          animationCompleted();\n\t        },\n\t\n\t        beforeRemoveClass: function(element, className, animationCompleted, options) {\n\t          options = options || {};\n\t          var cancellationMethod = animateBefore('removeClass', element, suffixClasses(className, '-remove'), options.from);\n\t          if (cancellationMethod) {\n\t            afterReflow(element, animationCompleted);\n\t            return cancellationMethod;\n\t          }\n\t          clearCacheAfterReflow();\n\t          animationCompleted();\n\t        },\n\t\n\t        setClass: function(element, add, remove, animationCompleted, options) {\n\t          options = options || {};\n\t          remove = suffixClasses(remove, '-remove');\n\t          add = suffixClasses(add, '-add');\n\t          var className = remove + ' ' + add;\n\t          return animateAfter('setClass', element, className, animationCompleted, options.to);\n\t        },\n\t\n\t        addClass: function(element, className, animationCompleted, options) {\n\t          options = options || {};\n\t          return animateAfter('addClass', element, suffixClasses(className, '-add'), animationCompleted, options.to);\n\t        },\n\t\n\t        removeClass: function(element, className, animationCompleted, options) {\n\t          options = options || {};\n\t          return animateAfter('removeClass', element, suffixClasses(className, '-remove'), animationCompleted, options.to);\n\t        }\n\t      };\n\t\n\t      function suffixClasses(classes, suffix) {\n\t        var className = '';\n\t        classes = isArray(classes) ? classes : classes.split(/\\s+/);\n\t        forEach(classes, function(klass, i) {\n\t          if (klass && klass.length > 0) {\n\t            className += (i > 0 ? ' ' : '') + klass + suffix;\n\t          }\n\t        });\n\t        return className;\n\t      }\n\t    }]);\n\t  }]);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(2);\n\tmodule.exports = 'ngAnimate';\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.3.15\n\t * (c) 2010-2014 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular, undefined) {'use strict';\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngAria\n\t * @description\n\t *\n\t * The `ngAria` module provides support for common\n\t * [<abbr title=\"Accessible Rich Internet Applications\">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)\n\t * attributes that convey state or semantic information about the application for users\n\t * of assistive technologies, such as screen readers.\n\t *\n\t * <div doc-module-components=\"ngAria\"></div>\n\t *\n\t * ## Usage\n\t *\n\t * For ngAria to do its magic, simply include the module as a dependency. The directives supported\n\t * by ngAria are:\n\t * `ngModel`, `ngDisabled`, `ngShow`, `ngHide`, `ngClick`, `ngDblClick`, and `ngMessages`.\n\t *\n\t * Below is a more detailed breakdown of the attributes handled by ngAria:\n\t *\n\t * | Directive                                   | Supported Attributes                                                                   |\n\t * |---------------------------------------------|----------------------------------------------------------------------------------------|\n\t * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                          |\n\t * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                            |\n\t * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                            |\n\t * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                               |\n\t * | {@link module:ngMessages ngMessages}        | aria-live                                                                              |\n\t * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required, input roles |\n\t * | {@link ng.directive:ngClick ngClick}        | tabindex, keypress event, button role                                                               |\n\t *\n\t * Find out more information about each directive by reading the\n\t * {@link guide/accessibility ngAria Developer Guide}.\n\t *\n\t * ##Example\n\t * Using ngDisabled with ngAria:\n\t * ```html\n\t * <md-checkbox ng-disabled=\"disabled\">\n\t * ```\n\t * Becomes:\n\t * ```html\n\t * <md-checkbox ng-disabled=\"disabled\" aria-disabled=\"true\">\n\t * ```\n\t *\n\t * ##Disabling Attributes\n\t * It's possible to disable individual attributes added by ngAria with the\n\t * {@link ngAria.$ariaProvider#config config} method. For more details, see the\n\t * {@link guide/accessibility Developer Guide}.\n\t */\n\t /* global -ngAriaModule */\n\tvar ngAriaModule = angular.module('ngAria', ['ng']).\n\t                        provider('$aria', $AriaProvider);\n\t\n\t/**\n\t * @ngdoc provider\n\t * @name $ariaProvider\n\t *\n\t * @description\n\t *\n\t * Used for configuring the ARIA attributes injected and managed by ngAria.\n\t *\n\t * ```js\n\t * angular.module('myApp', ['ngAria'], function config($ariaProvider) {\n\t *   $ariaProvider.config({\n\t *     ariaValue: true,\n\t *     tabindex: false\n\t *   });\n\t * });\n\t *```\n\t *\n\t * ## Dependencies\n\t * Requires the {@link ngAria} module to be installed.\n\t *\n\t */\n\tfunction $AriaProvider() {\n\t  var config = {\n\t    ariaHidden: true,\n\t    ariaChecked: true,\n\t    ariaDisabled: true,\n\t    ariaRequired: true,\n\t    ariaInvalid: true,\n\t    ariaMultiline: true,\n\t    ariaValue: true,\n\t    tabindex: true,\n\t    bindKeypress: true\n\t  };\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ariaProvider#config\n\t   *\n\t   * @param {object} config object to enable/disable specific ARIA attributes\n\t   *\n\t   *  - **ariaHidden** – `{boolean}` – Enables/disables aria-hidden tags\n\t   *  - **ariaChecked** – `{boolean}` – Enables/disables aria-checked tags\n\t   *  - **ariaDisabled** – `{boolean}` – Enables/disables aria-disabled tags\n\t   *  - **ariaRequired** – `{boolean}` – Enables/disables aria-required tags\n\t   *  - **ariaInvalid** – `{boolean}` – Enables/disables aria-invalid tags\n\t   *  - **ariaMultiline** – `{boolean}` – Enables/disables aria-multiline tags\n\t   *  - **ariaValue** – `{boolean}` – Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags\n\t   *  - **tabindex** – `{boolean}` – Enables/disables tabindex tags\n\t   *  - **bindKeypress** – `{boolean}` – Enables/disables keypress event binding on `&lt;div&gt;` and\n\t   *    `&lt;li&gt;` elements with ng-click\n\t   *\n\t   * @description\n\t   * Enables/disables various ARIA attributes\n\t   */\n\t  this.config = function(newConfig) {\n\t    config = angular.extend(config, newConfig);\n\t  };\n\t\n\t  function watchExpr(attrName, ariaAttr, negate) {\n\t    return function(scope, elem, attr) {\n\t      var ariaCamelName = attr.$normalize(ariaAttr);\n\t      if (config[ariaCamelName] && !attr[ariaCamelName]) {\n\t        scope.$watch(attr[attrName], function(boolVal) {\n\t          if (negate) {\n\t            boolVal = !boolVal;\n\t          }\n\t          elem.attr(ariaAttr, boolVal);\n\t        });\n\t      }\n\t    };\n\t  }\n\t\n\t  /**\n\t   * @ngdoc service\n\t   * @name $aria\n\t   *\n\t   * @description\n\t   * @priority 200\n\t   *\n\t   * The $aria service contains helper methods for applying common\n\t   * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.\n\t   *\n\t   * ngAria injects common accessibility attributes that tell assistive technologies when HTML\n\t   * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,\n\t   * let's review a code snippet from ngAria itself:\n\t   *\n\t   *```js\n\t   * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {\n\t   *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n\t   * }])\n\t   *```\n\t   * Shown above, the ngAria module creates a directive with the same signature as the\n\t   * traditional `ng-disabled` directive. But this ngAria version is dedicated to\n\t   * solely managing accessibility attributes. The internal `$aria` service is used to watch the\n\t   * boolean attribute `ngDisabled`. If it has not been explicitly set by the developer,\n\t   * `aria-disabled` is injected as an attribute with its value synchronized to the value in\n\t   * `ngDisabled`.\n\t   *\n\t   * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do\n\t   * anything to enable this feature. The `aria-disabled` attribute is automatically managed\n\t   * simply as a silent side-effect of using `ng-disabled` with the ngAria module.\n\t   *\n\t   * The full list of directives that interface with ngAria:\n\t   * * **ngModel**\n\t   * * **ngShow**\n\t   * * **ngHide**\n\t   * * **ngClick**\n\t   * * **ngDblclick**\n\t   * * **ngMessages**\n\t   * * **ngDisabled**\n\t   *\n\t   * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each\n\t   * directive.\n\t   *\n\t   *\n\t   * ## Dependencies\n\t   * Requires the {@link ngAria} module to be installed.\n\t   */\n\t  this.$get = function() {\n\t    return {\n\t      config: function(key) {\n\t        return config[key];\n\t      },\n\t      $$watchExpr: watchExpr\n\t    };\n\t  };\n\t}\n\t\n\t\n\tngAriaModule.directive('ngShow', ['$aria', function($aria) {\n\t  return $aria.$$watchExpr('ngShow', 'aria-hidden', true);\n\t}])\n\t.directive('ngHide', ['$aria', function($aria) {\n\t  return $aria.$$watchExpr('ngHide', 'aria-hidden', false);\n\t}])\n\t.directive('ngModel', ['$aria', function($aria) {\n\t\n\t  function shouldAttachAttr(attr, normalizedAttr, elem) {\n\t    return $aria.config(normalizedAttr) && !elem.attr(attr);\n\t  }\n\t\n\t  function shouldAttachRole(role, elem) {\n\t    return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');\n\t  }\n\t\n\t  function getShape(attr, elem) {\n\t    var type = attr.type,\n\t        role = attr.role;\n\t\n\t    return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :\n\t           ((type || role) === 'radio'    || role === 'menuitemradio') ? 'radio' :\n\t           (type === 'range'              || role === 'progressbar' || role === 'slider') ? 'range' :\n\t           (type || role) === 'textbox'   || elem[0].nodeName === 'TEXTAREA' ? 'multiline' : '';\n\t  }\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: '?ngModel',\n\t    priority: 200, //Make sure watches are fired after any other directives that affect the ngModel value\n\t    link: function(scope, elem, attr, ngModel) {\n\t      var shape = getShape(attr, elem);\n\t      var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem);\n\t\n\t      function ngAriaWatchModelValue() {\n\t        return ngModel.$modelValue;\n\t      }\n\t\n\t      function getRadioReaction() {\n\t        if (needsTabIndex) {\n\t          needsTabIndex = false;\n\t          return function ngAriaRadioReaction(newVal) {\n\t            var boolVal = (attr.value == ngModel.$viewValue);\n\t            elem.attr('aria-checked', boolVal);\n\t            elem.attr('tabindex', 0 - !boolVal);\n\t          };\n\t        } else {\n\t          return function ngAriaRadioReaction(newVal) {\n\t            elem.attr('aria-checked', (attr.value == ngModel.$viewValue));\n\t          };\n\t        }\n\t      }\n\t\n\t      function ngAriaCheckboxReaction(newVal) {\n\t        elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));\n\t      }\n\t\n\t      switch (shape) {\n\t        case 'radio':\n\t        case 'checkbox':\n\t          if (shouldAttachRole(shape, elem)) {\n\t            elem.attr('role', shape);\n\t          }\n\t          if (shouldAttachAttr('aria-checked', 'ariaChecked', elem)) {\n\t            scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?\n\t                getRadioReaction() : ngAriaCheckboxReaction);\n\t          }\n\t          break;\n\t        case 'range':\n\t          if (shouldAttachRole(shape, elem)) {\n\t            elem.attr('role', 'slider');\n\t          }\n\t          if ($aria.config('ariaValue')) {\n\t            if (attr.min && !elem.attr('aria-valuemin')) {\n\t              elem.attr('aria-valuemin', attr.min);\n\t            }\n\t            if (attr.max && !elem.attr('aria-valuemax')) {\n\t              elem.attr('aria-valuemax', attr.max);\n\t            }\n\t            if (!elem.attr('aria-valuenow')) {\n\t              scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {\n\t                elem.attr('aria-valuenow', newVal);\n\t              });\n\t            }\n\t          }\n\t          break;\n\t        case 'multiline':\n\t          if (shouldAttachAttr('aria-multiline', 'ariaMultiline', elem)) {\n\t            elem.attr('aria-multiline', true);\n\t          }\n\t          break;\n\t      }\n\t\n\t      if (needsTabIndex) {\n\t        elem.attr('tabindex', 0);\n\t      }\n\t\n\t      if (ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem)) {\n\t        scope.$watch(function ngAriaRequiredWatch() {\n\t          return ngModel.$error.required;\n\t        }, function ngAriaRequiredReaction(newVal) {\n\t          elem.attr('aria-required', !!newVal);\n\t        });\n\t      }\n\t\n\t      if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem)) {\n\t        scope.$watch(function ngAriaInvalidWatch() {\n\t          return ngModel.$invalid;\n\t        }, function ngAriaInvalidReaction(newVal) {\n\t          elem.attr('aria-invalid', !!newVal);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}])\n\t.directive('ngDisabled', ['$aria', function($aria) {\n\t  return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n\t}])\n\t.directive('ngMessages', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?ngMessages',\n\t    link: function(scope, elem, attr, ngMessages) {\n\t      if (!elem.attr('aria-live')) {\n\t        elem.attr('aria-live', 'assertive');\n\t      }\n\t    }\n\t  };\n\t})\n\t.directive('ngClick',['$aria', '$parse', function($aria, $parse) {\n\t  return {\n\t    restrict: 'A',\n\t    compile: function(elem, attr) {\n\t      var fn = $parse(attr.ngClick, /* interceptorFn */ null, /* expensiveChecks */ true);\n\t      return function(scope, elem, attr) {\n\t\n\t        var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA'];\n\t\n\t        function isNodeOneOf(elem, nodeTypeArray) {\n\t          if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {\n\t            return true;\n\t          }\n\t        }\n\t        if (!elem.attr('role') && !isNodeOneOf(elem, nodeBlackList)) {\n\t          elem.attr('role', 'button');\n\t        }\n\t\n\t        if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n\t          elem.attr('tabindex', 0);\n\t        }\n\t\n\t        if ($aria.config('bindKeypress') && !attr.ngKeypress && !isNodeOneOf(elem, nodeBlackList)) {\n\t          elem.on('keypress', function(event) {\n\t            if (event.keyCode === 32 || event.keyCode === 13) {\n\t              scope.$apply(callback);\n\t            }\n\t\n\t            function callback() {\n\t              fn(scope, { $event: event });\n\t            }\n\t          });\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t.directive('ngDblclick', ['$aria', function($aria) {\n\t  return function(scope, elem, attr) {\n\t    if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n\t      elem.attr('tabindex', 0);\n\t    }\n\t  };\n\t}]);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(4);\n\tmodule.exports = 'ngAria';\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Angular Material Design\n\t * https://github.com/angular/material\n\t * @license MIT\n\t * v0.10.0\n\t */\n\t(function( window, angular, undefined ){\n\t\"use strict\";\n\t\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('ngMaterial', [\"ng\",\"ngAnimate\",\"ngAria\",\"material.core\",\"material.core.gestures\",\"material.core.theming.palette\",\"material.core.theming\",\"material.components.autocomplete\",\"material.components.backdrop\",\"material.components.bottomSheet\",\"material.components.button\",\"material.components.card\",\"material.components.checkbox\",\"material.components.content\",\"material.components.chips\",\"material.components.dialog\",\"material.components.fabActions\",\"material.components.divider\",\"material.components.fabSpeedDial\",\"material.components.fabToolbar\",\"material.components.gridList\",\"material.components.fabTrigger\",\"material.components.icon\",\"material.components.input\",\"material.components.list\",\"material.components.menu\",\"material.components.progressCircular\",\"material.components.progressLinear\",\"material.components.radioButton\",\"material.components.select\",\"material.components.sidenav\",\"material.components.slider\",\"material.components.subheader\",\"material.components.sticky\",\"material.components.swipe\",\"material.components.switch\",\"material.components.tabs\",\"material.components.toast\",\"material.components.toolbar\",\"material.components.tooltip\",\"material.components.whiteframe\"]);\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t\n\t/**\n\t * Initialization function that validates environment\n\t * requirements.\n\t */\n\tangular\n\t  .module('material.core', [ 'material.core.gestures', 'material.core.theming' ])\n\t  .config( MdCoreConfigure );\n\t\n\t\n\tfunction MdCoreConfigure($provide, $mdThemingProvider) {\n\t\n\t  $provide.decorator('$$rAF', [\"$delegate\", rAFDecorator]);\n\t\n\t  $mdThemingProvider.theme('default')\n\t    .primaryPalette('indigo')\n\t    .accentPalette('pink')\n\t    .warnPalette('red')\n\t    .backgroundPalette('grey');\n\t}\n\tMdCoreConfigure.$inject = [\"$provide\", \"$mdThemingProvider\"];\n\t\n\tfunction rAFDecorator( $delegate ) {\n\t  /**\n\t   * Use this to throttle events that come in often.\n\t   * The throttled function will always use the *last* invocation before the\n\t   * coming frame.\n\t   *\n\t   * For example, window resize events that fire many times a second:\n\t   * If we set to use an raf-throttled callback on window resize, then\n\t   * our callback will only be fired once per frame, with the last resize\n\t   * event that happened before that frame.\n\t   *\n\t   * @param {function} callback function to debounce\n\t   */\n\t  $delegate.throttle = function(cb) {\n\t    var queueArgs, alreadyQueued, queueCb, context;\n\t    return function debounced() {\n\t      queueArgs = arguments;\n\t      context = this;\n\t      queueCb = cb;\n\t      if (!alreadyQueued) {\n\t        alreadyQueued = true;\n\t        $delegate(function() {\n\t          queueCb.apply(context, queueArgs);\n\t          alreadyQueued = false;\n\t        });\n\t      }\n\t    };\n\t  };\n\t  return $delegate;\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core')\n\t.factory('$mdConstant', MdConstantFactory);\n\t\n\tfunction MdConstantFactory($$rAF, $sniffer) {\n\t\n\t  var webkit = /webkit/i.test($sniffer.vendorPrefix);\n\t  function vendorProperty(name) {\n\t    return webkit ?  ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;\n\t  }\n\t\n\t  return {\n\t    KEY_CODE: {\n\t      ENTER: 13,\n\t      ESCAPE: 27,\n\t      SPACE: 32,\n\t      LEFT_ARROW : 37,\n\t      UP_ARROW : 38,\n\t      RIGHT_ARROW : 39,\n\t      DOWN_ARROW : 40,\n\t      TAB : 9,\n\t      BACKSPACE: 8,\n\t      DELETE: 46\n\t    },\n\t    CSS: {\n\t      /* Constants */\n\t      TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),\n\t      ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),\n\t\n\t      TRANSFORM: vendorProperty('transform'),\n\t      TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),\n\t      TRANSITION: vendorProperty('transition'),\n\t      TRANSITION_DURATION: vendorProperty('transitionDuration'),\n\t      ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),\n\t      ANIMATION_DURATION: vendorProperty('animationDuration'),\n\t      ANIMATION_NAME: vendorProperty('animationName'),\n\t      ANIMATION_TIMING: vendorProperty('animationTimingFunction'),\n\t      ANIMATION_DIRECTION: vendorProperty('animationDirection')\n\t    },\n\t    MEDIA: {\n\t      'sm': '(max-width: 600px)',\n\t      'gt-sm': '(min-width: 600px)',\n\t      'md': '(min-width: 600px) and (max-width: 960px)',\n\t      'gt-md': '(min-width: 960px)',\n\t      'lg': '(min-width: 960px) and (max-width: 1200px)',\n\t      'gt-lg': '(min-width: 1200px)'\n\t    },\n\t    MEDIA_PRIORITY: [\n\t      'gt-lg',\n\t      'lg',\n\t      'gt-md',\n\t      'md',\n\t      'gt-sm',\n\t      'sm'\n\t    ]\n\t  };\n\t}\n\tMdConstantFactory.$inject = [\"$$rAF\", \"$sniffer\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  angular\n\t    .module('material.core')\n\t    .config( [\"$provide\", function($provide){\n\t       $provide.decorator('$mdUtil', ['$delegate', function ($delegate){\n\t           /**\n\t            * Inject the iterator facade to easily support iteration and accessors\n\t            * @see iterator below\n\t            */\n\t           $delegate.iterator = MdIterator;\n\t\n\t           return $delegate;\n\t         }\n\t       ]);\n\t     }]);\n\t\n\t  /**\n\t   * iterator is a list facade to easily support iteration and accessors\n\t   *\n\t   * @param items Array list which this iterator will enumerate\n\t   * @param reloop Boolean enables iterator to consider the list as an endless reloop\n\t   */\n\t  function MdIterator(items, reloop) {\n\t    var trueFn = function() { return true; };\n\t\n\t    if (items && !angular.isArray(items)) {\n\t      items = Array.prototype.slice.call(items);\n\t    }\n\t\n\t    reloop = !!reloop;\n\t    var _items = items || [ ];\n\t\n\t    // Published API\n\t    return {\n\t      items: getItems,\n\t      count: count,\n\t\n\t      inRange: inRange,\n\t      contains: contains,\n\t      indexOf: indexOf,\n\t      itemAt: itemAt,\n\t\n\t      findBy: findBy,\n\t\n\t      add: add,\n\t      remove: remove,\n\t\n\t      first: first,\n\t      last: last,\n\t      next: angular.bind(null, findSubsequentItem, false),\n\t      previous: angular.bind(null, findSubsequentItem, true),\n\t\n\t      hasPrevious: hasPrevious,\n\t      hasNext: hasNext\n\t\n\t    };\n\t\n\t    /**\n\t     * Publish copy of the enumerable set\n\t     * @returns {Array|*}\n\t     */\n\t    function getItems() {\n\t      return [].concat(_items);\n\t    }\n\t\n\t    /**\n\t     * Determine length of the list\n\t     * @returns {Array.length|*|number}\n\t     */\n\t    function count() {\n\t      return _items.length;\n\t    }\n\t\n\t    /**\n\t     * Is the index specified valid\n\t     * @param index\n\t     * @returns {Array.length|*|number|boolean}\n\t     */\n\t    function inRange(index) {\n\t      return _items.length && ( index > -1 ) && (index < _items.length );\n\t    }\n\t\n\t    /**\n\t     * Can the iterator proceed to the next item in the list; relative to\n\t     * the specified item.\n\t     *\n\t     * @param item\n\t     * @returns {Array.length|*|number|boolean}\n\t     */\n\t    function hasNext(item) {\n\t      return item ? inRange(indexOf(item) + 1) : false;\n\t    }\n\t\n\t    /**\n\t     * Can the iterator proceed to the previous item in the list; relative to\n\t     * the specified item.\n\t     *\n\t     * @param item\n\t     * @returns {Array.length|*|number|boolean}\n\t     */\n\t    function hasPrevious(item) {\n\t      return item ? inRange(indexOf(item) - 1) : false;\n\t    }\n\t\n\t    /**\n\t     * Get item at specified index/position\n\t     * @param index\n\t     * @returns {*}\n\t     */\n\t    function itemAt(index) {\n\t      return inRange(index) ? _items[index] : null;\n\t    }\n\t\n\t    /**\n\t     * Find all elements matching the key/value pair\n\t     * otherwise return null\n\t     *\n\t     * @param val\n\t     * @param key\n\t     *\n\t     * @return array\n\t     */\n\t    function findBy(key, val) {\n\t      return _items.filter(function(item) {\n\t        return item[key] === val;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Add item to list\n\t     * @param item\n\t     * @param index\n\t     * @returns {*}\n\t     */\n\t    function add(item, index) {\n\t      if ( !item ) return -1;\n\t\n\t      if (!angular.isNumber(index)) {\n\t        index = _items.length;\n\t      }\n\t\n\t      _items.splice(index, 0, item);\n\t\n\t      return indexOf(item);\n\t    }\n\t\n\t    /**\n\t     * Remove item from list...\n\t     * @param item\n\t     */\n\t    function remove(item) {\n\t      if ( contains(item) ){\n\t        _items.splice(indexOf(item), 1);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Get the zero-based index of the target item\n\t     * @param item\n\t     * @returns {*}\n\t     */\n\t    function indexOf(item) {\n\t      return _items.indexOf(item);\n\t    }\n\t\n\t    /**\n\t     * Boolean existence check\n\t     * @param item\n\t     * @returns {boolean}\n\t     */\n\t    function contains(item) {\n\t      return item && (indexOf(item) > -1);\n\t    }\n\t\n\t    /**\n\t     * Return first item in the list\n\t     * @returns {*}\n\t     */\n\t    function first() {\n\t      return _items.length ? _items[0] : null;\n\t    }\n\t\n\t    /**\n\t     * Return last item in the list...\n\t     * @returns {*}\n\t     */\n\t    function last() {\n\t      return _items.length ? _items[_items.length - 1] : null;\n\t    }\n\t\n\t    /**\n\t     * Find the next item. If reloop is true and at the end of the list, it will go back to the\n\t     * first item. If given, the `validate` callback will be used to determine whether the next item\n\t     * is valid. If not valid, it will try to find the next item again.\n\t     *\n\t     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)\n\t     * @param {*} item The item whose subsequent item we are looking for\n\t     * @param {Function=} validate The `validate` function\n\t     * @param {integer=} limit The recursion limit\n\t     *\n\t     * @returns {*} The subsequent item or null\n\t     */\n\t    function findSubsequentItem(backwards, item, validate, limit) {\n\t      validate = validate || trueFn;\n\t\n\t      var curIndex = indexOf(item);\n\t      while (true) {\n\t        if (!inRange(curIndex)) return null;\n\t\n\t        var nextIndex = curIndex + (backwards ? -1 : 1);\n\t        var foundItem = null;\n\t        if (inRange(nextIndex)) {\n\t          foundItem = _items[nextIndex];\n\t        } else if (reloop) {\n\t          foundItem = backwards ? last() : first();\n\t          nextIndex = indexOf(foundItem);\n\t        }\n\t\n\t        if ((foundItem === null) || (nextIndex === limit)) return null;\n\t        if (validate(foundItem)) return foundItem;\n\t\n\t        if (angular.isUndefined(limit)) limit = nextIndex;\n\t\n\t        curIndex = nextIndex;\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core')\n\t.factory('$mdMedia', mdMediaFactory);\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $mdMedia\n\t * @module material.core\n\t *\n\t * @description\n\t * `$mdMedia` is used to evaluate whether a given media query is true or false given the\n\t * current device's screen / window size. The media query will be re-evaluated on resize, allowing\n\t * you to register a watch.\n\t *\n\t * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints.\n\t *  (`sm`, `gt-sm`, `md`, `gt-md`, `lg`, `gt-lg`).\n\t *\n\t * @returns {boolean} a boolean representing whether or not the given media query is true or false.\n\t *\n\t * @usage\n\t * <hljs lang=\"js\">\n\t * app.controller('MyController', function($mdMedia, $scope) {\n\t *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {\n\t *     $scope.bigScreen = big;\n\t *   });\n\t *\n\t *   $scope.screenIsSmall = $mdMedia('sm');\n\t *   $scope.customQuery = $mdMedia('(min-width: 1234px)');\n\t *   $scope.anotherCustom = $mdMedia('max-width: 300px');\n\t * });\n\t * </hljs>\n\t */\n\t\n\tfunction mdMediaFactory($mdConstant, $rootScope, $window) {\n\t  var queries = {};\n\t  var mqls = {};\n\t  var results = {};\n\t  var normalizeCache = {};\n\t\n\t  $mdMedia.getResponsiveAttribute = getResponsiveAttribute;\n\t  $mdMedia.getQuery = getQuery;\n\t  $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;\n\t\n\t  return $mdMedia;\n\t\n\t  function $mdMedia(query) {\n\t    var validated = queries[query];\n\t    if (angular.isUndefined(validated)) {\n\t      validated = queries[query] = validate(query);\n\t    }\n\t\n\t    var result = results[validated];\n\t    if (angular.isUndefined(result)) {\n\t      result = add(validated);\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function validate(query) {\n\t    return $mdConstant.MEDIA[query] ||\n\t           ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);\n\t  }\n\t\n\t  function add(query) {\n\t    var result = mqls[query] = $window.matchMedia(query);\n\t    result.addListener(onQueryChange);\n\t    return (results[result.media] = !!result.matches);\n\t  }\n\t\n\t  function onQueryChange(query) {\n\t    $rootScope.$evalAsync(function() {\n\t      results[query.media] = !!query.matches;\n\t    });\n\t  }\n\t\n\t  function getQuery(name) {\n\t    return mqls[name];\n\t  }\n\t\n\t  function getResponsiveAttribute(attrs, attrName) {\n\t    for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {\n\t      var mediaName = $mdConstant.MEDIA_PRIORITY[i];\n\t      if (!mqls[queries[mediaName]].matches) {\n\t        continue;\n\t      }\n\t\n\t      var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n\t      if (attrs[normalizedName]) {\n\t        return attrs[normalizedName];\n\t      }\n\t    }\n\t\n\t    // fallback on unprefixed\n\t    return attrs[getNormalizedName(attrs, attrName)];\n\t  }\n\t\n\t  function watchResponsiveAttributes(attrNames, attrs, watchFn) {\n\t    var unwatchFns = [];\n\t    attrNames.forEach(function(attrName) {\n\t      var normalizedName = getNormalizedName(attrs, attrName);\n\t      if (attrs[normalizedName]) {\n\t        unwatchFns.push(\n\t            attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));\n\t      }\n\t\n\t      for (var mediaName in $mdConstant.MEDIA) {\n\t        normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n\t        if (!attrs[normalizedName]) {\n\t          return;\n\t        }\n\t\n\t        unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));\n\t      }\n\t    });\n\t\n\t    return function unwatch() {\n\t      unwatchFns.forEach(function(fn) { fn(); })\n\t    };\n\t  }\n\t\n\t  // Improves performance dramatically\n\t  function getNormalizedName(attrs, attrName) {\n\t    return normalizeCache[attrName] ||\n\t        (normalizeCache[attrName] = attrs.$normalize(attrName));\n\t  }\n\t}\n\tmdMediaFactory.$inject = [\"$mdConstant\", \"$rootScope\", \"$window\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/*\n\t * This var has to be outside the angular factory, otherwise when\n\t * there are multiple material apps on the same page, each app\n\t * will create its own instance of this array and the app's IDs\n\t * will not be unique.\n\t */\n\tvar nextUniqueId = 0;\n\t\n\tangular.module('material.core')\n\t.factory('$mdUtil', [\"$cacheFactory\", \"$document\", \"$timeout\", \"$q\", \"$window\", \"$mdConstant\", function($cacheFactory, $document, $timeout, $q, $window, $mdConstant) {\n\t  var Util;\n\t\n\t  function getNode(el) {\n\t    return el[0] || el;\n\t  }\n\t\n\t  return Util = {\n\t    now: window.performance ?\n\t      angular.bind(window.performance, window.performance.now) :\n\t      Date.now,\n\t\n\t    clientRect: function(element, offsetParent, isOffsetRect) {\n\t      var node = getNode(element);\n\t      offsetParent = getNode(offsetParent || node.offsetParent || document.body);\n\t      var nodeRect = node.getBoundingClientRect();\n\t\n\t      // The user can ask for an offsetRect: a rect relative to the offsetParent,\n\t      // or a clientRect: a rect relative to the page\n\t      var offsetRect = isOffsetRect ?\n\t        offsetParent.getBoundingClientRect() :\n\t        { left: 0, top: 0, width: 0, height: 0 };\n\t      return {\n\t        left: nodeRect.left - offsetRect.left,\n\t        top: nodeRect.top - offsetRect.top,\n\t        width: nodeRect.width,\n\t        height: nodeRect.height\n\t      };\n\t    },\n\t    offsetRect: function(element, offsetParent) {\n\t      return Util.clientRect(element, offsetParent, true);\n\t    },\n\t\n\t    // Annoying method to copy nodes to an array, thanks to IE\n\t    nodesToArray: function (nodes) {\n\t      var results = [];\n\t      for (var i = 0; i < nodes.length; ++i) {\n\t        results.push(nodes.item(i));\n\t      }\n\t      return results;\n\t    },\n\t\n\t    // Disables scroll around the passed element.\n\t    disableScrollAround: function(element) {\n\t      if (Util.disableScrollAround._enableScrolling) return Util.disableScrollAround._enableScrolling;\n\t      element = angular.element(element);\n\t      var body = $document[0].body,\n\t          restoreBody = disableBodyScroll(),\n\t          restoreElement = disableElementScroll();\n\t\n\t      return Util.disableScrollAround._enableScrolling = function () {\n\t        restoreBody();\n\t        restoreElement();\n\t        delete Util.disableScrollAround._enableScrolling;\n\t      };\n\t\n\t      // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events\n\t      function disableElementScroll() {\n\t        var zIndex = $window.getComputedStyle(element[0]).zIndex - 1;\n\t        if (isNaN(zIndex)) zIndex = 99;\n\t        var scrollMask = angular.element(\n\t            '<div class=\"md-scroll-mask\" style=\"z-index: ' + zIndex + '\">' +\n\t            '  <div class=\"md-scroll-mask-bar\"></div>' +\n\t            '</div>');\n\t        body.appendChild(scrollMask[0]);\n\t\n\t        scrollMask.on('wheel', preventDefault);\n\t        scrollMask.on('touchmove', preventDefault);\n\t        $document.on('keydown', disableKeyNav);\n\t\n\t        return function restoreScroll () {\n\t          scrollMask.off('wheel');\n\t          scrollMask.off('touchmove');\n\t          scrollMask[0].parentNode.removeChild(scrollMask[0]);\n\t          $document.off('keydown', disableKeyNav);\n\t          delete Util.disableScrollAround._enableScrolling;\n\t        };\n\t\n\t        // Prevent keypresses from elements inside the body\n\t        // used to stop the keypresses that could cause the page to scroll\n\t        // (arrow keys, spacebar, tab, etc).\n\t        function disableKeyNav(e) {\n\t          //-- temporarily removed this logic, will possibly re-add at a later date\n\t          return;\n\t          if (!element[0].contains(e.target)) {\n\t            e.preventDefault();\n\t            e.stopImmediatePropagation();\n\t          }\n\t        }\n\t\n\t        function preventDefault(e) {\n\t          e.preventDefault();\n\t        }\n\t      }\n\t\n\t      // Converts the body to a position fixed block and translate it to the proper scroll\n\t      // position\n\t      function disableBodyScroll() {\n\t        var restoreStyle = body.getAttribute('style') || '';\n\t        var scrollOffset = body.scrollTop + body.parentElement.scrollTop;\n\t\n\t        applyStyles(body, {\n\t          position: 'fixed',\n\t          width: '100%',\n\t          overflowY: 'scroll',\n\t          top: -scrollOffset + 'px'\n\t        });\n\t\n\t        return function restoreScroll() {\n\t          body.setAttribute('style', restoreStyle);\n\t          body.scrollTop = scrollOffset;\n\t        };\n\t      }\n\t\n\t      function applyStyles (el, styles) {\n\t        for (var key in styles) {\n\t          el.style[key] = styles[key];\n\t        }\n\t      }\n\t    },\n\t    enableScrolling: function () {\n\t      var method = this.disableScrollAround._enableScrolling;\n\t      method && method();\n\t    },\n\t    floatingScrollbars: function() {\n\t      if (this.floatingScrollbars.cached === undefined) {\n\t        var tempNode = angular.element('<div style=\"width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll\"><div style=\"height: 60;\"></div></div>');\n\t        $document[0].body.appendChild(tempNode[0]);\n\t        this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);\n\t        tempNode.remove();\n\t      }\n\t      return this.floatingScrollbars.cached;\n\t    },\n\t\n\t    // Mobile safari only allows you to set focus in click event listeners...\n\t    forceFocus: function(element) {\n\t      var node = element[0] || element;\n\t\n\t      document.addEventListener('click', function focusOnClick(ev) {\n\t        if (ev.target === node && ev.$focus) {\n\t          node.focus();\n\t          ev.stopImmediatePropagation();\n\t          ev.preventDefault();\n\t          node.removeEventListener('click', focusOnClick);\n\t        }\n\t      }, true);\n\t\n\t      var newEvent = document.createEvent('MouseEvents');\n\t      newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0,\n\t                       false, false, false, false, 0, null);\n\t      newEvent.$material = true;\n\t      newEvent.$focus = true;\n\t      node.dispatchEvent(newEvent);\n\t    },\n\t\n\t    transitionEndPromise: function(element, opts) {\n\t      opts = opts || {};\n\t      var deferred = $q.defer();\n\t      element.on($mdConstant.CSS.TRANSITIONEND, finished);\n\t      function finished(ev) {\n\t        // Make sure this transitionend didn't bubble up from a child\n\t        if (!ev || ev.target === element[0]) {\n\t          element.off($mdConstant.CSS.TRANSITIONEND, finished);\n\t          deferred.resolve();\n\t        }\n\t      }\n\t      if (opts.timeout) $timeout(finished, opts.timeout);\n\t      return deferred.promise;\n\t    },\n\t\n\t    fakeNgModel: function() {\n\t      return {\n\t        $fake: true,\n\t        $setTouched: angular.noop,\n\t        $setViewValue: function(value) {\n\t          this.$viewValue = value;\n\t          this.$render(value);\n\t          this.$viewChangeListeners.forEach(function(cb) { cb(); });\n\t        },\n\t        $isEmpty: function(value) {\n\t          return ('' + value).length === 0;\n\t        },\n\t        $parsers: [],\n\t        $formatters: [],\n\t        $viewChangeListeners: [],\n\t        $render: angular.noop\n\t      };\n\t    },\n\t\n\t    // Returns a function, that, as long as it continues to be invoked, will not\n\t    // be triggered. The function will be called after it stops being called for\n\t    // N milliseconds.\n\t    // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs\n\t    // @param invokeApply should the $timeout trigger $digest() dirty checking\n\t    debounce: function (func, wait, scope, invokeApply) {\n\t      var timer;\n\t\n\t      return function debounced() {\n\t        var context = scope,\n\t          args = Array.prototype.slice.call(arguments);\n\t\n\t        $timeout.cancel(timer);\n\t        timer = $timeout(function() {\n\t\n\t          timer = undefined;\n\t          func.apply(context, args);\n\t\n\t        }, wait || 10, invokeApply );\n\t      };\n\t    },\n\t\n\t    // Returns a function that can only be triggered every `delay` milliseconds.\n\t    // In other words, the function will not be called unless it has been more\n\t    // than `delay` milliseconds since the last call.\n\t    throttle: function throttle(func, delay) {\n\t      var recent;\n\t      return function throttled() {\n\t        var context = this;\n\t        var args = arguments;\n\t        var now = Util.now();\n\t\n\t        if (!recent || (now - recent > delay)) {\n\t          func.apply(context, args);\n\t          recent = now;\n\t        }\n\t      };\n\t    },\n\t\n\t    /**\n\t     * Measures the number of milliseconds taken to run the provided callback\n\t     * function. Uses a high-precision timer if available.\n\t     */\n\t    time: function time(cb) {\n\t      var start = Util.now();\n\t      cb();\n\t      return Util.now() - start;\n\t    },\n\t\n\t    /**\n\t     * Get a unique ID.\n\t     *\n\t     * @returns {string} an unique numeric string\n\t     */\n\t    nextUid: function() {\n\t      return '' + nextUniqueId++;\n\t    },\n\t\n\t    // Stop watchers and events from firing on a scope without destroying it,\n\t    // by disconnecting it from its parent and its siblings' linked lists.\n\t    disconnectScope: function disconnectScope(scope) {\n\t      if (!scope) return;\n\t\n\t      // we can't destroy the root scope or a scope that has been already destroyed\n\t      if (scope.$root === scope) return;\n\t      if (scope.$$destroyed ) return;\n\t\n\t      var parent = scope.$parent;\n\t      scope.$$disconnected = true;\n\t\n\t      // See Scope.$destroy\n\t      if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;\n\t      if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;\n\t      if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;\n\t      if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;\n\t\n\t      scope.$$nextSibling = scope.$$prevSibling = null;\n\t\n\t    },\n\t\n\t    // Undo the effects of disconnectScope above.\n\t    reconnectScope: function reconnectScope(scope) {\n\t      if (!scope) return;\n\t\n\t      // we can't disconnect the root node or scope already disconnected\n\t      if (scope.$root === scope) return;\n\t      if (!scope.$$disconnected) return;\n\t\n\t      var child = scope;\n\t\n\t      var parent = child.$parent;\n\t      child.$$disconnected = false;\n\t      // See Scope.$new for this logic...\n\t      child.$$prevSibling = parent.$$childTail;\n\t      if (parent.$$childHead) {\n\t        parent.$$childTail.$$nextSibling = child;\n\t        parent.$$childTail = child;\n\t      } else {\n\t        parent.$$childHead = parent.$$childTail = child;\n\t      }\n\t    },\n\t\n\t    /*\n\t     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName\n\t     *\n\t     * @param el Element to start walking the DOM from\n\t     * @param tagName Tag name to find closest to el, such as 'form'\n\t     */\n\t    getClosest: function getClosest(el, tagName, onlyParent) {\n\t      if (el instanceof angular.element) el = el[0];\n\t      tagName = tagName.toUpperCase();\n\t      if (onlyParent) el = el.parentNode;\n\t      if (!el) return null;\n\t      do {\n\t        if (el.nodeName === tagName) {\n\t          return el;\n\t        }\n\t      } while (el = el.parentNode);\n\t      return null;\n\t    },\n\t\n\t    /**\n\t     * Functional equivalent for $element.filter(‘md-bottom-sheet’)\n\t     * useful with interimElements where the element and its container are important...\n\t     */\n\t    extractElementByName: function (element, nodeName) {\n\t      for (var i = 0, len = element.length; i < len; i++) {\n\t        if (element[i].nodeName.toLowerCase() === nodeName){\n\t          return angular.element(element[i]);\n\t        }\n\t      }\n\t      return element;\n\t    },\n\t\n\t    /**\n\t     * Give optional properties with no value a boolean true by default\n\t     */\n\t    initOptionalProperties: function (scope, attr, defaults ) {\n\t       defaults = defaults || { };\n\t       angular.forEach(scope.$$isolateBindings, function (binding, key) {\n\t         if (binding.optional && angular.isUndefined(scope[key])) {\n\t           var hasKey = attr.hasOwnProperty(attr.$normalize(binding.attrName));\n\t\n\t           scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : hasKey;\n\t         }\n\t       });\n\t    }\n\t\n\t  };\n\t\n\t}]);\n\t\n\t/*\n\t * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.\n\t *\n\t * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.\n\t *\n\t * TODO(ajoslin): This should be added in a better place later.\n\t */\n\t\n\tangular.element.prototype.focus = angular.element.prototype.focus || function() {\n\t  if (this.length) {\n\t    this[0].focus();\n\t  }\n\t  return this;\n\t};\n\tangular.element.prototype.blur = angular.element.prototype.blur || function() {\n\t  if (this.length) {\n\t    this[0].blur();\n\t  }\n\t  return this;\n\t};\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t\n\tangular.module('material.core')\n\t  .service('$mdAria', AriaService);\n\t\n\t/*\n\t * @ngInject\n\t */\n\tfunction AriaService($$rAF, $log, $window) {\n\t\n\t  return {\n\t    expect: expect,\n\t    expectAsync: expectAsync,\n\t    expectWithText: expectWithText\n\t  };\n\t\n\t  /**\n\t   * Check if expected attribute has been specified on the target element or child\n\t   * @param element\n\t   * @param attrName\n\t   * @param {optional} defaultValue What to set the attr to if no value is found\n\t   */\n\t  function expect(element, attrName, defaultValue) {\n\t    var node = element[0] || element;\n\t\n\t    // if node exists and neither it nor its children have the attribute\n\t    if (node &&\n\t       ((!node.hasAttribute(attrName) ||\n\t        node.getAttribute(attrName).length === 0) &&\n\t        !childHasAttribute(node, attrName))) {\n\t\n\t      defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';\n\t      if (defaultValue.length) {\n\t        element.attr(attrName, defaultValue);\n\t      } else {\n\t        $log.warn('ARIA: Attribute \"', attrName, '\", required for accessibility, is missing on node:', node);\n\t      }\n\t\n\t    }\n\t  }\n\t\n\t  function expectAsync(element, attrName, defaultValueGetter) {\n\t    // Problem: when retrieving the element's contents synchronously to find the label,\n\t    // the text may not be defined yet in the case of a binding.\n\t    // There is a higher chance that a binding will be defined if we wait one frame.\n\t    $$rAF(function() {\n\t      expect(element, attrName, defaultValueGetter());\n\t    });\n\t  }\n\t\n\t  function expectWithText(element, attrName) {\n\t    expectAsync(element, attrName, function() {\n\t      return getText(element);\n\t    });\n\t  }\n\t\n\t  function getText(element) {\n\t    return element.text().trim();\n\t  }\n\t\n\t  function childHasAttribute(node, attrName) {\n\t    var hasChildren = node.hasChildNodes(),\n\t        hasAttr = false;\n\t\n\t    function isHidden(el) {\n\t      var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);\n\t      return (style.display === 'none');\n\t    }\n\t\n\t    if(hasChildren) {\n\t      var children = node.childNodes;\n\t      for(var i=0; i<children.length; i++){\n\t        var child = children[i];\n\t        if(child.nodeType === 1 && child.hasAttribute(attrName)) {\n\t          if(!isHidden(child)){\n\t            hasAttr = true;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hasAttr;\n\t  }\n\t}\n\tAriaService.$inject = [\"$$rAF\", \"$log\", \"$window\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core')\n\t  .service('$mdCompiler', mdCompilerService);\n\t\n\tfunction mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n\t  /* jshint validthis: true */\n\t\n\t  /*\n\t   * @ngdoc service\n\t   * @name $mdCompiler\n\t   * @module material.core\n\t   * @description\n\t   * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer\n\t   * to easily compile an element with a templateUrl, controller, and locals.\n\t   *\n\t   * @usage\n\t   * <hljs lang=\"js\">\n\t   * $mdCompiler.compile({\n\t   *   templateUrl: 'modal.html',\n\t   *   controller: 'ModalCtrl',\n\t   *   locals: {\n\t   *     modal: myModalInstance;\n\t   *   }\n\t   * }).then(function(compileData) {\n\t   *   compileData.element; // modal.html's template in an element\n\t   *   compileData.link(myScope); //attach controller & scope to element\n\t   * });\n\t   * </hljs>\n\t   */\n\t\n\t   /*\n\t    * @ngdoc method\n\t    * @name $mdCompiler#compile\n\t    * @description A helper to compile an HTML template/templateUrl with a given controller,\n\t    * locals, and scope.\n\t    * @param {object} options An options object, with the following properties:\n\t    *\n\t    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n\t    *      newly created scope or the name of a registered controller if passed as a string.\n\t    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n\t    *      published to scope under the `controllerAs` name.\n\t    *    - `template` - `{string=}` An html template as a string.\n\t    *    - `templateUrl` - `{string=}` A path to an html template.\n\t    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n\t    *      it is loaded. It will be given the template string as a parameter, and should\n\t    *      return a a new string representing the transformed template.\n\t    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n\t    *      be injected into the controller. If any of these dependencies are promises, the compiler\n\t    *      will wait for them all to be resolved, or if one is rejected before the controller is\n\t    *      instantiated `compile()` will fail..\n\t    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n\t    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n\t    *        Otherwise if function, then it is injected and the return value is treated as the\n\t    *        dependency. If the result is a promise, it is resolved before its value is \n\t    *        injected into the controller.\n\t    *\n\t    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n\t    * `compileData` has the following properties: \n\t    *\n\t    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n\t    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n\t    *     the element and instantiate the provided controller (if given).\n\t    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n\t    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n\t    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n\t    */\n\t  this.compile = function(options) {\n\t    var templateUrl = options.templateUrl;\n\t    var template = options.template || '';\n\t    var controller = options.controller;\n\t    var controllerAs = options.controllerAs;\n\t    var resolve = options.resolve || {};\n\t    var locals = options.locals || {};\n\t    var transformTemplate = options.transformTemplate || angular.identity;\n\t    var bindToController = options.bindToController;\n\t\n\t    // Take resolve values and invoke them.  \n\t    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n\t    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n\t    angular.forEach(resolve, function(value, key) {\n\t      if (angular.isString(value)) {\n\t        resolve[key] = $injector.get(value);\n\t      } else {\n\t        resolve[key] = $injector.invoke(value);\n\t      }\n\t    });\n\t    //Add the locals, which are just straight values to inject\n\t    //eg locals: { three: 3 }, will inject three into the controller\n\t    angular.extend(resolve, locals);\n\t\n\t    if (templateUrl) {\n\t      resolve.$template = $http.get(templateUrl, {cache: $templateCache})\n\t        .then(function(response) {\n\t          return response.data;\n\t        });\n\t    } else {\n\t      resolve.$template = $q.when(template);\n\t    }\n\t\n\t    // Wait for all the resolves to finish if they are promises\n\t    return $q.all(resolve).then(function(locals) {\n\t\n\t      var template = transformTemplate(locals.$template);\n\t      var element = options.element || angular.element('<div>').html(template.trim()).contents();\n\t      var linkFn = $compile(element);\n\t\n\t      //Return a linking function that can be used later when the element is ready\n\t      return {\n\t        locals: locals,\n\t        element: element,\n\t        link: function link(scope) {\n\t          locals.$scope = scope;\n\t\n\t          //Instantiate controller if it exists, because we have scope\n\t          if (controller) {\n\t            var invokeCtrl = $controller(controller, locals, true);\n\t            if (bindToController) {\n\t              angular.extend(invokeCtrl.instance, locals);\n\t            }\n\t            var ctrl = invokeCtrl();\n\t            //See angular-route source for this logic\n\t            element.data('$ngControllerController', ctrl);\n\t            element.children().data('$ngControllerController', ctrl);\n\t\n\t            if (controllerAs) {\n\t              scope[controllerAs] = ctrl;\n\t            }\n\t          }\n\t          return linkFn(scope);\n\t        }\n\t      };\n\t    });\n\t\n\t  };\n\t}\n\tmdCompilerService.$inject = [\"$q\", \"$http\", \"$injector\", \"$compile\", \"$controller\", \"$templateCache\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  var HANDLERS = {};\n\t  /* The state of the current 'pointer'\n\t   * The pointer represents the state of the current touch.\n\t   * It contains normalized x and y coordinates from DOM events,\n\t   * as well as other information abstracted from the DOM.\n\t   */\n\t  var pointer, lastPointer, forceSkipClickHijack = false;\n\t\n\t  // Used to attach event listeners once when multiple ng-apps are running.\n\t  var isInitialized = false;\n\t  \n\t  angular\n\t    .module('material.core.gestures', [ ])\n\t    .provider('$mdGesture', MdGestureProvider)\n\t    .factory('$$MdGestureHandler', MdGestureHandler)\n\t    .run( attachToDocument );\n\t\n\t  /**\n\t     * @ngdoc service\n\t     * @name $mdGestureProvider\n\t     * @module material.core.gestures\n\t     *\n\t     * @description\n\t     * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.\n\t     * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile\n\t     * devices.\n\t     *\n\t     * <hljs lang=\"js\">\n\t     *   app.config(function($mdGestureProvider) {\n\t     *\n\t     *     // For mobile devices without jQuery loaded, do not\n\t     *     // intercept click events during the capture phase.\n\t     *     $mdGestureProvider.skipClickHijack();\n\t     *\n\t     *   });\n\t     * </hljs>\n\t     *\n\t     */\n\t  function MdGestureProvider() { }\n\t\n\t  MdGestureProvider.prototype = {\n\t\n\t    // Publish access to setter to configure a variable  BEFORE the\n\t    // $mdGesture service is instantiated...\n\t    skipClickHijack: function() {\n\t      return forceSkipClickHijack = true;\n\t    },\n\t\n\t    /**\n\t     * $get is used to build an instance of $mdGesture\n\t     * @ngInject\n\t     */\n\t    $get : [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\", function($$MdGestureHandler, $$rAF, $timeout) {\n\t         return new MdGesture($$MdGestureHandler, $$rAF, $timeout);\n\t    }]\n\t  };\n\t\n\t\n\t\n\t  /**\n\t   * MdGesture factory construction function\n\t   * @ngInject\n\t   */\n\t  function MdGesture($$MdGestureHandler, $$rAF, $timeout) {\n\t    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n\t    var isIos = userAgent.match(/ipad|iphone|ipod/i);\n\t    var isAndroid = userAgent.match(/android/i);\n\t    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\t\n\t    var self = {\n\t      handler: addHandler,\n\t      register: register,\n\t      // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?\n\t      isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack\n\t    };\n\t\n\t    if (self.isHijackingClicks) {\n\t      self.handler('click', {\n\t        options: {\n\t          maxDistance: 6\n\t        },\n\t        onEnd: function (ev, pointer) {\n\t          if (pointer.distance < this.state.options.maxDistance) {\n\t            this.dispatchEvent(ev, 'click');\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    /*\n\t     * Register an element to listen for a handler.\n\t     * This allows an element to override the default options for a handler.\n\t     * Additionally, some handlers like drag and hold only dispatch events if\n\t     * the domEvent happens inside an element that's registered to listen for these events.\n\t     *\n\t     * @see GestureHandler for how overriding of default options works.\n\t     * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horziontal: false })\n\t     */\n\t    function register(element, handlerName, options) {\n\t      var handler = HANDLERS[handlerName.replace(/^\\$md./, '')];\n\t      if (!handler) {\n\t        throw new Error('Failed to register element with handler ' + handlerName + '. ' +\n\t        'Available handlers: ' + Object.keys(HANDLERS).join(', '));\n\t      }\n\t      return handler.registerElement(element, options);\n\t    }\n\t\n\t    /*\n\t     * add a handler to $mdGesture. see below.\n\t     */\n\t    function addHandler(name, definition) {\n\t      var handler = new $$MdGestureHandler(name);\n\t      angular.extend(handler, definition);\n\t      HANDLERS[name] = handler;\n\t\n\t      return self;\n\t    }\n\t\n\t    /*\n\t     * Register handlers. These listen to touch/start/move events, interpret them,\n\t     * and dispatch gesture events depending on options & conditions. These are all\n\t     * instances of GestureHandler.\n\t     * @see GestureHandler \n\t     */\n\t    return self\n\t      /*\n\t       * The press handler dispatches an event on touchdown/touchend.\n\t       * It's a simple abstraction of touch/mouse/pointer start and end.\n\t       */\n\t      .handler('press', {\n\t        onStart: function (ev, pointer) {\n\t          this.dispatchEvent(ev, '$md.pressdown');\n\t        },\n\t        onEnd: function (ev, pointer) {\n\t          this.dispatchEvent(ev, '$md.pressup');\n\t        }\n\t      })\n\t\n\t      /*\n\t       * The hold handler dispatches an event if the user keeps their finger within\n\t       * the same <maxDistance> area for <delay> ms.\n\t       * The hold handler will only run if a parent of the touch target is registered\n\t       * to listen for hold events through $mdGesture.register()\n\t       */\n\t      .handler('hold', {\n\t        options: {\n\t          maxDistance: 6,\n\t          delay: 500\n\t        },\n\t        onCancel: function () {\n\t          $timeout.cancel(this.state.timeout);\n\t        },\n\t        onStart: function (ev, pointer) {\n\t          // For hold, require a parent to be registered with $mdGesture.register()\n\t          // Because we prevent scroll events, this is necessary.\n\t          if (!this.state.registeredParent) return this.cancel();\n\t\n\t          this.state.pos = {x: pointer.x, y: pointer.y};\n\t          this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {\n\t            this.dispatchEvent(ev, '$md.hold');\n\t            this.cancel(); //we're done!\n\t          }), this.state.options.delay, false);\n\t        },\n\t        onMove: function (ev, pointer) {\n\t          // Don't scroll while waiting for hold.\n\t          // If we don't preventDefault touchmove events here, Android will assume we don't\n\t          // want to listen to anymore touch events. It will start scrolling and stop sending\n\t          // touchmove events.\n\t          ev.preventDefault();\n\t\n\t          // If the user moves greater than <maxDistance> pixels, stop the hold timer\n\t          // set in onStart\n\t          var dx = this.state.pos.x - pointer.x;\n\t          var dy = this.state.pos.y - pointer.y;\n\t          if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {\n\t            this.cancel();\n\t          }\n\t        },\n\t        onEnd: function () {\n\t          this.onCancel();\n\t        }\n\t      })\n\t\n\t      /*\n\t       * The drag handler dispatches a drag event if the user holds and moves his finger greater than\n\t       * <minDistance> px in the x or y direction, depending on options.horizontal.\n\t       * The drag will be cancelled if the user moves his finger greater than <minDistance>*<cancelMultiplier> in\n\t       * the perpindicular direction. Eg if the drag is horizontal and the user moves his finger <minDistance>*<cancelMultiplier>\n\t       * pixels vertically, this handler won't consider the move part of a drag.\n\t       */\n\t      .handler('drag', {\n\t        options: {\n\t          minDistance: 6,\n\t          horizontal: true,\n\t          cancelMultiplier: 1.5\n\t        },\n\t        onStart: function (ev) {\n\t          // For drag, require a parent to be registered with $mdGesture.register()\n\t          if (!this.state.registeredParent) this.cancel();\n\t        },\n\t        onMove: function (ev, pointer) {\n\t          var shouldStartDrag, shouldCancel;\n\t          // Don't scroll while deciding if this touchmove qualifies as a drag event.\n\t          // If we don't preventDefault touchmove events here, Android will assume we don't\n\t          // want to listen to anymore touch events. It will start scrolling and stop sending\n\t          // touchmove events.\n\t          ev.preventDefault();\n\t\n\t          if (!this.state.dragPointer) {\n\t            if (this.state.options.horizontal) {\n\t              shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;\n\t              shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n\t            } else {\n\t              shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;\n\t              shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n\t            }\n\t\n\t            if (shouldStartDrag) {\n\t              // Create a new pointer representing this drag, starting at this point where the drag started.\n\t              this.state.dragPointer = makeStartPointer(ev);\n\t              updatePointerState(ev, this.state.dragPointer);\n\t              this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);\n\t\n\t            } else if (shouldCancel) {\n\t              this.cancel();\n\t            }\n\t          } else {\n\t            this.dispatchDragMove(ev);\n\t          }\n\t        },\n\t        // Only dispatch dragmove events every frame; any more is unnecessray\n\t        dispatchDragMove: $$rAF.throttle(function (ev) {\n\t          // Make sure the drag didn't stop while waiting for the next frame\n\t          if (this.state.isRunning) {\n\t            updatePointerState(ev, this.state.dragPointer);\n\t            this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);\n\t          }\n\t        }),\n\t        onEnd: function (ev, pointer) {\n\t          if (this.state.dragPointer) {\n\t            updatePointerState(ev, this.state.dragPointer);\n\t            this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);\n\t          }\n\t        }\n\t      })\n\t\n\t      /*\n\t       * The swipe handler will dispatch a swipe event if, on the end of a touch,\n\t       * the velocity and distance were high enough.\n\t       * TODO: add vertical swiping with a `horizontal` option similar to the drag handler.\n\t       */\n\t      .handler('swipe', {\n\t        options: {\n\t          minVelocity: 0.65,\n\t          minDistance: 10\n\t        },\n\t        onEnd: function (ev, pointer) {\n\t          if (Math.abs(pointer.velocityX) > this.state.options.minVelocity &&\n\t            Math.abs(pointer.distanceX) > this.state.options.minDistance) {\n\t            var eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';\n\t            this.dispatchEvent(ev, eventType);\n\t          }\n\t        }\n\t      });\n\t\n\t  }\n\t  MdGesture.$inject = [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\"];\n\t\n\t  /**\n\t   * MdGestureHandler\n\t   * A GestureHandler is an object which is able to dispatch custom dom events\n\t   * based on native dom {touch,pointer,mouse}{start,move,end} events.\n\t   *\n\t   * A gesture will manage its lifecycle through the start,move,end, and cancel\n\t   * functions, which are called by native dom events.\n\t   *\n\t   * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be\n\t   * overridden by elements registering through $mdGesture.register()\n\t   */\n\t  function GestureHandler (name) {\n\t    this.name = name;\n\t    this.state = {};\n\t  }\n\t\n\t  function MdGestureHandler() {\n\t    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\t\n\t    GestureHandler.prototype = {\n\t      options: {},\n\t      // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events\n\t      // differently when jQuery is loaded\n\t      dispatchEvent: hasJQuery ?  jQueryDispatchEvent : nativeDispatchEvent,\n\t\n\t      // These are overridden by the registered handler\n\t      onStart: angular.noop,\n\t      onMove: angular.noop,\n\t      onEnd: angular.noop,\n\t      onCancel: angular.noop,\n\t\n\t      // onStart sets up a new state for the handler, which includes options from the\n\t      // nearest registered parent element of ev.target.\n\t      start: function (ev, pointer) {\n\t        if (this.state.isRunning) return;\n\t        var parentTarget = this.getNearestParent(ev.target);\n\t        // Get the options from the nearest registered parent\n\t        var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};\n\t\n\t        this.state = {\n\t          isRunning: true,\n\t          // Override the default options with the nearest registered parent's options\n\t          options: angular.extend({}, this.options, parentTargetOptions),\n\t          // Pass in the registered parent node to the state so the onStart listener can use\n\t          registeredParent: parentTarget\n\t        };\n\t        this.onStart(ev, pointer);\n\t      },\n\t      move: function (ev, pointer) {\n\t        if (!this.state.isRunning) return;\n\t        this.onMove(ev, pointer);\n\t      },\n\t      end: function (ev, pointer) {\n\t        if (!this.state.isRunning) return;\n\t        this.onEnd(ev, pointer);\n\t        this.state.isRunning = false;\n\t      },\n\t      cancel: function (ev, pointer) {\n\t        this.onCancel(ev, pointer);\n\t        this.state = {};\n\t      },\n\t\n\t      // Find and return the nearest parent element that has been registered to\n\t      // listen for this handler via $mdGesture.register(element, 'handlerName').\n\t      getNearestParent: function (node) {\n\t        var current = node;\n\t        while (current) {\n\t          if ((current.$mdGesture || {})[this.name]) {\n\t            return current;\n\t          }\n\t          current = current.parentNode;\n\t        }\n\t        return null;\n\t      },\n\t\n\t      // Called from $mdGesture.register when an element reigsters itself with a handler.\n\t      // Store the options the user gave on the DOMElement itself. These options will\n\t      // be retrieved with getNearestParent when the handler starts.\n\t      registerElement: function (element, options) {\n\t        var self = this;\n\t        element[0].$mdGesture = element[0].$mdGesture || {};\n\t        element[0].$mdGesture[this.name] = options || {};\n\t        element.on('$destroy', onDestroy);\n\t\n\t        return onDestroy;\n\t\n\t        function onDestroy() {\n\t          delete element[0].$mdGesture[self.name];\n\t          element.off('$destroy', onDestroy);\n\t        }\n\t      }\n\t    };\n\t\n\t    return GestureHandler;\n\t\n\t    /*\n\t     * Dispatch an event with jQuery\n\t     * TODO: Make sure this sends bubbling events\n\t     *\n\t     * @param srcEvent the original DOM touch event that started this.\n\t     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n\t     * @param eventPointer the pointer object that matches this event.\n\t     */\n\t    function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {\n\t      eventPointer = eventPointer || pointer;\n\t      var eventObj = new angular.element.Event(eventType);\n\t\n\t      eventObj.$material = true;\n\t      eventObj.pointer = eventPointer;\n\t      eventObj.srcEvent = srcEvent;\n\t\n\t      angular.extend(eventObj, {\n\t        clientX: eventPointer.x,\n\t        clientY: eventPointer.y,\n\t        screenX: eventPointer.x,\n\t        screenY: eventPointer.y,\n\t        pageX: eventPointer.x,\n\t        pageY: eventPointer.y,\n\t        ctrlKey: srcEvent.ctrlKey,\n\t        altKey: srcEvent.altKey,\n\t        shiftKey: srcEvent.shiftKey,\n\t        metaKey: srcEvent.metaKey\n\t      });\n\t      angular.element(eventPointer.target).trigger(eventObj);\n\t    }\n\t\n\t    /*\n\t     * NOTE: nativeDispatchEvent is very performance sensitive.\n\t     * @param srcEvent the original DOM touch event that started this.\n\t     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n\t     * @param eventPointer the pointer object that matches this event.\n\t     */\n\t    function nativeDispatchEvent(srcEvent, eventType, eventPointer) {\n\t      eventPointer = eventPointer || pointer;\n\t      var eventObj;\n\t\n\t      if (eventType === 'click') {\n\t        eventObj = document.createEvent('MouseEvents');\n\t        eventObj.initMouseEvent(\n\t          'click', true, true, window, srcEvent.detail,\n\t          eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y,\n\t          srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey,\n\t          srcEvent.button, srcEvent.relatedTarget || null\n\t        );\n\t\n\t      } else {\n\t        eventObj = document.createEvent('CustomEvent');\n\t        eventObj.initCustomEvent(eventType, true, true, {});\n\t      }\n\t      eventObj.$material = true;\n\t      eventObj.pointer = eventPointer;\n\t      eventObj.srcEvent = srcEvent;\n\t      eventPointer.target.dispatchEvent(eventObj);\n\t    }\n\t\n\t  }\n\t\n\t  /**\n\t   * Attach Gestures: hook document and check shouldHijack clicks\n\t   * @ngInject\n\t   */\n\t  function attachToDocument( $mdGesture, $$MdGestureHandler ) {\n\t\n\t    // Polyfill document.contains for IE11.\n\t    // TODO: move to util\n\t    document.contains || (document.contains = function (node) {\n\t      return document.body.contains(node);\n\t    });\n\t\n\t    if (!isInitialized && $mdGesture.isHijackingClicks ) {\n\t      /*\n\t       * If hijack clicks is true, we preventDefault any click that wasn't\n\t       * sent by ngMaterial. This is because on older Android & iOS, a false, or 'ghost',\n\t       * click event will be sent ~400ms after a touchend event happens.\n\t       * The only way to know if this click is real is to prevent any normal\n\t       * click events, and add a flag to events sent by material so we know not to prevent those.\n\t       * \n\t       * Two exceptions to click events that should be prevented are:\n\t       *  - click events sent by the keyboard (eg form submit)\n\t       *  - events that originate from an Ionic app\n\t       */\n\t      document.addEventListener('click', function clickHijacker(ev) {\n\t        var isKeyClick = ev.clientX === 0 && ev.clientY === 0;\n\t        if (!isKeyClick && !ev.$material && !ev.isIonicTap) {\n\t          ev.preventDefault();\n\t          ev.stopPropagation();\n\t        }\n\t      }, true);\n\t      \n\t      isInitialized = true;\n\t    }\n\t\n\t    // Listen to all events to cover all platforms.\n\t    var START_EVENTS = 'mousedown touchstart pointerdown';\n\t    var MOVE_EVENTS = 'mousemove touchmove pointermove';\n\t    var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';\n\t\n\t    angular.element(document)\n\t      .on(START_EVENTS, gestureStart)\n\t      .on(MOVE_EVENTS, gestureMove)\n\t      .on(END_EVENTS, gestureEnd)\n\t      // For testing\n\t      .on('$$mdGestureReset', function gestureClearCache () {\n\t        lastPointer = pointer = null;\n\t      });\n\t\n\t    /*\n\t     * When a DOM event happens, run all registered gesture handlers' lifecycle\n\t     * methods which match the DOM event.\n\t     * Eg when a 'touchstart' event happens, runHandlers('start') will call and\n\t     * run `handler.cancel()` and `handler.start()` on all registered handlers.\n\t     */\n\t    function runHandlers(handlerEvent, event) {\n\t      var handler;\n\t      for (var name in HANDLERS) {\n\t        handler = HANDLERS[name];\n\t        if( handler instanceof $$MdGestureHandler ) {\n\t\n\t          if (handlerEvent === 'start') {\n\t            // Run cancel to reset any handlers' state\n\t            handler.cancel();\n\t          }\n\t          handler[handlerEvent](event, pointer);\n\t\n\t        }\n\t      }\n\t    }\n\t\n\t    /*\n\t     * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)\n\t     * If it is legitimate, we initiate the pointer state and mark the current pointer's type\n\t     * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events\n\t     * won't effect it.\n\t     */\n\t    function gestureStart(ev) {\n\t      // If we're already touched down, abort\n\t      if (pointer) return;\n\t\n\t      var now = +Date.now();\n\t\n\t      // iOS & old android bug: after a touch event, a click event is sent 350 ms later.\n\t      // If <400ms have passed, don't allow an event of a different type than the previous event\n\t      if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {\n\t        return;\n\t      }\n\t\n\t      pointer = makeStartPointer(ev);\n\t\n\t      runHandlers('start', ev);\n\t    }\n\t    /*\n\t     * If a move event happens of the right type, update the pointer and run all the move handlers.\n\t     * \"of the right type\": if a mousemove happens but our pointer started with a touch event, do nothing.\n\t     */\n\t    function gestureMove(ev) {\n\t      if (!pointer || !typesMatch(ev, pointer)) return;\n\t\n\t      updatePointerState(ev, pointer);\n\t      runHandlers('move', ev);\n\t    }\n\t    /*\n\t     * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as 'lastPointer'\n\t     */\n\t    function gestureEnd(ev) {\n\t      if (!pointer || !typesMatch(ev, pointer)) return;\n\t\n\t      updatePointerState(ev, pointer);\n\t      pointer.endTime = +Date.now();\n\t\n\t      runHandlers('end', ev);\n\t\n\t      lastPointer = pointer;\n\t      pointer = null;\n\t    }\n\t\n\t  }\n\t  attachToDocument.$inject = [\"$mdGesture\", \"$$MdGestureHandler\"];\n\t\n\t  // ********************\n\t  // Module Functions\n\t  // ********************\n\t\n\t  /*\n\t   * Initiate the pointer. x, y, and the pointer's type.\n\t   */\n\t  function makeStartPointer(ev) {\n\t    var point = getEventPoint(ev);\n\t    var startPointer = {\n\t      startTime: +Date.now(),\n\t      target: ev.target,\n\t      // 'p' for pointer events, 'm' for mouse, 't' for touch\n\t      type: ev.type.charAt(0)\n\t    };\n\t    startPointer.startX = startPointer.x = point.pageX;\n\t    startPointer.startY = startPointer.y = point.pageY;\n\t    return startPointer;\n\t  }\n\t\n\t  /*\n\t   * return whether the pointer's type matches the event's type.\n\t   * Eg if a touch event happens but the pointer has a mouse type, return false.\n\t   */\n\t  function typesMatch(ev, pointer) {\n\t    return ev && pointer && ev.type.charAt(0) === pointer.type;\n\t  }\n\t\n\t  /*\n\t   * Update the given pointer based upon the given DOMEvent.\n\t   * Distance, velocity, direction, duration, etc\n\t   */\n\t  function updatePointerState(ev, pointer) {\n\t    var point = getEventPoint(ev);\n\t    var x = pointer.x = point.pageX;\n\t    var y = pointer.y = point.pageY;\n\t\n\t    pointer.distanceX = x - pointer.startX;\n\t    pointer.distanceY = y - pointer.startY;\n\t    pointer.distance = Math.sqrt(\n\t      pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY\n\t    );\n\t\n\t    pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';\n\t    pointer.directionY = pointer.distanceY > 0 ? 'up' : pointer.distanceY < 0 ? 'down' : '';\n\t\n\t    pointer.duration = +Date.now() - pointer.startTime;\n\t    pointer.velocityX = pointer.distanceX / pointer.duration;\n\t    pointer.velocityY = pointer.distanceY / pointer.duration;\n\t  }\n\t\n\t  /*\n\t   * Normalize the point where the DOM event happened whether it's touch or mouse.\n\t   * @returns point event obj with pageX and pageY on it.\n\t   */\n\t  function getEventPoint(ev) {\n\t    ev = ev.originalEvent || ev; // support jQuery events\n\t    return (ev.touches && ev.touches[0]) ||\n\t      (ev.changedTouches && ev.changedTouches[0]) ||\n\t      ev;\n\t  }\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core')\n\t  .provider('$$interimElement', InterimElementProvider);\n\t\n\t/*\n\t * @ngdoc service\n\t * @name $$interimElement\n\t * @module material.core\n\t *\n\t * @description\n\t *\n\t * Factory that contructs `$$interimElement.$service` services.\n\t * Used internally in material design for elements that appear on screen temporarily.\n\t * The service provides a promise-like API for interacting with the temporary\n\t * elements.\n\t *\n\t * ```js\n\t * app.service('$mdToast', function($$interimElement) {\n\t *   var $mdToast = $$interimElement(toastDefaultOptions);\n\t *   return $mdToast;\n\t * });\n\t * ```\n\t * @param {object=} defaultOptions Options used by default for the `show` method on the service.\n\t *\n\t * @returns {$$interimElement.$service}\n\t *\n\t */\n\t\n\tfunction InterimElementProvider() {\n\t  createInterimElementProvider.$get = InterimElementFactory;\n\t  InterimElementFactory.$inject = [\"$document\", \"$q\", \"$rootScope\", \"$timeout\", \"$rootElement\", \"$animate\", \"$interpolate\", \"$mdCompiler\", \"$mdTheming\"];\n\t  return createInterimElementProvider;\n\t\n\t  /**\n\t   * Returns a new provider which allows configuration of a new interimElement\n\t   * service. Allows configuration of default options & methods for options,\n\t   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)\n\t   */\n\t  function createInterimElementProvider(interimFactoryName) {\n\t    var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];\n\t\n\t    var customMethods = {};\n\t    var providerConfig = {\n\t      presets: {}\n\t    };\n\t\n\t    var provider = {\n\t      setDefaults: setDefaults,\n\t      addPreset: addPreset,\n\t      addMethod: addMethod,\n\t      $get: factory\n\t    };\n\t\n\t    /**\n\t     * all interim elements will come with the 'build' preset\n\t     */\n\t    provider.addPreset('build', {\n\t      methods: ['controller', 'controllerAs', 'resolve',\n\t        'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']\n\t    });\n\t\n\t    factory.$inject = [\"$$interimElement\", \"$animate\", \"$injector\"];\n\t    return provider;\n\t\n\t    /**\n\t     * Save the configured defaults to be used when the factory is instantiated\n\t     */\n\t    function setDefaults(definition) {\n\t      providerConfig.optionsFactory = definition.options;\n\t      providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);\n\t      return provider;\n\t    }\n\t\n\t    /**\n\t     * Add a method to the factory that isn't specific to any interim element operations\n\t     */\n\t\n\t    function addMethod(name, fn) {\n\t      customMethods[name] = fn;\n\t      return provider;\n\t    }\n\t\n\t    /**\n\t     * Save the configured preset to be used when the factory is instantiated\n\t     */\n\t    function addPreset(name, definition) {\n\t      definition = definition || {};\n\t      definition.methods = definition.methods || [];\n\t      definition.options = definition.options || function() { return {}; };\n\t\n\t      if (/^cancel|hide|show$/.test(name)) {\n\t        throw new Error(\"Preset '\" + name + \"' in \" + interimFactoryName + \" is reserved!\");\n\t      }\n\t      if (definition.methods.indexOf('_options') > -1) {\n\t        throw new Error(\"Method '_options' in \" + interimFactoryName + \" is reserved!\");\n\t      }\n\t      providerConfig.presets[name] = {\n\t        methods: definition.methods.concat(EXPOSED_METHODS),\n\t        optionsFactory: definition.options,\n\t        argOption: definition.argOption\n\t      };\n\t      return provider;\n\t    }\n\t\n\t    /**\n\t     * Create a factory that has the given methods & defaults implementing interimElement\n\t     */\n\t    /* @ngInject */\n\t    function factory($$interimElement, $animate, $injector) {\n\t      var defaultMethods;\n\t      var defaultOptions;\n\t      var interimElementService = $$interimElement();\n\t\n\t      /*\n\t       * publicService is what the developer will be using.\n\t       * It has methods hide(), cancel(), show(), build(), and any other\n\t       * presets which were set during the config phase.\n\t       */\n\t      var publicService = {\n\t        hide: interimElementService.hide,\n\t        cancel: interimElementService.cancel,\n\t        show: showInterimElement\n\t      };\n\t\n\t      defaultMethods = providerConfig.methods || [];\n\t      // This must be invoked after the publicService is initialized\n\t      defaultOptions = invokeFactory(providerConfig.optionsFactory, {});\n\t\n\t      // Copy over the simple custom methods\n\t      angular.forEach(customMethods, function(fn, name) {\n\t        publicService[name] = fn;\n\t      });\n\t\n\t      angular.forEach(providerConfig.presets, function(definition, name) {\n\t        var presetDefaults = invokeFactory(definition.optionsFactory, {});\n\t        var presetMethods = (definition.methods || []).concat(defaultMethods);\n\t\n\t        // Every interimElement built with a preset has a field called `$type`,\n\t        // which matches the name of the preset.\n\t        // Eg in preset 'confirm', options.$type === 'confirm'\n\t        angular.extend(presetDefaults, { $type: name });\n\t\n\t        // This creates a preset class which has setter methods for every\n\t        // method given in the `.addPreset()` function, as well as every\n\t        // method given in the `.setDefaults()` function.\n\t        //\n\t        // @example\n\t        // .setDefaults({\n\t        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],\n\t        //   options: dialogDefaultOptions\n\t        // })\n\t        // .addPreset('alert', {\n\t        //   methods: ['title', 'ok'],\n\t        //   options: alertDialogOptions\n\t        // })\n\t        //\n\t        // Set values will be passed to the options when interimElemnt.show() is called.\n\t        function Preset(opts) {\n\t          this._options = angular.extend({}, presetDefaults, opts);\n\t        }\n\t        angular.forEach(presetMethods, function(name) {\n\t          Preset.prototype[name] = function(value) {\n\t            this._options[name] = value;\n\t            return this;\n\t          };\n\t        });\n\t\n\t        // Create shortcut method for one-linear methods\n\t        if (definition.argOption) {\n\t          var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);\n\t          publicService[methodName] = function(arg) {\n\t            var config = publicService[name](arg);\n\t            return publicService.show(config);\n\t          };\n\t        }\n\t\n\t        // eg $mdDialog.alert() will return a new alert preset\n\t        publicService[name] = function(arg) {\n\t          // If argOption is supplied, eg `argOption: 'content'`, then we assume\n\t          // if the argument is not an options object then it is the `argOption` option.\n\t          //\n\t          // @example `$mdToast.simple('hello')` // sets options.content to hello\n\t          //                                     // because argOption === 'content'\n\t          if (arguments.length && definition.argOption && !angular.isObject(arg) &&\n\t              !angular.isArray(arg)) {\n\t            return (new Preset())[definition.argOption](arg);\n\t          } else {\n\t            return new Preset(arg);\n\t          }\n\t\n\t        };\n\t      });\n\t\n\t      return publicService;\n\t\n\t      function showInterimElement(opts) {\n\t        // opts is either a preset which stores its options on an _options field,\n\t        // or just an object made up of options\n\t        if (opts && opts._options) opts = opts._options;\n\t        return interimElementService.show(\n\t          angular.extend({}, defaultOptions, opts)\n\t        );\n\t      }\n\t\n\t      /**\n\t       * Helper to call $injector.invoke with a local of the factory name for\n\t       * this provider.\n\t       * If an $mdDialog is providing options for a dialog and tries to inject\n\t       * $mdDialog, a circular dependency error will happen.\n\t       * We get around that by manually injecting $mdDialog as a local.\n\t       */\n\t      function invokeFactory(factory, defaultVal) {\n\t        var locals = {};\n\t        locals[interimFactoryName] = publicService;\n\t        return $injector.invoke(factory || function() { return defaultVal; }, {}, locals);\n\t      }\n\t\n\t    }\n\t\n\t  }\n\t\n\t  /* @ngInject */\n\t  function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate,\n\t                                 $interpolate, $mdCompiler, $mdTheming ) {\n\t    var startSymbol = $interpolate.startSymbol(),\n\t        endSymbol = $interpolate.endSymbol(),\n\t        usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}')),\n\t        processTemplate  = usesStandardSymbols ? angular.identity : replaceInterpolationSymbols;\n\t\n\t    return function createInterimElementService() {\n\t      /*\n\t       * @ngdoc service\n\t       * @name $$interimElement.$service\n\t       *\n\t       * @description\n\t       * A service used to control inserting and removing an element into the DOM.\n\t       *\n\t       */\n\t      var stack = [];\n\t      var service;\n\t      return service = {\n\t        show: show,\n\t        hide: hide,\n\t        cancel: cancel\n\t      };\n\t\n\t      /*\n\t       * @ngdoc method\n\t       * @name $$interimElement.$service#show\n\t       * @kind function\n\t       *\n\t       * @description\n\t       * Adds the `$interimElement` to the DOM and returns a promise that will be resolved or rejected\n\t       * with hide or cancel, respectively.\n\t       *\n\t       * @param {*} options is hashMap of settings\n\t       * @returns a Promise\n\t       *\n\t       */\n\t      function show(options) {\n\t        if (stack.length) {\n\t          return service.cancel().then(function() {\n\t            return show(options);\n\t          });\n\t        } else {\n\t          var interimElement = new InterimElement(options);\n\t          stack.push(interimElement);\n\t          return interimElement.show().then(function() {\n\t            return interimElement.deferred.promise;\n\t          });\n\t        }\n\t      }\n\t\n\t      /*\n\t       * @ngdoc method\n\t       * @name $$interimElement.$service#hide\n\t       * @kind function\n\t       *\n\t       * @description\n\t       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`\n\t       *\n\t       * @param {*} resolveParam Data to resolve the promise with\n\t       * @returns a Promise that will be resolved after the element has been removed.\n\t       *\n\t       */\n\t      function hide(response) {\n\t        var interimElement = stack.shift();\n\t        return interimElement && interimElement.remove().then(function() {\n\t          interimElement.deferred.resolve(response);\n\t        });\n\t      }\n\t\n\t      /*\n\t       * @ngdoc method\n\t       * @name $$interimElement.$service#cancel\n\t       * @kind function\n\t       *\n\t       * @description\n\t       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`\n\t       *\n\t       * @param {*} reason Data to reject the promise with\n\t       * @returns Promise that will be resolved after the element has been removed.\n\t       *\n\t       */\n\t      function cancel(reason) {\n\t        var interimElement = stack.shift();\n\t        return $q.when(interimElement && interimElement.remove().then(function() {\n\t          interimElement.deferred.reject(reason);\n\t        }));\n\t      }\n\t\n\t\n\t      /*\n\t       * Internal Interim Element Object\n\t       * Used internally to manage the DOM element and related data\n\t       */\n\t      function InterimElement(options) {\n\t        var self;\n\t        var hideTimeout, element, showDone, removeDone;\n\t\n\t        options = options || {};\n\t        options = angular.extend({\n\t          preserveScope: false,\n\t          scope: options.scope || $rootScope.$new(options.isolateScope),\n\t          onShow: function(scope, element, options) {\n\t            return $animate.enter(element, options.parent);\n\t          },\n\t          onRemove: function(scope, element, options) {\n\t            // Element could be undefined if a new element is shown before\n\t            // the old one finishes compiling.\n\t            return element && $animate.leave(element) || $q.when();\n\t          }\n\t        }, options);\n\t\n\t        if (options.template) {\n\t          options.template = processTemplate(options.template);\n\t        }\n\t\n\t        return self = {\n\t          options: options,\n\t          deferred: $q.defer(),\n\t          show: function() {\n\t            var compilePromise;\n\t            if (options.skipCompile) {\n\t              compilePromise = $q(function(resolve) { \n\t                resolve({\n\t                  locals: {},\n\t                  link: function() { return options.element; }\n\t                });\n\t              });\n\t            } else {\n\t              compilePromise = $mdCompiler.compile(options);\n\t            }\n\t\n\t            return showDone = compilePromise.then(function(compileData) {\n\t              angular.extend(compileData.locals, self.options);\n\t\n\t              element = compileData.link(options.scope);\n\t\n\t              // Search for parent at insertion time, if not specified\n\t              if (angular.isFunction(options.parent)) {\n\t                options.parent = options.parent(options.scope, element, options);\n\t              } else if (angular.isString(options.parent)) {\n\t                options.parent = angular.element($document[0].querySelector(options.parent));\n\t              }\n\t\n\t              // If parent querySelector/getter function fails, or it's just null,\n\t              // find a default.\n\t              if (!(options.parent || {}).length) {\n\t                var el;\n\t                if ($rootElement[0] && $rootElement[0].querySelector) {\n\t                  el = $rootElement[0].querySelector(':not(svg) > body');\n\t                }\n\t                if (!el) el = $rootElement[0];\n\t                if (el.nodeName == '#comment') {\n\t                  el = $document[0].body;\n\t                }\n\t                options.parent = angular.element(el);\n\t              }\n\t\n\t              if (options.themable) $mdTheming(element);\n\t              var ret = options.onShow(options.scope, element, options);\n\t              return $q.when(ret)\n\t                .then(function(){\n\t                  // Issue onComplete callback when the `show()` finishes\n\t                  (options.onComplete || angular.noop)(options.scope, element, options);\n\t                  startHideTimeout();\n\t                });\n\t\n\t              function startHideTimeout() {\n\t                if (options.hideDelay) {\n\t                  hideTimeout = $timeout(service.cancel, options.hideDelay) ;\n\t                }\n\t              }\n\t            }, function(reason) { showDone = true; self.deferred.reject(reason); });\n\t          },\n\t          cancelTimeout: function() {\n\t            if (hideTimeout) {\n\t              $timeout.cancel(hideTimeout);\n\t              hideTimeout = undefined;\n\t            }\n\t          },\n\t          remove: function() {\n\t            self.cancelTimeout();\n\t            return removeDone = $q.when(showDone).then(function() {\n\t              var ret = element ? options.onRemove(options.scope, element, options) : true;\n\t              return $q.when(ret).then(function() {\n\t                if (!options.preserveScope) options.scope.$destroy();\n\t                removeDone = true;\n\t              });\n\t            });\n\t          }\n\t        };\n\t      }\n\t    };\n\t\n\t    /*\n\t     * Replace `{{` and `}}` in a string (usually a template) with the actual start-/endSymbols used\n\t     * for interpolation. This allows pre-defined templates (for components such as dialog, toast etc)\n\t     * to continue to work in apps that use custom interpolation start-/endSymbols.\n\t     *\n\t     * @param {string} text The text in which to replace `{{` / `}}`\n\t     * @returns {string} The modified string using the actual interpolation start-/endSymbols\n\t     */\n\t    function replaceInterpolationSymbols(text) {\n\t      if (!text || !angular.isString(text)) return text;\n\t      return text.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n\t    }\n\t  }\n\t\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  /**\n\t   * @ngdoc module\n\t   * @name material.core.componentRegistry\n\t   *\n\t   * @description\n\t   * A component instance registration service.\n\t   * Note: currently this as a private service in the SideNav component.\n\t   */\n\t  angular.module('material.core')\n\t    .factory('$mdComponentRegistry', ComponentRegistry);\n\t\n\t  /*\n\t   * @private\n\t   * @ngdoc factory\n\t   * @name ComponentRegistry\n\t   * @module material.core.componentRegistry\n\t   *\n\t   */\n\t  function ComponentRegistry($log, $q) {\n\t\n\t    var self;\n\t    var instances = [ ];\n\t    var pendings = { };\n\t\n\t    return self = {\n\t      /**\n\t       * Used to print an error when an instance for a handle isn't found.\n\t       */\n\t      notFoundError: function(handle) {\n\t        $log.error('No instance found for handle', handle);\n\t      },\n\t      /**\n\t       * Return all registered instances as an array.\n\t       */\n\t      getInstances: function() {\n\t        return instances;\n\t      },\n\t\n\t      /**\n\t       * Get a registered instance.\n\t       * @param handle the String handle to look up for a registered instance.\n\t       */\n\t      get: function(handle) {\n\t        if ( !isValidID(handle) ) return null;\n\t\n\t        var i, j, instance;\n\t        for(i = 0, j = instances.length; i < j; i++) {\n\t          instance = instances[i];\n\t          if(instance.$$mdHandle === handle) {\n\t            return instance;\n\t          }\n\t        }\n\t        return null;\n\t      },\n\t\n\t      /**\n\t       * Register an instance.\n\t       * @param instance the instance to register\n\t       * @param handle the handle to identify the instance under.\n\t       */\n\t      register: function(instance, handle) {\n\t        if ( !handle ) return angular.noop;\n\t\n\t        instance.$$mdHandle = handle;\n\t        instances.push(instance);\n\t        resolveWhen();\n\t\n\t        return deregister;\n\t\n\t        /**\n\t         * Remove registration for an instance\n\t         */\n\t        function deregister() {\n\t          var index = instances.indexOf(instance);\n\t          if (index !== -1) {\n\t            instances.splice(index, 1);\n\t          }\n\t        }\n\t\n\t        /**\n\t         * Resolve any pending promises for this instance\n\t         */\n\t        function resolveWhen() {\n\t          var dfd = pendings[handle];\n\t          if ( dfd ) {\n\t            dfd.resolve( instance );\n\t            delete pendings[handle];\n\t          }\n\t        }\n\t      },\n\t\n\t      /**\n\t       * Async accessor to registered component instance\n\t       * If not available then a promise is created to notify\n\t       * all listeners when the instance is registered.\n\t       */\n\t      when : function(handle) {\n\t        if ( isValidID(handle) ) {\n\t          var deferred = $q.defer();\n\t          var instance = self.get(handle);\n\t\n\t          if ( instance )  {\n\t            deferred.resolve( instance );\n\t          } else {\n\t            pendings[handle] = deferred;\n\t          }\n\t\n\t          return deferred.promise;\n\t        }\n\t        return $q.reject(\"Invalid `md-component-id` value.\");\n\t      }\n\t\n\t    };\n\t\n\t    function isValidID(handle){\n\t      return handle && (handle !== \"\");\n\t    }\n\t\n\t  }\n\t  ComponentRegistry.$inject = [\"$log\", \"$q\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  /**\n\t   * @ngdoc service\n\t   * @name $mdButtonInkRipple\n\t   * @module material.core\n\t   *\n\t   * @description\n\t   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.\n\t   *\n\t   * @param {object=} scope Scope within the current context\n\t   * @param {object=} element The element the ripple effect should be applied to\n\t   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n\t   */\n\t\n\t  angular.module('material.core')\n\t    .factory('$mdButtonInkRipple', MdButtonInkRipple);\n\t\n\t  function MdButtonInkRipple($mdInkRipple) {\n\t    return {\n\t      attach: attach\n\t    };\n\t\n\t    function attach(scope, element, options) {\n\t      var elementOptions = optionsForElement(element);\n\t      return $mdInkRipple.attach(scope, element, angular.extend(elementOptions, options));\n\t    };\n\t\n\t    function optionsForElement(element) {\n\t      if (element.hasClass('md-icon-button')) {\n\t        return {\n\t          isMenuItem: element.hasClass('md-menu-item'),\n\t          fitRipple: true,\n\t          center: true\n\t        };\n\t      } else {\n\t        return {\n\t          isMenuItem: element.hasClass('md-menu-item'),\n\t          dimBackground: true\n\t        }\n\t      }\n\t    };\n\t  }\n\t  MdButtonInkRipple.$inject = [\"$mdInkRipple\"];;\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t    /**\n\t   * @ngdoc service\n\t   * @name $mdCheckboxInkRipple\n\t   * @module material.core\n\t   *\n\t   * @description\n\t   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.\n\t   *\n\t   * @param {object=} scope Scope within the current context\n\t   * @param {object=} element The element the ripple effect should be applied to\n\t   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n\t   */\n\t\n\t  angular.module('material.core')\n\t    .factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);\n\t\n\t  function MdCheckboxInkRipple($mdInkRipple) {\n\t    return {\n\t      attach: attach\n\t    };\n\t\n\t    function attach(scope, element, options) {\n\t      return $mdInkRipple.attach(scope, element, angular.extend({\n\t        center: true,\n\t        dimBackground: false,\n\t        fitRipple: true\n\t      }, options));\n\t    };\n\t  }\n\t  MdCheckboxInkRipple.$inject = [\"$mdInkRipple\"];;\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  /**\n\t   * @ngdoc service\n\t   * @name $mdListInkRipple\n\t   * @module material.core\n\t   *\n\t   * @description\n\t   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.\n\t   *\n\t   * @param {object=} scope Scope within the current context\n\t   * @param {object=} element The element the ripple effect should be applied to\n\t   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n\t   */\n\t\n\t  angular.module('material.core')\n\t    .factory('$mdListInkRipple', MdListInkRipple);\n\t\n\t  function MdListInkRipple($mdInkRipple) {\n\t    return {\n\t      attach: attach\n\t    };\n\t\n\t    function attach(scope, element, options) {\n\t      return $mdInkRipple.attach(scope, element, angular.extend({\n\t        center: false,\n\t        dimBackground: true,\n\t        outline: false,\n\t        rippleSize: 'full'\n\t      }, options));\n\t    };\n\t  }\n\t  MdListInkRipple.$inject = [\"$mdInkRipple\"];;\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core')\n\t  .factory('$mdInkRipple', InkRippleService)\n\t  .directive('mdInkRipple', InkRippleDirective)\n\t  .directive('mdNoInk', attrNoDirective())\n\t  .directive('mdNoBar', attrNoDirective())\n\t  .directive('mdNoStretch', attrNoDirective());\n\t\n\tfunction InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {\n\t  return {\n\t    controller: angular.noop,\n\t    link: function (scope, element, attr) {\n\t      if (attr.hasOwnProperty('mdInkRippleCheckbox')) {\n\t        $mdCheckboxInkRipple.attach(scope, element);\n\t      } else {\n\t        $mdButtonInkRipple.attach(scope, element);\n\t      }\n\t    }\n\t  };\n\t}\n\tInkRippleDirective.$inject = [\"$mdButtonInkRipple\", \"$mdCheckboxInkRipple\"];\n\t\n\tfunction InkRippleService($window, $timeout) {\n\t\n\t  return {\n\t    attach: attach\n\t  };\n\t\n\t  function attach(scope, element, options) {\n\t    if (element.controller('mdNoInk')) return angular.noop;\n\t\n\t    options = angular.extend({\n\t      colorElement: element,\n\t      mousedown: true,\n\t      hover: true,\n\t      focus: true,\n\t      center: false,\n\t      mousedownPauseTime: 150,\n\t      dimBackground: false,\n\t      outline: false,\n\t      fullRipple: true,\n\t      isMenuItem: false,\n\t      fitRipple: false\n\t    }, options);\n\t\n\t    var rippleSize,\n\t        controller = element.controller('mdInkRipple') || {},\n\t        counter = 0,\n\t        ripples = [],\n\t        states = [],\n\t        isActiveExpr = element.attr('md-highlight'),\n\t        isActive = false,\n\t        isHeld = false,\n\t        node = element[0],\n\t        rippleSizeSetting = element.attr('md-ripple-size'),\n\t        color = parseColor(element.attr('md-ink-ripple')) || parseColor(options.colorElement.length && $window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\t\n\t    switch (rippleSizeSetting) {\n\t      case 'full':\n\t        options.fullRipple = true;\n\t        break;\n\t      case 'partial':\n\t        options.fullRipple = false;\n\t        break;\n\t    }\n\t\n\t    // expose onInput for ripple testing\n\t    if (options.mousedown) {\n\t      element.on('$md.pressdown', onPressDown)\n\t        .on('$md.pressup', onPressUp);\n\t    }\n\t\n\t    controller.createRipple = createRipple;\n\t\n\t    if (isActiveExpr) {\n\t      scope.$watch(isActiveExpr, function watchActive(newValue) {\n\t        isActive = newValue;\n\t        if (isActive && !ripples.length) {\n\t          $timeout(function () { createRipple(0, 0); }, 0, false);\n\t        }\n\t        angular.forEach(ripples, updateElement);\n\t      });\n\t    }\n\t\n\t    // Publish self-detach method if desired...\n\t    return function detach() {\n\t      element.off('$md.pressdown', onPressDown)\n\t        .off('$md.pressup', onPressUp);\n\t      getRippleContainer().remove();\n\t    };\n\t\n\t    /**\n\t     * Gets the current ripple container\n\t     * If there is no ripple container, it creates one and returns it\n\t     *\n\t     * @returns {angular.element} ripple container element\n\t     */\n\t    function getRippleContainer() {\n\t      var container = element.data('$mdRippleContainer');\n\t      if (container) return container;\n\t      container = angular.element('<div class=\"md-ripple-container\">');\n\t      element.append(container);\n\t      element.data('$mdRippleContainer', container);\n\t      return container;\n\t    }\n\t\n\t    function parseColor(color) {\n\t      if (!color) return;\n\t      if (color.indexOf('rgba') === 0) return color.replace(/\\d?\\.?\\d*\\s*\\)\\s*$/, '0.1)');\n\t      if (color.indexOf('rgb')  === 0) return rgbToRGBA(color);\n\t      if (color.indexOf('#')    === 0) return hexToRGBA(color);\n\t\n\t      /**\n\t       * Converts a hex value to an rgba string\n\t       *\n\t       * @param {string} hex value (3 or 6 digits) to be converted\n\t       *\n\t       * @returns {string} rgba color with 0.1 alpha\n\t       */\n\t      function hexToRGBA(color) {\n\t        var hex = color.charAt(0) === '#' ? color.substr(1) : color,\n\t          dig = hex.length / 3,\n\t          red = hex.substr(0, dig),\n\t          grn = hex.substr(dig, dig),\n\t          blu = hex.substr(dig * 2);\n\t        if (dig === 1) {\n\t          red += red;\n\t          grn += grn;\n\t          blu += blu;\n\t        }\n\t        return 'rgba(' + parseInt(red, 16) + ',' + parseInt(grn, 16) + ',' + parseInt(blu, 16) + ',0.1)';\n\t      }\n\t\n\t      /**\n\t       * Converts rgb value to rgba string\n\t       *\n\t       * @param {string} rgb color string\n\t       *\n\t       * @returns {string} rgba color with 0.1 alpha\n\t       */\n\t      function rgbToRGBA(color) {\n\t        return color.replace(')', ', 0.1)').replace('(', 'a(');\n\t      }\n\t\n\t    }\n\t\n\t    function removeElement(elem, wait) {\n\t      ripples.splice(ripples.indexOf(elem), 1);\n\t      if (ripples.length === 0) {\n\t        getRippleContainer().css({ backgroundColor: '' });\n\t      }\n\t      $timeout(function () { elem.remove(); }, wait, false);\n\t    }\n\t\n\t    function updateElement(elem) {\n\t      var index = ripples.indexOf(elem),\n\t          state = states[index] || {},\n\t          elemIsActive = ripples.length > 1 ? false : isActive,\n\t          elemIsHeld   = ripples.length > 1 ? false : isHeld;\n\t      if (elemIsActive || state.animating || elemIsHeld) {\n\t        elem.addClass('md-ripple-visible');\n\t      } else if (elem) {\n\t        elem.removeClass('md-ripple-visible');\n\t        if (options.outline) {\n\t          elem.css({\n\t            width: rippleSize + 'px',\n\t            height: rippleSize + 'px',\n\t            marginLeft: (rippleSize * -1) + 'px',\n\t            marginTop: (rippleSize * -1) + 'px'\n\t          });\n\t        }\n\t        removeElement(elem, options.outline ? 450 : 650);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Creates a ripple at the provided coordinates\n\t     *\n\t     * @param {number} left cursor position\n\t     * @param {number} top cursor position\n\t     *\n\t     * @returns {angular.element} the generated ripple element\n\t     */\n\t    function createRipple(left, top) {\n\t\n\t      color = parseColor(element.attr('md-ink-ripple')) || parseColor($window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\t\n\t      var container = getRippleContainer(),\n\t          size = getRippleSize(left, top),\n\t          css = getRippleCss(size, left, top),\n\t          elem = getRippleElement(css),\n\t          index = ripples.indexOf(elem),\n\t          state = states[index] || {};\n\t\n\t      rippleSize = size;\n\t\n\t      state.animating = true;\n\t\n\t      $timeout(function () {\n\t        if (options.dimBackground) {\n\t          container.css({ backgroundColor: color });\n\t        }\n\t        elem.addClass('md-ripple-placed md-ripple-scaled');\n\t        if (options.outline) {\n\t          elem.css({\n\t            borderWidth: (size * 0.5) + 'px',\n\t            marginLeft: (size * -0.5) + 'px',\n\t            marginTop: (size * -0.5) + 'px'\n\t          });\n\t        } else {\n\t          elem.css({ left: '50%', top: '50%' });\n\t        }\n\t        updateElement(elem);\n\t        $timeout(function () {\n\t          state.animating = false;\n\t          updateElement(elem);\n\t        }, (options.outline ? 450 : 225), false);\n\t      }, 0, false);\n\t\n\t      return elem;\n\t\n\t      /**\n\t       * Creates the ripple element with the provided css\n\t       *\n\t       * @param {object} css properties to be applied\n\t       *\n\t       * @returns {angular.element} the generated ripple element\n\t       */\n\t      function getRippleElement(css) {\n\t        var elem = angular.element('<div class=\"md-ripple\" data-counter=\"' + counter++ + '\">');\n\t        ripples.unshift(elem);\n\t        states.unshift({ animating: true });\n\t        container.append(elem);\n\t        css && elem.css(css);\n\t        return elem;\n\t      }\n\t\n\t      /**\n\t       * Calculate the ripple size\n\t       *\n\t       * @returns {number} calculated ripple diameter\n\t       */\n\t      function getRippleSize(left, top) {\n\t        var width = container.prop('offsetWidth'),\n\t            height = container.prop('offsetHeight'),\n\t            multiplier, size, rect;\n\t        if (options.isMenuItem) {\n\t          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n\t        } else if (options.outline) {\n\t          rect = node.getBoundingClientRect();\n\t          left -= rect.left;\n\t          top -= rect.top;\n\t          width = Math.max(left, width - left);\n\t          height = Math.max(top, height - top);\n\t          size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n\t        } else {\n\t          multiplier = options.fullRipple ? 1.1 : 0.8;\n\t          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * multiplier;\n\t          if (options.fitRipple) {\n\t            size = Math.min(height, width, size);\n\t          }\n\t        }\n\t        return size;\n\t      }\n\t\n\t      /**\n\t       * Generates the ripple css\n\t       *\n\t       * @param {number} the diameter of the ripple\n\t       * @param {number} the left cursor offset\n\t       * @param {number} the top cursor offset\n\t       *\n\t       * @returns {{backgroundColor: string, borderColor: string, width: string, height: string}}\n\t       */\n\t      function getRippleCss(size, left, top) {\n\t        var rect = node.getBoundingClientRect(),\n\t            css  = {\n\t              backgroundColor: rgbaToRGB(color),\n\t              borderColor: rgbaToRGB(color),\n\t              width: size + 'px',\n\t              height: size + 'px'\n\t            };\n\t\n\t        if (options.outline) {\n\t          css.width = 0;\n\t          css.height = 0;\n\t        } else {\n\t          css.marginLeft = css.marginTop = (size * -0.5) + 'px';\n\t        }\n\t\n\t        if (options.center) {\n\t          css.left = css.top = '50%';\n\t        } else {\n\t          css.left = Math.round((left - rect.left) / container.prop('offsetWidth') * 100) + '%';\n\t          css.top = Math.round((top - rect.top) / container.prop('offsetHeight') * 100) + '%';\n\t        }\n\t\n\t        return css;\n\t\n\t        /**\n\t         * Converts rgba string to rgb, removing the alpha value\n\t         *\n\t         * @param {string} rgba color\n\t         *\n\t         * @returns {string} rgb color\n\t         */\n\t        function rgbaToRGB(color) {\n\t          return color.replace('rgba', 'rgb').replace(/,[^\\),]+\\)/, ')');\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Handles user input start and stop events\n\t     *\n\t     */\n\t    function onPressDown(ev) {\n\t      if (!isRippleAllowed()) return;\n\t\n\t      createRipple(ev.pointer.x, ev.pointer.y);\n\t      isHeld = true;\n\t    }\n\t    function onPressUp() {\n\t      isHeld = false;\n\t      var ripple = ripples[ ripples.length - 1 ];\n\t      $timeout(function () { updateElement(ripple); }, 0, false);\n\t    }\n\t\n\t    /**\n\t     * Determines if the ripple is allowed\n\t     *\n\t     * @returns {boolean} true if the ripple is allowed, false if not\n\t     */\n\t    function isRippleAllowed() {\n\t      var parent = node.parentNode;\n\t      var grandparent = parent && parent.parentNode;\n\t      var ancestor = grandparent && grandparent.parentNode;\n\t      return !isDisabled(node) && !isDisabled(parent) && !isDisabled(grandparent) && !isDisabled(ancestor);\n\t      function isDisabled (elem) {\n\t        return elem && elem.hasAttribute && elem.hasAttribute('disabled');\n\t      }\n\t    }\n\t\n\t  }\n\t}\n\tInkRippleService.$inject = [\"$window\", \"$timeout\"];\n\t\n\t/**\n\t * noink/nobar/nostretch directive: make any element that has one of\n\t * these attributes be given a controller, so that other directives can\n\t * `require:` these and see if there is a `no<xxx>` parent attribute.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <parent md-no-ink>\n\t *   <child detect-no>\n\t *   </child>\n\t * </parent>\n\t * </hljs>\n\t *\n\t * <hljs lang=\"js\">\n\t * myApp.directive('detectNo', function() {\n\t *   return {\n\t *     require: ['^?mdNoInk', ^?mdNoBar'],\n\t *     link: function(scope, element, attr, ctrls) {\n\t *       var noinkCtrl = ctrls[0];\n\t *       var nobarCtrl = ctrls[1];\n\t *       if (noInkCtrl) {\n\t *         alert(\"the md-no-ink flag has been specified on an ancestor!\");\n\t *       }\n\t *       if (nobarCtrl) {\n\t *         alert(\"the md-no-bar flag has been specified on an ancestor!\");\n\t *       }\n\t *     }\n\t *   };\n\t * });\n\t * </hljs>\n\t */\n\tfunction attrNoDirective() {\n\t  return function() {\n\t    return {\n\t      controller: angular.noop\n\t    };\n\t  };\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t    /**\n\t   * @ngdoc service\n\t   * @name $mdTabInkRipple\n\t   * @module material.core\n\t   *\n\t   * @description\n\t   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.\n\t   *\n\t   * @param {object=} scope Scope within the current context\n\t   * @param {object=} element The element the ripple effect should be applied to\n\t   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n\t   */\n\t\n\t  angular.module('material.core')\n\t    .factory('$mdTabInkRipple', MdTabInkRipple);\n\t\n\t  function MdTabInkRipple($mdInkRipple) {\n\t    return {\n\t      attach: attach\n\t    };\n\t\n\t    function attach(scope, element, options) {\n\t      return $mdInkRipple.attach(scope, element, angular.extend({\n\t        center: false,\n\t        dimBackground: true,\n\t        outline: false,\n\t        rippleSize: 'full'\n\t      }, options));\n\t    };\n\t  }\n\t  MdTabInkRipple.$inject = [\"$mdInkRipple\"];;\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core.theming.palette', [])\n\t.constant('$mdColorPalette', {\n\t  'red': {\n\t    '50': '#ffebee',\n\t    '100': '#ffcdd2',\n\t    '200': '#ef9a9a',\n\t    '300': '#e57373',\n\t    '400': '#ef5350',\n\t    '500': '#f44336',\n\t    '600': '#e53935',\n\t    '700': '#d32f2f',\n\t    '800': '#c62828',\n\t    '900': '#b71c1c',\n\t    'A100': '#ff8a80',\n\t    'A200': '#ff5252',\n\t    'A400': '#ff1744',\n\t    'A700': '#d50000',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 300 400 A100',\n\t    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n\t  },\n\t  'pink': {\n\t    '50': '#fce4ec',\n\t    '100': '#f8bbd0',\n\t    '200': '#f48fb1',\n\t    '300': '#f06292',\n\t    '400': '#ec407a',\n\t    '500': '#e91e63',\n\t    '600': '#d81b60',\n\t    '700': '#c2185b',\n\t    '800': '#ad1457',\n\t    '900': '#880e4f',\n\t    'A100': '#ff80ab',\n\t    'A200': '#ff4081',\n\t    'A400': '#f50057',\n\t    'A700': '#c51162',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 300 400 A100',\n\t    'contrastStrongLightColors': '500 600 A200 A400 A700'\n\t  },\n\t  'purple': {\n\t    '50': '#f3e5f5',\n\t    '100': '#e1bee7',\n\t    '200': '#ce93d8',\n\t    '300': '#ba68c8',\n\t    '400': '#ab47bc',\n\t    '500': '#9c27b0',\n\t    '600': '#8e24aa',\n\t    '700': '#7b1fa2',\n\t    '800': '#6a1b9a',\n\t    '900': '#4a148c',\n\t    'A100': '#ea80fc',\n\t    'A200': '#e040fb',\n\t    'A400': '#d500f9',\n\t    'A700': '#aa00ff',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 A100',\n\t    'contrastStrongLightColors': '300 400 A200 A400 A700'\n\t  },\n\t  'deep-purple': {\n\t    '50': '#ede7f6',\n\t    '100': '#d1c4e9',\n\t    '200': '#b39ddb',\n\t    '300': '#9575cd',\n\t    '400': '#7e57c2',\n\t    '500': '#673ab7',\n\t    '600': '#5e35b1',\n\t    '700': '#512da8',\n\t    '800': '#4527a0',\n\t    '900': '#311b92',\n\t    'A100': '#b388ff',\n\t    'A200': '#7c4dff',\n\t    'A400': '#651fff',\n\t    'A700': '#6200ea',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 A100',\n\t    'contrastStrongLightColors': '300 400 A200'\n\t  },\n\t  'indigo': {\n\t    '50': '#e8eaf6',\n\t    '100': '#c5cae9',\n\t    '200': '#9fa8da',\n\t    '300': '#7986cb',\n\t    '400': '#5c6bc0',\n\t    '500': '#3f51b5',\n\t    '600': '#3949ab',\n\t    '700': '#303f9f',\n\t    '800': '#283593',\n\t    '900': '#1a237e',\n\t    'A100': '#8c9eff',\n\t    'A200': '#536dfe',\n\t    'A400': '#3d5afe',\n\t    'A700': '#304ffe',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 A100',\n\t    'contrastStrongLightColors': '300 400 A200 A400'\n\t  },\n\t  'blue': {\n\t    '50': '#e3f2fd',\n\t    '100': '#bbdefb',\n\t    '200': '#90caf9',\n\t    '300': '#64b5f6',\n\t    '400': '#42a5f5',\n\t    '500': '#2196f3',\n\t    '600': '#1e88e5',\n\t    '700': '#1976d2',\n\t    '800': '#1565c0',\n\t    '900': '#0d47a1',\n\t    'A100': '#82b1ff',\n\t    'A200': '#448aff',\n\t    'A400': '#2979ff',\n\t    'A700': '#2962ff',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '100 200 300 400 A100',\n\t    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n\t  },\n\t  'light-blue': {\n\t    '50': '#e1f5fe',\n\t    '100': '#b3e5fc',\n\t    '200': '#81d4fa',\n\t    '300': '#4fc3f7',\n\t    '400': '#29b6f6',\n\t    '500': '#03a9f4',\n\t    '600': '#039be5',\n\t    '700': '#0288d1',\n\t    '800': '#0277bd',\n\t    '900': '#01579b',\n\t    'A100': '#80d8ff',\n\t    'A200': '#40c4ff',\n\t    'A400': '#00b0ff',\n\t    'A700': '#0091ea',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '500 600 700 800 900 A700',\n\t    'contrastStrongLightColors': '500 600 700 800 A700'\n\t  },\n\t  'cyan': {\n\t    '50': '#e0f7fa',\n\t    '100': '#b2ebf2',\n\t    '200': '#80deea',\n\t    '300': '#4dd0e1',\n\t    '400': '#26c6da',\n\t    '500': '#00bcd4',\n\t    '600': '#00acc1',\n\t    '700': '#0097a7',\n\t    '800': '#00838f',\n\t    '900': '#006064',\n\t    'A100': '#84ffff',\n\t    'A200': '#18ffff',\n\t    'A400': '#00e5ff',\n\t    'A700': '#00b8d4',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '500 600 700 800 900',\n\t    'contrastStrongLightColors': '500 600 700 800'\n\t  },\n\t  'teal': {\n\t    '50': '#e0f2f1',\n\t    '100': '#b2dfdb',\n\t    '200': '#80cbc4',\n\t    '300': '#4db6ac',\n\t    '400': '#26a69a',\n\t    '500': '#009688',\n\t    '600': '#00897b',\n\t    '700': '#00796b',\n\t    '800': '#00695c',\n\t    '900': '#004d40',\n\t    'A100': '#a7ffeb',\n\t    'A200': '#64ffda',\n\t    'A400': '#1de9b6',\n\t    'A700': '#00bfa5',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '500 600 700 800 900',\n\t    'contrastStrongLightColors': '500 600 700'\n\t  },\n\t  'green': {\n\t    '50': '#e8f5e9',\n\t    '100': '#c8e6c9',\n\t    '200': '#a5d6a7',\n\t    '300': '#81c784',\n\t    '400': '#66bb6a',\n\t    '500': '#4caf50',\n\t    '600': '#43a047',\n\t    '700': '#388e3c',\n\t    '800': '#2e7d32',\n\t    '900': '#1b5e20',\n\t    'A100': '#b9f6ca',\n\t    'A200': '#69f0ae',\n\t    'A400': '#00e676',\n\t    'A700': '#00c853',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '500 600 700 800 900',\n\t    'contrastStrongLightColors': '500 600 700'\n\t  },\n\t  'light-green': {\n\t    '50': '#f1f8e9',\n\t    '100': '#dcedc8',\n\t    '200': '#c5e1a5',\n\t    '300': '#aed581',\n\t    '400': '#9ccc65',\n\t    '500': '#8bc34a',\n\t    '600': '#7cb342',\n\t    '700': '#689f38',\n\t    '800': '#558b2f',\n\t    '900': '#33691e',\n\t    'A100': '#ccff90',\n\t    'A200': '#b2ff59',\n\t    'A400': '#76ff03',\n\t    'A700': '#64dd17',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '800 900',\n\t    'contrastStrongLightColors': '800 900'\n\t  },\n\t  'lime': {\n\t    '50': '#f9fbe7',\n\t    '100': '#f0f4c3',\n\t    '200': '#e6ee9c',\n\t    '300': '#dce775',\n\t    '400': '#d4e157',\n\t    '500': '#cddc39',\n\t    '600': '#c0ca33',\n\t    '700': '#afb42b',\n\t    '800': '#9e9d24',\n\t    '900': '#827717',\n\t    'A100': '#f4ff81',\n\t    'A200': '#eeff41',\n\t    'A400': '#c6ff00',\n\t    'A700': '#aeea00',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '900',\n\t    'contrastStrongLightColors': '900'\n\t  },\n\t  'yellow': {\n\t    '50': '#fffde7',\n\t    '100': '#fff9c4',\n\t    '200': '#fff59d',\n\t    '300': '#fff176',\n\t    '400': '#ffee58',\n\t    '500': '#ffeb3b',\n\t    '600': '#fdd835',\n\t    '700': '#fbc02d',\n\t    '800': '#f9a825',\n\t    '900': '#f57f17',\n\t    'A100': '#ffff8d',\n\t    'A200': '#ffff00',\n\t    'A400': '#ffea00',\n\t    'A700': '#ffd600',\n\t    'contrastDefaultColor': 'dark'\n\t  },\n\t  'amber': {\n\t    '50': '#fff8e1',\n\t    '100': '#ffecb3',\n\t    '200': '#ffe082',\n\t    '300': '#ffd54f',\n\t    '400': '#ffca28',\n\t    '500': '#ffc107',\n\t    '600': '#ffb300',\n\t    '700': '#ffa000',\n\t    '800': '#ff8f00',\n\t    '900': '#ff6f00',\n\t    'A100': '#ffe57f',\n\t    'A200': '#ffd740',\n\t    'A400': '#ffc400',\n\t    'A700': '#ffab00',\n\t    'contrastDefaultColor': 'dark'\n\t  },\n\t  'orange': {\n\t    '50': '#fff3e0',\n\t    '100': '#ffe0b2',\n\t    '200': '#ffcc80',\n\t    '300': '#ffb74d',\n\t    '400': '#ffa726',\n\t    '500': '#ff9800',\n\t    '600': '#fb8c00',\n\t    '700': '#f57c00',\n\t    '800': '#ef6c00',\n\t    '900': '#e65100',\n\t    'A100': '#ffd180',\n\t    'A200': '#ffab40',\n\t    'A400': '#ff9100',\n\t    'A700': '#ff6d00',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '800 900',\n\t    'contrastStrongLightColors': '800 900'\n\t  },\n\t  'deep-orange': {\n\t    '50': '#fbe9e7',\n\t    '100': '#ffccbc',\n\t    '200': '#ffab91',\n\t    '300': '#ff8a65',\n\t    '400': '#ff7043',\n\t    '500': '#ff5722',\n\t    '600': '#f4511e',\n\t    '700': '#e64a19',\n\t    '800': '#d84315',\n\t    '900': '#bf360c',\n\t    'A100': '#ff9e80',\n\t    'A200': '#ff6e40',\n\t    'A400': '#ff3d00',\n\t    'A700': '#dd2c00',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 300 400 A100 A200',\n\t    'contrastStrongLightColors': '500 600 700 800 900 A400 A700'\n\t  },\n\t  'brown': {\n\t    '50': '#efebe9',\n\t    '100': '#d7ccc8',\n\t    '200': '#bcaaa4',\n\t    '300': '#a1887f',\n\t    '400': '#8d6e63',\n\t    '500': '#795548',\n\t    '600': '#6d4c41',\n\t    '700': '#5d4037',\n\t    '800': '#4e342e',\n\t    '900': '#3e2723',\n\t    'A100': '#d7ccc8',\n\t    'A200': '#bcaaa4',\n\t    'A400': '#8d6e63',\n\t    'A700': '#5d4037',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200',\n\t    'contrastStrongLightColors': '300 400'\n\t  },\n\t  'grey': {\n\t    '50': '#fafafa',\n\t    '100': '#f5f5f5',\n\t    '200': '#eeeeee',\n\t    '300': '#e0e0e0',\n\t    '400': '#bdbdbd',\n\t    '500': '#9e9e9e',\n\t    '600': '#757575',\n\t    '700': '#616161',\n\t    '800': '#424242',\n\t    '900': '#212121',\n\t    '1000': '#000000',\n\t    'A100': '#ffffff',\n\t    'A200': '#eeeeee',\n\t    'A400': '#bdbdbd',\n\t    'A700': '#616161',\n\t    'contrastDefaultColor': 'dark',\n\t    'contrastLightColors': '600 700 800 900'\n\t  },\n\t  'blue-grey': {\n\t    '50': '#eceff1',\n\t    '100': '#cfd8dc',\n\t    '200': '#b0bec5',\n\t    '300': '#90a4ae',\n\t    '400': '#78909c',\n\t    '500': '#607d8b',\n\t    '600': '#546e7a',\n\t    '700': '#455a64',\n\t    '800': '#37474f',\n\t    '900': '#263238',\n\t    'A100': '#cfd8dc',\n\t    'A200': '#b0bec5',\n\t    'A400': '#78909c',\n\t    'A700': '#455a64',\n\t    'contrastDefaultColor': 'light',\n\t    'contrastDarkColors': '50 100 200 300',\n\t    'contrastStrongLightColors': '400 500'\n\t  }\n\t});\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.core.theming', ['material.core.theming.palette'])\n\t  .directive('mdTheme', ThemingDirective)\n\t  .directive('mdThemable', ThemableDirective)\n\t  .provider('$mdTheming', ThemingProvider)\n\t  .run(generateThemes);\n\t\n\t/**\n\t * @ngdoc provider\n\t * @name $mdThemingProvider\n\t * @module material.core\n\t *\n\t * @description Provider to configure the `$mdTheming` service.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdThemingProvider#setDefaultTheme\n\t * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdThemingProvider#alwaysWatchTheme\n\t * @param {boolean} watch Whether or not to always watch themes for changes and re-apply\n\t * classes when they change. Default is `false`. Enabling can reduce performance.\n\t */\n\t\n\t/* Some Example Valid Theming Expressions\n\t * =======================================\n\t *\n\t * Intention group expansion: (valid for primary, accent, warn, background)\n\t *\n\t * {{primary-100}} - grab shade 100 from the primary palette\n\t * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7\n\t * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette\n\t * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1\n\t * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue\n\t * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules\n\t * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue\n\t * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules\n\t *\n\t * Foreground expansion: Applies rgba to black/white foreground text\n\t *\n\t * {{foreground-1}} - used for primary text\n\t * {{foreground-2}} - used for secondary text/divider\n\t * {{foreground-3}} - used for disabled text\n\t * {{foreground-4}} - used for dividers\n\t *\n\t */\n\t\n\t// In memory generated CSS rules; registered by theme.name\n\tvar GENERATED = { };\n\t\n\t// In memory storage of defined themes and color palettes (both loaded by CSS, and user specified)\n\tvar PALETTES;\n\tvar THEMES;\n\t\n\tvar DARK_FOREGROUND = {\n\t  name: 'dark',\n\t  '1': 'rgba(0,0,0,0.87)',\n\t  '2': 'rgba(0,0,0,0.54)',\n\t  '3': 'rgba(0,0,0,0.26)',\n\t  '4': 'rgba(0,0,0,0.12)'\n\t};\n\tvar LIGHT_FOREGROUND = {\n\t  name: 'light',\n\t  '1': 'rgba(255,255,255,1.0)',\n\t  '2': 'rgba(255,255,255,0.7)',\n\t  '3': 'rgba(255,255,255,0.3)',\n\t  '4': 'rgba(255,255,255,0.12)'\n\t};\n\t\n\tvar DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';\n\tvar LIGHT_SHADOW = '';\n\t\n\tvar DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');\n\tvar LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87');\n\tvar STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');\n\t\n\tvar THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];\n\tvar DEFAULT_COLOR_TYPE = 'primary';\n\t\n\t// A color in a theme will use these hues by default, if not specified by user.\n\tvar LIGHT_DEFAULT_HUES = {\n\t  'accent': {\n\t    'default': 'A200',\n\t    'hue-1': 'A100',\n\t    'hue-2': 'A400',\n\t    'hue-3': 'A700'\n\t  },\n\t  'background': {\n\t    'default': 'A100',\n\t    'hue-1': '300',\n\t    'hue-2': '800',\n\t    'hue-3': '900'\n\t  }\n\t};\n\t\n\tvar DARK_DEFAULT_HUES = {\n\t  'background': {\n\t    'default': '800',\n\t    'hue-1': '300',\n\t    'hue-2': '600',\n\t    'hue-3': '900'\n\t  }\n\t};\n\tTHEME_COLOR_TYPES.forEach(function(colorType) {\n\t  // Color types with unspecified default hues will use these default hue values\n\t  var defaultDefaultHues = {\n\t    'default': '500',\n\t    'hue-1': '300',\n\t    'hue-2': '800',\n\t    'hue-3': 'A100'\n\t  };\n\t  if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;\n\t  if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;\n\t});\n\t\n\tvar VALID_HUE_VALUES = [\n\t  '50', '100', '200', '300', '400', '500', '600',\n\t  '700', '800', '900', 'A100', 'A200', 'A400', 'A700'\n\t];\n\t\n\tfunction ThemingProvider($mdColorPalette) {\n\t  PALETTES = { };\n\t  THEMES = { };\n\t\n\t  var themingProvider;\n\t  var defaultTheme = 'default';\n\t  var alwaysWatchTheme = false;\n\t\n\t  // Load JS Defined Palettes\n\t  angular.extend(PALETTES, $mdColorPalette);\n\t\n\t  // Default theme defined in core.js\n\t\n\t  ThemingService.$inject = [\"$rootScope\", \"$log\"];\n\t  return themingProvider = {\n\t    definePalette: definePalette,\n\t    extendPalette: extendPalette,\n\t    theme: registerTheme,\n\t\n\t    setDefaultTheme: function(theme) {\n\t      defaultTheme = theme;\n\t    },\n\t    alwaysWatchTheme: function(alwaysWatch) {\n\t      alwaysWatchTheme = alwaysWatch;\n\t    },\n\t    $get: ThemingService,\n\t    _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,\n\t    _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,\n\t    _PALETTES: PALETTES,\n\t    _THEMES: THEMES,\n\t    _parseRules: parseRules,\n\t    _rgba: rgba\n\t  };\n\t\n\t  // Example: $mdThemingProvider.definePalette('neonRed', { 50: '#f5fafa', ... });\n\t  function definePalette(name, map) {\n\t    map = map || {};\n\t    PALETTES[name] = checkPaletteValid(name, map);\n\t    return themingProvider;\n\t  }\n\t\n\t  // Returns an new object which is a copy of a given palette `name` with variables from\n\t  // `map` overwritten\n\t  // Example: var neonRedMap = $mdThemingProvider.extendPalette('red', { 50: '#f5fafafa' });\n\t  function extendPalette(name, map) {\n\t    return checkPaletteValid(name,  angular.extend({}, PALETTES[name] || {}, map) );\n\t  }\n\t\n\t  // Make sure that palette has all required hues\n\t  function checkPaletteValid(name, map) {\n\t    var missingColors = VALID_HUE_VALUES.filter(function(field) {\n\t      return !map[field];\n\t    });\n\t    if (missingColors.length) {\n\t      throw new Error(\"Missing colors %1 in palette %2!\"\n\t                      .replace('%1', missingColors.join(', '))\n\t                      .replace('%2', name));\n\t    }\n\t\n\t    return map;\n\t  }\n\t\n\t  // Register a theme (which is a collection of color palettes to use with various states\n\t  // ie. warn, accent, primary )\n\t  // Optionally inherit from an existing theme\n\t  // $mdThemingProvider.theme('custom-theme').primaryPalette('red');\n\t  function registerTheme(name, inheritFrom) {\n\t    if (THEMES[name]) return THEMES[name];\n\t\n\t    inheritFrom = inheritFrom || 'default';\n\t\n\t    var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;\n\t    var theme = new Theme(name);\n\t\n\t    if (parentTheme) {\n\t      angular.forEach(parentTheme.colors, function(color, colorType) {\n\t        theme.colors[colorType] = {\n\t          name: color.name,\n\t          // Make sure a COPY of the hues is given to the child color,\n\t          // not the same reference.\n\t          hues: angular.extend({}, color.hues)\n\t        };\n\t      });\n\t    }\n\t    THEMES[name] = theme;\n\t\n\t    return theme;\n\t  }\n\t\n\t  function Theme(name) {\n\t    var self = this;\n\t    self.name = name;\n\t    self.colors = {};\n\t\n\t    self.dark = setDark;\n\t    setDark(false);\n\t\n\t    function setDark(isDark) {\n\t      isDark = arguments.length === 0 ? true : !!isDark;\n\t\n\t      // If no change, abort\n\t      if (isDark === self.isDark) return;\n\t\n\t      self.isDark = isDark;\n\t\n\t      self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;\n\t      self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;\n\t\n\t      // Light and dark themes have different default hues.\n\t      // Go through each existing color type for this theme, and for every\n\t      // hue value that is still the default hue value from the previous light/dark setting,\n\t      // set it to the default hue value from the new light/dark setting.\n\t      var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;\n\t      var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;\n\t      angular.forEach(newDefaultHues, function(newDefaults, colorType) {\n\t        var color = self.colors[colorType];\n\t        var oldDefaults = oldDefaultHues[colorType];\n\t        if (color) {\n\t          for (var hueName in color.hues) {\n\t            if (color.hues[hueName] === oldDefaults[hueName]) {\n\t              color.hues[hueName] = newDefaults[hueName];\n\t            }\n\t          }\n\t        }\n\t      });\n\t\n\t      return self;\n\t    }\n\t\n\t    THEME_COLOR_TYPES.forEach(function(colorType) {\n\t      var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];\n\t      self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {\n\t        var color = self.colors[colorType] = {\n\t          name: paletteName,\n\t          hues: angular.extend({}, defaultHues, hues)\n\t        };\n\t\n\t        Object.keys(color.hues).forEach(function(name) {\n\t          if (!defaultHues[name]) {\n\t            throw new Error(\"Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4\"\n\t              .replace('%1', name)\n\t              .replace('%2', self.name)\n\t              .replace('%3', paletteName)\n\t              .replace('%4', Object.keys(defaultHues).join(', '))\n\t            );\n\t          }\n\t        });\n\t        Object.keys(color.hues).map(function(key) {\n\t          return color.hues[key];\n\t        }).forEach(function(hueValue) {\n\t          if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {\n\t            throw new Error(\"Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5\"\n\t              .replace('%1', hueValue)\n\t              .replace('%2', self.name)\n\t              .replace('%3', colorType)\n\t              .replace('%4', paletteName)\n\t              .replace('%5', VALID_HUE_VALUES.join(', '))\n\t            );\n\t          }\n\t        });\n\t        return self;\n\t      };\n\t\n\t      self[colorType + 'Color'] = function() {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' +\n\t                     'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');\n\t        return self[colorType + 'Palette'].apply(self, args);\n\t      };\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc service\n\t   * @name $mdTheming\n\t   *\n\t   * @description\n\t   *\n\t   * Service that makes an element apply theming related classes to itself.\n\t   *\n\t   * ```js\n\t   * app.directive('myFancyDirective', function($mdTheming) {\n\t   *   return {\n\t   *     restrict: 'e',\n\t   *     link: function(scope, el, attrs) {\n\t   *       $mdTheming(el);\n\t   *     }\n\t   *   };\n\t   * });\n\t   * ```\n\t   * @param {el=} element to apply theming to\n\t   */\n\t  /* @ngInject */\n\t  function ThemingService($rootScope, $log) {\n\t\n\t    applyTheme.inherit = function(el, parent) {\n\t      var ctrl = parent.controller('mdTheme');\n\t\n\t      var attrThemeValue = el.attr('md-theme-watch');\n\t      if ( (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {\n\t        var deregisterWatch = $rootScope.$watch(function() {\n\t          return ctrl && ctrl.$mdTheme || defaultTheme;\n\t        }, changeTheme);\n\t        el.on('$destroy', deregisterWatch);\n\t      } else {\n\t        var theme = ctrl && ctrl.$mdTheme || defaultTheme;\n\t        changeTheme(theme);\n\t      }\n\t\n\t      function changeTheme(theme) {\n\t        if (!registered(theme)) {\n\t          $log.warn('Attempted to use unregistered theme \\'' + theme + '\\'. ' +\n\t                    'Register it with $mdThemingProvider.theme().');\n\t        }\n\t        var oldTheme = el.data('$mdThemeName');\n\t        if (oldTheme) el.removeClass('md-' + oldTheme +'-theme');\n\t        el.addClass('md-' + theme + '-theme');\n\t        el.data('$mdThemeName', theme);\n\t      }\n\t    };\n\t\n\t    applyTheme.THEMES = angular.extend({}, THEMES);\n\t    applyTheme.defaultTheme = function() { return defaultTheme; };\n\t    applyTheme.registered = registered;\n\t\n\t    return applyTheme;\n\t\n\t    function registered(themeName) {\n\t      if (themeName === undefined || themeName === '') return true;\n\t      return applyTheme.THEMES[themeName] !== undefined;\n\t    }\n\t\n\t    function applyTheme(scope, el) {\n\t      // Allow us to be invoked via a linking function signature.\n\t      if (el === undefined) {\n\t        el = scope;\n\t        scope = undefined;\n\t      }\n\t      if (scope === undefined) {\n\t        scope = $rootScope;\n\t      }\n\t      applyTheme.inherit(el, el);\n\t    }\n\t  }\n\t}\n\tThemingProvider.$inject = [\"$mdColorPalette\"];\n\t\n\tfunction ThemingDirective($mdTheming, $interpolate, $log) {\n\t  return {\n\t    priority: 100,\n\t    link: {\n\t      pre: function(scope, el, attrs) {\n\t        var ctrl = {\n\t          $setTheme: function(theme) {\n\t            if (!$mdTheming.registered(theme)) {\n\t              $log.warn('attempted to use unregistered theme \\'' + theme + '\\'');\n\t            }\n\t            ctrl.$mdTheme = theme;\n\t          }\n\t        };\n\t        el.data('$mdThemeController', ctrl);\n\t        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));\n\t        attrs.$observe('mdTheme', ctrl.$setTheme);\n\t      }\n\t    }\n\t  };\n\t}\n\tThemingDirective.$inject = [\"$mdTheming\", \"$interpolate\", \"$log\"];\n\t\n\tfunction ThemableDirective($mdTheming) {\n\t  return $mdTheming;\n\t}\n\tThemableDirective.$inject = [\"$mdTheming\"];\n\t\n\tfunction parseRules(theme, colorType, rules) {\n\t  checkValidPalette(theme, colorType);\n\t\n\t  rules = rules.replace(/THEME_NAME/g, theme.name);\n\t  var generatedRules = [];\n\t  var color = theme.colors[colorType];\n\t\n\t  var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');\n\t  // Matches '{{ primary-color }}', etc\n\t  var hueRegex = new RegExp('(\\'|\")?{{\\\\s*(' + colorType + ')-(color|contrast)-?(\\\\d\\\\.?\\\\d*)?\\\\s*}}(\\\"|\\')?','g');\n\t  var simpleVariableRegex = /'?\"?\\{\\{\\s*([a-zA-Z]+)-(A?\\d+|hue\\-[0-3]|shadow)-?(\\d\\.?\\d*)?\\s*\\}\\}'?\"?/g;\n\t  var palette = PALETTES[color.name];\n\t\n\t  // find and replace simple variables where we use a specific hue, not an entire palette\n\t  // eg. \"{{primary-100}}\"\n\t  //\\(' + THEME_COLOR_TYPES.join('\\|') + '\\)'\n\t  rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity) {\n\t    if (colorType === 'foreground') {\n\t      if (hue == 'shadow') {\n\t        return theme.foregroundShadow;\n\t      } else {\n\t        return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];\n\t      }\n\t    }\n\t    if (hue.indexOf('hue') === 0) {\n\t      hue = theme.colors[colorType].hues[hue];\n\t    }\n\t    return rgba( (PALETTES[ theme.colors[colorType].name ][hue] || '').value, opacity );\n\t  });\n\t\n\t  // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)\n\t  angular.forEach(color.hues, function(hueValue, hueName) {\n\t    var newRule = rules\n\t      .replace(hueRegex, function(match, _, colorType, hueType, opacity) {\n\t        return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);\n\t      });\n\t    if (hueName !== 'default') {\n\t      newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);\n\t    }\n\t\n\t    // Don't apply a selector rule to the default theme, making it easier to override\n\t    // styles of the base-component\n\t    if (theme.name == 'default') {\n\t      newRule = newRule.replace(/\\.md-default-theme/g, '');\n\t    }\n\t    generatedRules.push(newRule);\n\t  });\n\t\n\t  return generatedRules;\n\t}\n\t\n\t// Generate our themes at run time given the state of THEMES and PALETTES\n\tfunction generateThemes($injector) {\n\t\n\t  var head = document.getElementsByTagName('head')[0];\n\t  var firstChild = head ? head.firstElementChild : null;\n\t  var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';\n\t\n\t  if ( !firstChild ) return;\n\t  if (themeCss.length === 0) return; // no rules, so no point in running this expensive task\n\t\n\t  // Expose contrast colors for palettes to ensure that text is always readable\n\t  angular.forEach(PALETTES, sanitizePalette);\n\t\n\t  // MD_THEME_CSS is a string generated by the build process that includes all the themable\n\t  // components as templates\n\t\n\t  // Break the CSS into individual rules\n\t  var rulesByType = {};\n\t  var rules = themeCss\n\t                  .split(/\\}(?!(\\}|'|\"|;))/)\n\t                  .filter(function(rule) { return rule && rule.length; })\n\t                  .map(function(rule) { return rule.trim() + '}'; });\n\t\n\t\n\t  var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');\n\t\n\t  THEME_COLOR_TYPES.forEach(function(type) {\n\t    rulesByType[type] = '';\n\t  });\n\t\n\t\n\t  // Sort the rules based on type, allowing us to do color substitution on a per-type basis\n\t  rules.forEach(function(rule) {\n\t    var match = rule.match(ruleMatchRegex);\n\t    // First: test that if the rule has '.md-accent', it goes into the accent set of rules\n\t    for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {\n\t      if (rule.indexOf('.md-' + type) > -1) {\n\t        return rulesByType[type] += rule;\n\t      }\n\t    }\n\t\n\t    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from\n\t    // there\n\t    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {\n\t      if (rule.indexOf(type) > -1) {\n\t        return rulesByType[type] += rule;\n\t      }\n\t    }\n\t\n\t    // Default to the primary array\n\t    return rulesByType[DEFAULT_COLOR_TYPE] += rule;\n\t  });\n\t\n\t    // For each theme, use the color palettes specified for\n\t    // `primary`, `warn` and `accent` to generate CSS rules.\n\t\n\t    angular.forEach(THEMES, function(theme) {\n\t      if ( !GENERATED[theme.name] ) {\n\t\n\t\n\t        THEME_COLOR_TYPES.forEach(function(colorType) {\n\t          var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);\n\t          while (styleStrings.length) {\n\t            var style = document.createElement('style');\n\t                style.setAttribute('type', 'text/css');\n\t            style.appendChild(document.createTextNode(styleStrings.shift()));\n\t            head.insertBefore(style, firstChild);\n\t          }\n\t        });\n\t\n\t\n\t        if (theme.colors.primary.name == theme.colors.accent.name) {\n\t          console.warn(\"$mdThemingProvider: Using the same palette for primary and\" +\n\t                       \" accent. This violates the material design spec.\");\n\t        }\n\t\n\t        GENERATED[theme.name] = true;\n\t      }\n\t    });\n\t\n\t\n\t  // *************************\n\t  // Internal functions\n\t  // *************************\n\t\n\t  // The user specifies a 'default' contrast color as either light or dark,\n\t  // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)\n\t  function sanitizePalette(palette) {\n\t    var defaultContrast = palette.contrastDefaultColor;\n\t    var lightColors = palette.contrastLightColors || [];\n\t    var strongLightColors = palette.contrastStrongLightColors || [];\n\t    var darkColors = palette.contrastDarkColors || [];\n\t\n\t    // These colors are provided as space-separated lists\n\t    if (typeof lightColors === 'string') lightColors = lightColors.split(' ');\n\t    if (typeof strongLightColors === 'string') strongLightColors = strongLightColors.split(' ');\n\t    if (typeof darkColors === 'string') darkColors = darkColors.split(' ');\n\t\n\t    // Cleanup after ourselves\n\t    delete palette.contrastDefaultColor;\n\t    delete palette.contrastLightColors;\n\t    delete palette.contrastStrongLightColors;\n\t    delete palette.contrastDarkColors;\n\t\n\t    // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }\n\t    angular.forEach(palette, function(hueValue, hueName) {\n\t      if (angular.isObject(hueValue)) return; // Already converted\n\t      // Map everything to rgb colors\n\t      var rgbValue = colorToRgbaArray(hueValue);\n\t      if (!rgbValue) {\n\t        throw new Error(\"Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.\"\n\t                        .replace('%1', hueValue)\n\t                        .replace('%2', palette.name)\n\t                        .replace('%3', hueName));\n\t      }\n\t\n\t      palette[hueName] = {\n\t        value: rgbValue,\n\t        contrast: getContrastColor()\n\t      };\n\t      function getContrastColor() {\n\t        if (defaultContrast === 'light') {\n\t          if (darkColors.indexOf(hueName) > -1) {\n\t            return DARK_CONTRAST_COLOR;\n\t          } else {\n\t            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n\t              : LIGHT_CONTRAST_COLOR;\n\t          }\n\t        } else {\n\t          if (lightColors.indexOf(hueName) > -1) {\n\t            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n\t              : LIGHT_CONTRAST_COLOR;\n\t          } else {\n\t            return DARK_CONTRAST_COLOR;\n\t          }\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t\n\t}\n\tgenerateThemes.$inject = [\"$injector\"];\n\t\n\tfunction checkValidPalette(theme, colorType) {\n\t  // If theme attempts to use a palette that doesnt exist, throw error\n\t  if (!PALETTES[ (theme.colors[colorType] || {}).name ]) {\n\t    throw new Error(\n\t      \"You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3\"\n\t                    .replace('%1', theme.name)\n\t                    .replace('%2', colorType)\n\t                    .replace('%3', Object.keys(PALETTES).join(', '))\n\t    );\n\t  }\n\t}\n\t\n\tfunction colorToRgbaArray(clr) {\n\t  if (angular.isArray(clr) && clr.length == 3) return clr;\n\t  if (/^rgb/.test(clr)) {\n\t    return clr.replace(/(^\\s*rgba?\\(|\\)\\s*$)/g, '').split(',').map(function(value, i) {\n\t      return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);\n\t    });\n\t  }\n\t  if (clr.charAt(0) == '#') clr = clr.substring(1);\n\t  if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;\n\t\n\t  var dig = clr.length / 3;\n\t  var red = clr.substr(0, dig);\n\t  var grn = clr.substr(dig, dig);\n\t  var blu = clr.substr(dig * 2);\n\t  if (dig === 1) {\n\t    red += red;\n\t    grn += grn;\n\t    blu += blu;\n\t  }\n\t  return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];\n\t}\n\t\n\tfunction rgba(rgbArray, opacity) {\n\t  if ( !rgbArray ) return \"rgb('0,0,0')\";\n\t\n\t  if (rgbArray.length == 4) {\n\t    rgbArray = angular.copy(rgbArray);\n\t    opacity ? rgbArray.pop() : opacity = rgbArray.pop();\n\t  }\n\t  return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ?\n\t    'rgba(' + rgbArray.join(',') + ',' + opacity + ')' :\n\t    'rgb(' + rgbArray.join(',') + ')';\n\t}\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.autocomplete\n\t */\n\t/*\n\t * @see js folder for autocomplete implementation\n\t */\n\tangular.module('material.components.autocomplete', [\n\t  'material.core',\n\t  'material.components.icon'\n\t]);\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/*\n\t * @ngdoc module\n\t * @name material.components.backdrop\n\t * @description Backdrop\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdBackdrop\n\t * @module material.components.backdrop\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.\n\t * Apply class `opaque` to make the backdrop use the theme backdrop color.\n\t *\n\t */\n\t\n\tangular.module('material.components.backdrop', [\n\t  'material.core'\n\t])\n\t  .directive('mdBackdrop', BackdropDirective);\n\t\n\tfunction BackdropDirective($mdTheming) {\n\t  return $mdTheming;\n\t}\n\tBackdropDirective.$inject = [\"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.bottomSheet\n\t * @description\n\t * BottomSheet\n\t */\n\tangular.module('material.components.bottomSheet', [\n\t  'material.core',\n\t  'material.components.backdrop'\n\t])\n\t  .directive('mdBottomSheet', MdBottomSheetDirective)\n\t  .provider('$mdBottomSheet', MdBottomSheetProvider);\n\t\n\tfunction MdBottomSheetDirective() {\n\t  return {\n\t    restrict: 'E'\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $mdBottomSheet\n\t * @module material.components.bottomSheet\n\t *\n\t * @description\n\t * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.\n\t *\n\t * ## Restrictions\n\t *\n\t * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.\n\t * - Add the `md-grid` class to the bottom sheet for a grid layout.\n\t * - Add the `md-list` class to the bottom sheet for a list layout.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div ng-controller=\"MyController\">\n\t *   <md-button ng-click=\"openBottomSheet()\">\n\t *     Open a Bottom Sheet!\n\t *   </md-button>\n\t * </div>\n\t * </hljs>\n\t * <hljs lang=\"js\">\n\t * var app = angular.module('app', ['ngMaterial']);\n\t * app.controller('MyController', function($scope, $mdBottomSheet) {\n\t *   $scope.openBottomSheet = function() {\n\t *     $mdBottomSheet.show({\n\t *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'\n\t *     });\n\t *   };\n\t * });\n\t * </hljs>\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdBottomSheet#show\n\t *\n\t * @description\n\t * Show a bottom sheet with the specified options.\n\t *\n\t * @param {object} options An options object, with the following properties:\n\t *\n\t *   - `templateUrl` - `{string=}`: The url of an html template file that will\n\t *   be used as the content of the bottom sheet. Restrictions: the template must\n\t *   have an outer `md-bottom-sheet` element.\n\t *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n\t *   template string.\n\t *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n\t *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.\n\t *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n\t *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.\n\t *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n\t *   be used as names of values to inject into the controller. For example,\n\t *   `locals: {three: 3}` would inject `three` into the controller with the value\n\t *   of 3.\n\t *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n\t *   the location of the click will be used as the starting point for the opening animation\n\t *   of the the dialog.\n\t *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n\t *   and the bottom sheet will not open until the promises resolve.\n\t *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n\t *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,\n\t *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.\n\t *   e.g. angular.element(document.getElementById('content')) or \"#content\"\n\t *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.\n\t *     Default true.\n\t *\n\t * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or\n\t * rejected with `$mdBottomSheet.cancel()`.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdBottomSheet#hide\n\t *\n\t * @description\n\t * Hide the existing bottom sheet and resolve the promise returned from\n\t * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if any).\n\t *\n\t * @param {*=} response An argument for the resolved promise.\n\t *\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdBottomSheet#cancel\n\t *\n\t * @description\n\t * Hide the existing bottom sheet and reject the promise returned from\n\t * `$mdBottomSheet.show()`.\n\t *\n\t * @param {*=} response An argument for the rejected promise.\n\t *\n\t */\n\t\n\tfunction MdBottomSheetProvider($$interimElementProvider) {\n\t  // how fast we need to flick down to close the sheet, pixels/ms\n\t  var CLOSING_VELOCITY = 0.5;\n\t  var PADDING = 80; // same as css\n\t\n\t  bottomSheetDefaults.$inject = [\"$animate\", \"$mdConstant\", \"$mdUtil\", \"$timeout\", \"$compile\", \"$mdTheming\", \"$mdBottomSheet\", \"$rootElement\", \"$mdGesture\"];\n\t  return $$interimElementProvider('$mdBottomSheet')\n\t    .setDefaults({\n\t      methods: ['disableParentScroll', 'escapeToClose', 'targetEvent'],\n\t      options: bottomSheetDefaults\n\t    });\n\t\n\t  /* @ngInject */\n\t  function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $timeout, $compile, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {\n\t    var backdrop;\n\t\n\t    return {\n\t      themable: true,\n\t      targetEvent: null,\n\t      onShow: onShow,\n\t      onRemove: onRemove,\n\t      escapeToClose: true,\n\t      disableParentScroll: true\n\t    };\n\t\n\t\n\t    function onShow(scope, element, options) {\n\t\n\t      element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');\n\t\n\t      // Add a backdrop that will close on click\n\t      backdrop = $compile('<md-backdrop class=\"md-opaque md-bottom-sheet-backdrop\">')(scope);\n\t      backdrop.on('click', function() {\n\t        $timeout($mdBottomSheet.cancel);\n\t      });\n\t      $mdTheming.inherit(backdrop, options.parent);\n\t\n\t      $animate.enter(backdrop, options.parent, null);\n\t\n\t      var bottomSheet = new BottomSheet(element, options.parent);\n\t      options.bottomSheet = bottomSheet;\n\t\n\t      // Give up focus on calling item\n\t      options.targetEvent && angular.element(options.targetEvent.target).blur();\n\t      $mdTheming.inherit(bottomSheet.element, options.parent);\n\t\n\t      if (options.disableParentScroll) {\n\t        options.lastOverflow = options.parent.css('overflow');\n\t        options.parent.css('overflow', 'hidden');\n\t      }\n\t\n\t      return $animate.enter(bottomSheet.element, options.parent)\n\t        .then(function() {\n\t          var focusable = angular.element(\n\t            element[0].querySelector('button') ||\n\t            element[0].querySelector('a') ||\n\t            element[0].querySelector('[ng-click]')\n\t          );\n\t          focusable.focus();\n\t\n\t          if (options.escapeToClose) {\n\t            options.rootElementKeyupCallback = function(e) {\n\t              if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n\t                $timeout($mdBottomSheet.cancel);\n\t              }\n\t            };\n\t            $rootElement.on('keyup', options.rootElementKeyupCallback);\n\t          }\n\t        });\n\t\n\t    }\n\t\n\t    function onRemove(scope, element, options) {\n\t\n\t      var bottomSheet = options.bottomSheet;\n\t\n\t      $animate.leave(backdrop);\n\t      return $animate.leave(bottomSheet.element).then(function() {\n\t        if (options.disableParentScroll) {\n\t          options.parent.css('overflow', options.lastOverflow);\n\t          delete options.lastOverflow;\n\t        }\n\t\n\t        bottomSheet.cleanup();\n\t\n\t        // Restore focus\n\t        options.targetEvent && angular.element(options.targetEvent.target).focus();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * BottomSheet class to apply bottom-sheet behavior to an element\n\t     */\n\t    function BottomSheet(element, parent) {\n\t      var deregister = $mdGesture.register(parent, 'drag', { horizontal: false });\n\t      parent.on('$md.dragstart', onDragStart)\n\t        .on('$md.drag', onDrag)\n\t        .on('$md.dragend', onDragEnd);\n\t\n\t      return {\n\t        element: element,\n\t        cleanup: function cleanup() {\n\t          deregister();\n\t          parent.off('$md.dragstart', onDragStart)\n\t            .off('$md.drag', onDrag)\n\t            .off('$md.dragend', onDragEnd);\n\t        }\n\t      };\n\t\n\t      function onDragStart(ev) {\n\t        // Disable transitions on transform so that it feels fast\n\t        element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');\n\t      }\n\t\n\t      function onDrag(ev) {\n\t        var transform = ev.pointer.distanceY;\n\t        if (transform < 5) {\n\t          // Slow down drag when trying to drag up, and stop after PADDING\n\t          transform = Math.max(-PADDING, transform / 2);\n\t        }\n\t        element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');\n\t      }\n\t\n\t      function onDragEnd(ev) {\n\t        if (ev.pointer.distanceY > 0 &&\n\t            (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {\n\t          var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;\n\t          var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);\n\t          element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');\n\t          $timeout($mdBottomSheet.cancel);\n\t        } else {\n\t          element.css($mdConstant.CSS.TRANSITION_DURATION, '');\n\t          element.css($mdConstant.CSS.TRANSFORM, '');\n\t        }\n\t      }\n\t    }\n\t\n\t  }\n\t\n\t}\n\tMdBottomSheetProvider.$inject = [\"$$interimElementProvider\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.button\n\t * @description\n\t *\n\t * Button\n\t */\n\tangular\n\t    .module('material.components.button', [ 'material.core' ])\n\t    .directive('mdButton', MdButtonDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdButton\n\t * @module material.components.button\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * `<md-button>` is a button directive with optional ink ripples (default enabled).\n\t *\n\t * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will\n\t * become a `<button>` element. As per the [Material Design specifications](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n\t * the FAB button background is filled with the accent color [by default]. The primary color palette may be used with\n\t * the `md-primary` class.\n\t *\n\t * @param {boolean=} md-no-ink If present, disable ripple ink effects.\n\t * @param {expression=} ng-disabled En/Disable based on the expression\n\t * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`\n\t * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.\n\t * If no default text is found, a warning will be logged.\n\t *\n\t * @usage\n\t *\n\t * Regular buttons:\n\t *\n\t * <hljs lang=\"html\">\n\t *  <md-button> Flat Button </md-button>\n\t *  <md-button href=\"http://google.com\"> Flat link </md-button>\n\t *  <md-button class=\"md-raised\"> Raised Button </md-button>\n\t *  <md-button ng-disabled=\"true\"> Disabled Button </md-button>\n\t *  <md-button>\n\t *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n\t *    Register Now\n\t *  </md-button>\n\t * </hljs>\n\t *\n\t * FAB buttons:\n\t *\n\t * <hljs lang=\"html\">\n\t *  <md-button class=\"md-fab\" aria-label=\"FAB\">\n\t *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n\t *  </md-button>\n\t *  <!-- mini-FAB -->\n\t *  <md-button class=\"md-fab md-mini\" aria-label=\"Mini FAB\">\n\t *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n\t *  </md-button>\n\t *  <!-- Button with SVG Icon -->\n\t *  <md-button class=\"md-icon-button\" aria-label=\"Custom Icon Button\">\n\t *    <md-icon md-svg-icon=\"path/to/your.svg\"></md-icon>\n\t *  </md-button>\n\t * </hljs>\n\t */\n\tfunction MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {\n\t\n\t  return {\n\t    restrict: 'EA',\n\t    replace: true,\n\t    transclude: true,\n\t    template: getTemplate,\n\t    link: postLink\n\t  };\n\t\n\t  function isAnchor(attr) {\n\t    return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);\n\t  }\n\t\n\t  function getTemplate(element, attr) {\n\t    return isAnchor(attr) ?\n\t           '<a class=\"md-button\" ng-transclude></a>' :\n\t           '<button class=\"md-button\" ng-transclude></button>';\n\t  }\n\t\n\t  function postLink(scope, element, attr) {\n\t    var node = element[0];\n\t    $mdTheming(element);\n\t    $mdButtonInkRipple.attach(scope, element);\n\t\n\t    var elementHasText = node.textContent.trim();\n\t    if (!elementHasText) {\n\t      $mdAria.expect(element, 'aria-label');\n\t    }\n\t\n\t    // For anchor elements, we have to set tabindex manually when the\n\t    // element is disabled\n\t    if (isAnchor(attr) && angular.isDefined(attr.ngDisabled) ) {\n\t      scope.$watch(attr.ngDisabled, function(isDisabled) {\n\t        element.attr('tabindex', isDisabled ? -1 : 0);\n\t      });\n\t    }\n\t\n\t    // disabling click event when disabled is true\n\t    element.on('click', function(e){\n\t      if (attr.disabled === true) {\n\t        e.preventDefault();\n\t        e.stopImmediatePropagation();\n\t      }\n\t    });\n\t\n\t    // restrict focus styles to the keyboard\n\t    scope.mouseActive = false;\n\t    element.on('mousedown', function() {\n\t        scope.mouseActive = true;\n\t        $timeout(function(){\n\t          scope.mouseActive = false;\n\t        }, 100);\n\t      })\n\t      .on('focus', function() {\n\t        if(scope.mouseActive === false) { element.addClass('md-focused'); }\n\t      })\n\t      .on('blur', function() { element.removeClass('md-focused'); });\n\t  }\n\t\n\t}\n\tMdButtonDirective.$inject = [\"$mdButtonInkRipple\", \"$mdTheming\", \"$mdAria\", \"$timeout\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.card\n\t *\n\t * @description\n\t * Card components.\n\t */\n\tangular.module('material.components.card', [\n\t  'material.core'\n\t])\n\t  .directive('mdCard', mdCardDirective);\n\t\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdCard\n\t * @module material.components.card\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-card>` directive is a container element used within `<md-content>` containers.\n\t *\n\t * An image included as a direct descendant will fill the card's width, while the `<md-card-content>`\n\t * container will wrap text content and provide padding. An `<md-card-footer>` element can be\n\t * optionally included to put content flush against the bottom edge of the card.\n\t *\n\t * Action buttons can be included in an element with the `.md-actions` class, also used in `md-dialog`.\n\t * You can then position buttons using layout attributes.\n\t *\n\t * Cards have constant width and variable heights; where the maximum height is limited to what can\n\t * fit within a single view on a platform, but it can temporarily expand as needed.\n\t *\n\t * @usage\n\t * ###Card with optional footer\n\t * <hljs lang=\"html\">\n\t * <md-card>\n\t *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n\t *  <md-card-content>\n\t *    <h2>Card headline</h2>\n\t *    <p>Card content</p>\n\t *  </md-card-content>\n\t *  <md-card-footer>\n\t *    Card footer\n\t *  </md-card-footer>\n\t * </md-card>\n\t * </hljs>\n\t *\n\t * ###Card with actions\n\t * <hljs lang=\"html\">\n\t * <md-card>\n\t *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n\t *  <md-card-content>\n\t *    <h2>Card headline</h2>\n\t *    <p>Card content</p>\n\t *  </md-card-content>\n\t *  <div class=\"md-actions\" layout=\"row\" layout-align=\"end center\">\n\t *    <md-button>Action 1</md-button>\n\t *    <md-button>Action 2</md-button>\n\t *  </div>\n\t * </md-card>\n\t * </hljs>\n\t *\n\t */\n\tfunction mdCardDirective($mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    link: function($scope, $element, $attr) {\n\t      $mdTheming($element);\n\t    }\n\t  };\n\t}\n\tmdCardDirective.$inject = [\"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.checkbox\n\t * @description Checkbox module!\n\t */\n\tangular\n\t  .module('material.components.checkbox', ['material.core'])\n\t  .directive('mdCheckbox', MdCheckboxDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdCheckbox\n\t * @module material.components.checkbox\n\t * @restrict E\n\t *\n\t * @description\n\t * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n\t *\n\t * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n\t * the checkbox is in the accent color by default. The primary color palette may be used with\n\t * the `md-primary` class.\n\t *\n\t * @param {string} ng-model Assignable angular expression to data-bind to.\n\t * @param {string=} name Property name of the form under which the control is published.\n\t * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n\t * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n\t * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n\t * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects\n\t * @param {string=} aria-label Adds label to checkbox for accessibility.\n\t * Defaults to checkbox's text. If no default text is found, a warning will be logged.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-checkbox ng-model=\"isChecked\" aria-label=\"Finished?\">\n\t *   Finished ?\n\t * </md-checkbox>\n\t *\n\t * <md-checkbox md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n\t *   No Ink Effects\n\t * </md-checkbox>\n\t *\n\t * <md-checkbox ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n\t *   Disabled\n\t * </md-checkbox>\n\t *\n\t * </hljs>\n\t *\n\t */\n\tfunction MdCheckboxDirective(inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {\n\t  inputDirective = inputDirective[0];\n\t  var CHECKED_CSS = 'md-checked';\n\t\n\t  return {\n\t    restrict: 'E',\n\t    transclude: true,\n\t    require: '?ngModel',\n\t    priority:210, // Run before ngAria\n\t    template: \n\t      '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n\t        '<div class=\"md-icon\"></div>' +\n\t      '</div>' +\n\t      '<div ng-transclude class=\"md-label\"></div>',\n\t    compile: compile\n\t  };\n\t\n\t  // **********************************************************\n\t  // Private Methods\n\t  // **********************************************************\n\t\n\t  function compile (tElement, tAttrs) {\n\t\n\t    tAttrs.type = 'checkbox';\n\t    tAttrs.tabindex = tAttrs.tabindex || '0';\n\t    tElement.attr('role', tAttrs.type);\n\t\n\t    return function postLink(scope, element, attr, ngModelCtrl) {\n\t      ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();\n\t      $mdTheming(element);\n\t\n\t      if (attr.ngChecked) {\n\t        scope.$watch(\n\t            scope.$eval.bind(scope, attr.ngChecked),\n\t            ngModelCtrl.$setViewValue.bind(ngModelCtrl)\n\t        );\n\t      }\n\t      $$watchExpr('ngDisabled', 'tabindex', {\n\t        true: '-1',\n\t        false: attr.tabindex\n\t      });\n\t      $mdAria.expectWithText(element, 'aria-label');\n\t\n\t      // Reuse the original input[type=checkbox] directive from Angular core.\n\t      // This is a bit hacky as we need our own event listener and own render\n\t      // function.\n\t      inputDirective.link.pre(scope, {\n\t        on: angular.noop,\n\t        0: {}\n\t      }, attr, [ngModelCtrl]);\n\t\n\t      scope.mouseActive = false;\n\t      element.on('click', listener)\n\t        .on('keypress', keypressHandler)\n\t        .on('mousedown', function() {\n\t          scope.mouseActive = true;\n\t          $timeout(function(){\n\t            scope.mouseActive = false;\n\t          }, 100);\n\t        })\n\t        .on('focus', function() {\n\t          if(scope.mouseActive === false) { element.addClass('md-focused'); }\n\t        })\n\t        .on('blur', function() { element.removeClass('md-focused'); });\n\t\n\t      ngModelCtrl.$render = render;\n\t\n\t      function $$watchExpr(expr, htmlAttr, valueOpts) {\n\t        if (attr[expr]) {\n\t          scope.$watch(attr[expr], function(val) {\n\t            if (valueOpts[val]) {\n\t              element.attr(htmlAttr, valueOpts[val]);\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      function keypressHandler(ev) {\n\t        var keyCode = ev.which || ev.keyCode;\n\t        if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {\n\t          ev.preventDefault();\n\t          if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n\t          listener(ev);\n\t        }\n\t      }\n\t      function listener(ev) {\n\t        if (element[0].hasAttribute('disabled')) return;\n\t\n\t        scope.$apply(function() {\n\t          // Toggle the checkbox value...\n\t          var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;\n\t\n\t          ngModelCtrl.$setViewValue( viewValue, ev && ev.type);\n\t          ngModelCtrl.$render();\n\t        });\n\t      }\n\t\n\t      function render() {\n\t        if(ngModelCtrl.$viewValue) {\n\t          element.addClass(CHECKED_CSS);\n\t        } else {\n\t          element.removeClass(CHECKED_CSS);\n\t        }\n\t      }\n\t    };\n\t  }\n\t}\n\tMdCheckboxDirective.$inject = [\"inputDirective\", \"$mdInkRipple\", \"$mdAria\", \"$mdConstant\", \"$mdTheming\", \"$mdUtil\", \"$timeout\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.content\n\t *\n\t * @description\n\t * Scrollable content\n\t */\n\tangular.module('material.components.content', [\n\t  'material.core'\n\t])\n\t  .directive('mdContent', mdContentDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdContent\n\t * @module material.components.content\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-content>` directive is a container element useful for scrollable content\n\t *\n\t * @usage\n\t *\n\t * - Add the `[layout-padding]` attribute to make the content padded.\n\t *\n\t * <hljs lang=\"html\">\n\t *  <md-content layout-padding>\n\t *      Lorem ipsum dolor sit amet, ne quod novum mei.\n\t *  </md-content>\n\t * </hljs>\n\t *\n\t */\n\t\n\tfunction mdContentDirective($mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    controller: ['$scope', '$element', ContentController],\n\t    link: function(scope, element, attr) {\n\t      var node = element[0];\n\t\n\t      $mdTheming(element);\n\t      scope.$broadcast('$mdContentLoaded', element);\n\t\n\t      iosScrollFix(element[0]);\n\t    }\n\t  };\n\t\n\t  function ContentController($scope, $element) {\n\t    this.$scope = $scope;\n\t    this.$element = $element;\n\t  }\n\t}\n\tmdContentDirective.$inject = [\"$mdTheming\"];\n\t\n\tfunction iosScrollFix(node) {\n\t  // IOS FIX:\n\t  // If we scroll where there is no more room for the webview to scroll,\n\t  // by default the webview itself will scroll up and down, this looks really\n\t  // bad.  So if we are scrolling to the very top or bottom, add/subtract one\n\t  angular.element(node).on('$md.pressdown', function(ev) {\n\t    // Only touch events\n\t    if (ev.pointer.type !== 't') return;\n\t    // Don't let a child content's touchstart ruin it for us.\n\t    if (ev.$materialScrollFixed) return;\n\t    ev.$materialScrollFixed = true;\n\t\n\t    if (node.scrollTop === 0) {\n\t      node.scrollTop = 1;\n\t    } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {\n\t      node.scrollTop -= 1;\n\t    }\n\t  });\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.chips\n\t */\n\t/*\n\t * @see js folder for chips implementation\n\t */\n\tangular.module('material.components.chips', [\n\t  'material.core',\n\t  'material.components.autocomplete'\n\t]);\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.dialog\n\t */\n\tangular.module('material.components.dialog', [\n\t  'material.core',\n\t  'material.components.backdrop'\n\t])\n\t  .directive('mdDialog', MdDialogDirective)\n\t  .provider('$mdDialog', MdDialogProvider);\n\t\n\tfunction MdDialogDirective($$rAF, $mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    link: function(scope, element, attr) {\n\t      $mdTheming(element);\n\t      $$rAF(function() {\n\t        var content = element[0].querySelector('md-dialog-content');\n\t        if (content && content.scrollHeight > content.clientHeight) {\n\t          element.addClass('md-content-overflow');\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tMdDialogDirective.$inject = [\"$$rAF\", \"$mdTheming\"];\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $mdDialog\n\t * @module material.components.dialog\n\t *\n\t * @description\n\t * `$mdDialog` opens a dialog over the app to inform users about critical information or require\n\t *  them to make decisions. There are two approaches for setup: a simple promise API\n\t *  and regular object syntax.\n\t *\n\t * ## Restrictions\n\t *\n\t * - The dialog is always given an isolate scope.\n\t * - The dialog's template must have an outer `<md-dialog>` element.\n\t *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use\n\t *   an element with class `md-actions` for the dialog's actions.\n\t * - Dialogs must cover the entire application to keep interactions inside of them.\n\t * Use the `parent` option to change where dialogs are appended.\n\t *\n\t * ## Sizing\n\t * - Complex dialogs can be sized with `flex=\"percentage\"`, i.e. `flex=\"66\"`.\n\t * - Default max-width is 80% of the `rootElement` or `parent`.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div  ng-app=\"demoApp\" ng-controller=\"EmployeeController\">\n\t *   <div>\n\t *     <md-button ng-click=\"showAlert()\" class=\"md-raised md-warn\">\n\t *       Employee Alert!\n\t *       </md-button>\n\t *   </div>\n\t *   <div>\n\t *     <md-button ng-click=\"showDialog($event)\" class=\"md-raised\">\n\t *       Custom Dialog\n\t *       </md-button>\n\t *   </div>\n\t *   <div>\n\t *     <md-button ng-click=\"closeAlert()\" ng-disabled=\"!hasAlert()\" class=\"md-raised\">\n\t *       Close Alert\n\t *     </md-button>\n\t *   </div>\n\t *   <div>\n\t *     <md-button ng-click=\"showGreeting($event)\" class=\"md-raised md-primary\" >\n\t *       Greet Employee\n\t *       </md-button>\n\t *   </div>\n\t * </div>\n\t * </hljs>\n\t *\n\t * ### JavaScript: object syntax\n\t * <hljs lang=\"js\">\n\t * (function(angular, undefined){\n\t *   \"use strict\";\n\t *\n\t *   angular\n\t *    .module('demoApp', ['ngMaterial'])\n\t *    .controller('AppCtrl', AppController);\n\t *\n\t *   function AppController($scope, $mdDialog) {\n\t *     var alert;\n\t *     $scope.showAlert = showAlert;\n\t *     $scope.showDialog = showDialog;\n\t *     $scope.items = [1, 2, 3];\n\t *\n\t *     // Internal method\n\t *     function showAlert() {\n\t *       alert = $mdDialog.alert({\n\t *         title: 'Attention',\n\t *         content: 'This is an example of how easy dialogs can be!',\n\t *         ok: 'Close'\n\t *       });\n\t *\n\t *       $mdDialog\n\t *         .show( alert )\n\t *         .finally(function() {\n\t *           alert = undefined;\n\t *         });\n\t *     }\n\t *\n\t *     function showDialog($event) {\n\t *        var parentEl = angular.element(document.body);\n\t *        $mdDialog.show({\n\t *          parent: parentEl,\n\t *          targetEvent: $event,\n\t *          template:\n\t *            '<md-dialog aria-label=\"List dialog\">' +\n\t *            '  <md-dialog-content>'+\n\t *            '    <md-list>'+\n\t *            '      <md-list-item ng-repeat=\"item in items\">'+\n\t *            '       <p>Number {{item}}</p>' +\n\t *            '      </md-item>'+\n\t *            '    </md-list>'+\n\t *            '  </md-dialog-content>' +\n\t *            '  <div class=\"md-actions\">' +\n\t *            '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n\t *            '      Close Dialog' +\n\t *            '    </md-button>' +\n\t *            '  </div>' +\n\t *            '</md-dialog>',\n\t *          locals: {\n\t *            items: $scope.items\n\t *          },\n\t *          controller: DialogController\n\t *       });\n\t *       function DialogController($scope, $mdDialog, items) {\n\t *         $scope.items = items;\n\t *         $scope.closeDialog = function() {\n\t *           $mdDialog.hide();\n\t *         }\n\t *       }\n\t *     }\n\t *   }\n\t * })(angular);\n\t * </hljs>\n\t *\n\t * ### JavaScript: promise API syntax, custom dialog template\n\t * <hljs lang=\"js\">\n\t * (function(angular, undefined){\n\t *   \"use strict\";\n\t *\n\t *   angular\n\t *     .module('demoApp', ['ngMaterial'])\n\t *     .controller('EmployeeController', EmployeeEditor)\n\t *     .controller('GreetingController', GreetingController);\n\t *\n\t *   // Fictitious Employee Editor to show how to use simple and complex dialogs.\n\t *\n\t *   function EmployeeEditor($scope, $mdDialog) {\n\t *     var alert;\n\t *\n\t *     $scope.showAlert = showAlert;\n\t *     $scope.closeAlert = closeAlert;\n\t *     $scope.showGreeting = showCustomGreeting;\n\t *\n\t *     $scope.hasAlert = function() { return !!alert };\n\t *     $scope.userName = $scope.userName || 'Bobby';\n\t *\n\t *     // Dialog #1 - Show simple alert dialog and cache\n\t *     // reference to dialog instance\n\t *\n\t *     function showAlert() {\n\t *       alert = $mdDialog.alert()\n\t *         .title('Attention, ' + $scope.userName)\n\t *         .content('This is an example of how easy dialogs can be!')\n\t *         .ok('Close');\n\t *\n\t *       $mdDialog\n\t *           .show( alert )\n\t *           .finally(function() {\n\t *             alert = undefined;\n\t *           });\n\t *     }\n\t *\n\t *     // Close the specified dialog instance and resolve with 'finished' flag\n\t *     // Normally this is not needed, just use '$mdDialog.hide()' to close\n\t *     // the most recent dialog popup.\n\t *\n\t *     function closeAlert() {\n\t *       $mdDialog.hide( alert, \"finished\" );\n\t *       alert = undefined;\n\t *     }\n\t *\n\t *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.\n\t *\n\t *     function showCustomGreeting($event) {\n\t *         $mdDialog.show({\n\t *           targetEvent: $event,\n\t *           template:\n\t *             '<md-dialog>' +\n\t *\n\t *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +\n\t *\n\t *             '  <div class=\"md-actions\">' +\n\t *             '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n\t *             '      Close Greeting' +\n\t *             '    </md-button>' +\n\t *             '  </div>' +\n\t *             '</md-dialog>',\n\t *           controller: 'GreetingController',\n\t *           onComplete: afterShowAnimation,\n\t *           locals: { employee: $scope.userName }\n\t *         });\n\t *\n\t *         // When the 'enter' animation finishes...\n\t *\n\t *         function afterShowAnimation(scope, element, options) {\n\t *            // post-show code here: DOM element focus, etc.\n\t *         }\n\t *     }\n\t *\n\t *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog\n\t *     //             Here we used ng-controller=\"GreetingController as vm\" and\n\t *     //             $scope.vm === <controller instance>\n\t *\n\t *     function showCustomGreeting() {\n\t *\n\t *        $mdDialog.show({\n\t *           clickOutsideToClose: true,\n\t *\n\t *           scope: $scope,        // use parent scope in template\n\t *           preserveScope: true,  // do not forget this if use parent scope\n\t\n\t *           // Since GreetingController is instantiated with ControllerAs syntax\n\t *           // AND we are passing the parent '$scope' to the dialog, we MUST\n\t *           // use 'vm.<xxx>' in the template markup\n\t *\n\t *           template: '<md-dialog>' +\n\t *                     '  <md-dialog-content>' +\n\t *                     '     Hi There {{vm.employee}}' +\n\t *                     '  </md-dialog-content>' +\n\t *                     '</md-dialog>',\n\t *\n\t *           controller: function DialogController($scope, $mdDialog) {\n\t *             $scope.closeDialog = function() {\n\t *               $mdDialog.hide();\n\t *             }\n\t *           }\n\t *        });\n\t *     }\n\t *\n\t *   }\n\t *\n\t *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog\n\t *\n\t *   function GreetingController($scope, $mdDialog, employee) {\n\t *     // Assigned from construction <code>locals</code> options...\n\t *     $scope.employee = employee;\n\t *\n\t *     $scope.closeDialog = function() {\n\t *       // Easily hides most recent dialog shown...\n\t *       // no specific instance reference is needed.\n\t *       $mdDialog.hide();\n\t *     };\n\t *   }\n\t *\n\t * })(angular);\n\t * </hljs>\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdDialog#alert\n\t *\n\t * @description\n\t * Builds a preconfigured dialog with the specified message.\n\t *\n\t * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n\t *\n\t * - $mdDialogPreset#title(string) - sets title to string\n\t * - $mdDialogPreset#content(string) - sets content / message to string\n\t * - $mdDialogPreset#ok(string) - sets okay button text to string\n\t * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n\t *\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdDialog#confirm\n\t *\n\t * @description\n\t * Builds a preconfigured dialog with the specified message. You can call show and the promise returned\n\t * will be resolved only if the user clicks the confirm action on the dialog.\n\t *\n\t * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n\t *\n\t * Additionally, it supports the following methods:\n\t *\n\t * - $mdDialogPreset#title(string) - sets title to string\n\t * - $mdDialogPreset#content(string) - sets content / message to string\n\t * - $mdDialogPreset#ok(string) - sets okay button text to string\n\t * - $mdDialogPreset#cancel(string) - sets cancel button text to string\n\t * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n\t *\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdDialog#show\n\t *\n\t * @description\n\t * Show a dialog with the specified options.\n\t *\n\t * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and\n\t * `confirm()`, or an options object with the following properties:\n\t *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content\n\t *   of the dialog.\n\t *   - `template` - `{string=}`: Same as templateUrl, except this is an actual template string.\n\t *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n\t *     the location of the click will be used as the starting point for the opening animation\n\t *     of the the dialog.\n\t *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,\n\t *     it will create a new isolate scope.\n\t *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.\n\t *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n\t *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.\n\t *     Default true.\n\t *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.\n\t *     Default true.\n\t *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to\n\t *     close it. Default false.\n\t *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.\n\t *     Default true.\n\t *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if\n\t *     focusing some other way, as focus management is required for dialogs to be accessible.\n\t *     Defaults to true.\n\t *   - `controller` - `{string=}`: The controller to associate with the dialog. The controller\n\t *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.\n\t *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names\n\t *     of values to inject into the controller. For example, `locals: {three: 3}` would inject\n\t *     `three` into the controller, with the value 3. If `bindToController` is true, they will be\n\t *     copied to the controller instead.\n\t *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n\t *     These values will not be available until after initialization.\n\t *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the\n\t *     dialog will not open until all of the promises resolve.\n\t *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n\t *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending\n\t *     to the root element of the application.\n\t *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is\n\t *     finished.\n\t *\n\t * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or\n\t * rejected with `$mdDialog.cancel()`.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdDialog#hide\n\t *\n\t * @description\n\t * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.\n\t *\n\t * @param {*=} response An argument for the resolved promise.\n\t *\n\t * @returns {promise} A promise that is resolved when the dialog has been closed.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdDialog#cancel\n\t *\n\t * @description\n\t * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.\n\t *\n\t * @param {*=} response An argument for the rejected promise.\n\t *\n\t * @returns {promise} A promise that is resolved when the dialog has been closed.\n\t */\n\t\n\tfunction MdDialogProvider($$interimElementProvider) {\n\t\n\t  var alertDialogMethods = ['title', 'content', 'ariaLabel', 'ok'];\n\t\n\t  advancedDialogOptions.$inject = [\"$mdDialog\", \"$mdTheming\"];\n\t  dialogDefaultOptions.$inject = [\"$mdAria\", \"$document\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdDialog\", \"$timeout\", \"$rootElement\", \"$animate\", \"$$rAF\", \"$q\"];\n\t  return $$interimElementProvider('$mdDialog')\n\t    .setDefaults({\n\t      methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'parent'],\n\t      options: dialogDefaultOptions\n\t    })\n\t    .addPreset('alert', {\n\t      methods: ['title', 'content', 'ariaLabel', 'ok', 'theme'],\n\t      options: advancedDialogOptions\n\t    })\n\t    .addPreset('confirm', {\n\t      methods: ['title', 'content', 'ariaLabel', 'ok', 'cancel', 'theme'],\n\t      options: advancedDialogOptions\n\t    });\n\t\n\t  /* @ngInject */\n\t  function advancedDialogOptions($mdDialog, $mdTheming) {\n\t    return {\n\t      template: [\n\t        '<md-dialog md-theme=\"{{ dialog.theme }}\" aria-label=\"{{ dialog.ariaLabel }}\">',\n\t          '<md-dialog-content role=\"document\" tabIndex=\"-1\">',\n\t            '<h2 class=\"md-title\">{{ dialog.title }}</h2>',\n\t            '<p>{{ dialog.content }}</p>',\n\t          '</md-dialog-content>',\n\t          '<div class=\"md-actions\">',\n\t            '<md-button ng-if=\"dialog.$type == \\'confirm\\'\"' +\n\t                      ' ng-click=\"dialog.abort()\" class=\"md-primary\">',\n\t              '{{ dialog.cancel }}',\n\t            '</md-button>',\n\t            '<md-button ng-click=\"dialog.hide()\" class=\"md-primary\">',\n\t              '{{ dialog.ok }}',\n\t            '</md-button>',\n\t          '</div>',\n\t        '</md-dialog>'\n\t      ].join(''),\n\t      controller: function mdDialogCtrl() {\n\t        this.hide = function() {\n\t          $mdDialog.hide(true);\n\t        };\n\t        this.abort = function() {\n\t          $mdDialog.cancel();\n\t        };\n\t      },\n\t      controllerAs: 'dialog',\n\t      bindToController: true,\n\t      theme: $mdTheming.defaultTheme()\n\t    };\n\t  }\n\t\n\t  /* @ngInject */\n\t  function dialogDefaultOptions($mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $mdDialog, $timeout, $rootElement, $animate, $$rAF, $q) {\n\t    return {\n\t      hasBackdrop: true,\n\t      isolateScope: true,\n\t      onShow: onShow,\n\t      onRemove: onRemove,\n\t      clickOutsideToClose: false,\n\t      escapeToClose: true,\n\t      targetEvent: null,\n\t      focusOnOpen: true,\n\t      disableParentScroll: true,\n\t      transformTemplate: function(template) {\n\t        return '<div class=\"md-dialog-container\">' + template + '</div>';\n\t      }\n\t    };\n\t\n\t    function trapFocus(ev) {\n\t      var dialog = document.querySelector('md-dialog');\n\t\n\t      if (dialog && !dialog.contains(ev.target)) {\n\t        ev.stopImmediatePropagation();\n\t        dialog.focus();\n\t      }\n\t    }\n\t\n\t    // On show method for dialogs\n\t    function onShow(scope, element, options) {\n\t      angular.element($document[0].body).addClass('md-dialog-is-showing');\n\t      element = $mdUtil.extractElementByName(element, 'md-dialog');\n\t\n\t      // Incase the user provides a raw dom element, always wrap it in jqLite\n\t      options.parent = angular.element(options.parent);\n\t\n\t      options.popInTarget = angular.element((options.targetEvent || {}).target);\n\t      var closeButton = findCloseButton();\n\t\n\t      if (options.hasBackdrop) {\n\t        // Fix for IE 10\n\t        var computeFrom = (options.parent[0] == $document[0].body && $document[0].documentElement\n\t                           && $document[0].documentElement.scrollTop) ? angular.element($document[0].documentElement) : options.parent;\n\t        var parentOffset = computeFrom.prop('scrollTop');\n\t        options.backdrop = angular.element('<md-backdrop class=\"md-dialog-backdrop md-opaque\">');\n\t        options.backdrop.css('top', parentOffset +'px');\n\t        $mdTheming.inherit(options.backdrop, options.parent);\n\t        $animate.enter(options.backdrop, options.parent);\n\t        element.css('top', parentOffset +'px');\n\t      }\n\t\n\t      var role = 'dialog',\n\t          elementToFocus = closeButton;\n\t\n\t      if (options.$type === 'alert') {\n\t        role = 'alertdialog';\n\t        elementToFocus = element.find('md-dialog-content');\n\t      }\n\t\n\t      configureAria(element.find('md-dialog'), role, options);\n\t\n\t      document.addEventListener('focus', trapFocus, true);\n\t\n\t      if (options.disableParentScroll) {\n\t        options.lastOverflow = options.parent.css('overflow');\n\t        options.parent.css('overflow', 'hidden');\n\t      }\n\t\n\t      return dialogPopIn(\n\t        element,\n\t        options.parent,\n\t        options.popInTarget && options.popInTarget.length && options.popInTarget\n\t      )\n\t      .then(function() {\n\t\n\t        applyAriaToSiblings(element, true);\n\t\n\t        if (options.escapeToClose) {\n\t          options.rootElementKeyupCallback = function(e) {\n\t            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n\t              $timeout($mdDialog.cancel);\n\t            }\n\t          };\n\t          $rootElement.on('keyup', options.rootElementKeyupCallback);\n\t        }\n\t\n\t        if (options.clickOutsideToClose) {\n\t          options.dialogClickOutsideCallback = function(ev) {\n\t            // Only close if we click the flex container outside the backdrop\n\t            if (ev.target === element[0]) {\n\t              $timeout($mdDialog.cancel);\n\t            }\n\t          };\n\t          element.on('click', options.dialogClickOutsideCallback);\n\t        }\n\t\n\t        if (options.focusOnOpen) {\n\t          elementToFocus.focus();\n\t        }\n\t      });\n\t\n\t\n\t      function findCloseButton() {\n\t        //If no element with class dialog-close, try to find the last\n\t        //button child in md-actions and assume it is a close button\n\t        var closeButton = element[0].querySelector('.dialog-close');\n\t        if (!closeButton) {\n\t          var actionButtons = element[0].querySelectorAll('.md-actions button');\n\t          closeButton = actionButtons[ actionButtons.length - 1 ];\n\t        }\n\t        return angular.element(closeButton);\n\t      }\n\t\n\t    }\n\t\n\t    // On remove function for all dialogs\n\t    function onRemove(scope, element, options) {\n\t      angular.element($document[0].body).removeClass('md-dialog-is-showing');\n\t\n\t      if (options.backdrop) {\n\t        $animate.leave(options.backdrop);\n\t      }\n\t      if (options.disableParentScroll) {\n\t        options.parent.css('overflow', options.lastOverflow);\n\t        delete options.lastOverflow;\n\t      }\n\t      if (options.escapeToClose) {\n\t        $rootElement.off('keyup', options.rootElementKeyupCallback);\n\t      }\n\t      if (options.clickOutsideToClose) {\n\t        element.off('click', options.dialogClickOutsideCallback);\n\t      }\n\t\n\t      applyAriaToSiblings(element, false);\n\t\n\t      document.removeEventListener('focus', trapFocus, true);\n\t\n\t      return dialogPopOut(\n\t        element,\n\t        options.parent,\n\t        options.popInTarget && options.popInTarget.length && options.popInTarget\n\t      ).then(function() {\n\t        element.remove();\n\t        options.popInTarget && options.popInTarget.focus();\n\t      });\n\t\n\t    }\n\t\n\t    /**\n\t     * Inject ARIA-specific attributes appropriate for Dialogs\n\t     */\n\t    function configureAria(element, role, options) {\n\t\n\t      element.attr({\n\t        'role': role,\n\t        'tabIndex': '-1'\n\t      });\n\t\n\t      var dialogContent = element.find('md-dialog-content');\n\t      if (dialogContent.length === 0){\n\t        dialogContent = element;\n\t      }\n\t\n\t      var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());\n\t      dialogContent.attr('id', dialogId);\n\t      element.attr('aria-describedby', dialogId);\n\t\n\t      if (options.ariaLabel) {\n\t        $mdAria.expect(element, 'aria-label', options.ariaLabel);\n\t      }\n\t      else {\n\t        $mdAria.expectAsync(element, 'aria-label', function() {\n\t          var words = dialogContent.text().split(/\\s+/);\n\t          if (words.length > 3) words = words.slice(0,3).concat('...');\n\t          return words.join(' ');\n\t        });\n\t      }\n\t    }\n\t    /**\n\t     * Utility function to filter out raw DOM nodes\n\t     */\n\t    function isNodeOneOf(elem, nodeTypeArray) {\n\t      if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {\n\t        return true;\n\t      }\n\t    }\n\t    /**\n\t     * Walk DOM to apply or remove aria-hidden on sibling nodes\n\t     * and parent sibling nodes\n\t     *\n\t     * Prevents screen reader interaction behind modal window\n\t     * on swipe interfaces\n\t     */\n\t    function applyAriaToSiblings(element, value) {\n\t      var attribute = 'aria-hidden';\n\t\n\t      // get raw DOM node\n\t      element = element[0];\n\t\n\t      function walkDOM(element) {\n\t        while (element.parentNode) {\n\t          if (element === document.body) {\n\t            return;\n\t          }\n\t          var children = element.parentNode.children;\n\t          for (var i = 0; i < children.length; i++) {\n\t            // skip over child if it is an ascendant of the dialog\n\t            // or a script or style tag\n\t            if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {\n\t              children[i].setAttribute(attribute, value);\n\t            }\n\t          }\n\t\n\t          walkDOM(element = element.parentNode);\n\t        }\n\t      }\n\t      walkDOM(element);\n\t    }\n\t\n\t    function dialogPopIn(container, parentElement, clickElement) {\n\t      var dialogEl = container.find('md-dialog');\n\t\n\t      parentElement.append(container);\n\t      transformToClickElement(dialogEl, clickElement);\n\t\n\t      $$rAF(function() {\n\t        dialogEl.addClass('transition-in')\n\t          .css($mdConstant.CSS.TRANSFORM, '');\n\t      });\n\t\n\t      return $mdUtil.transitionEndPromise(dialogEl);\n\t    }\n\t\n\t    function dialogPopOut(container, parentElement, clickElement) {\n\t      var dialogEl = container.find('md-dialog');\n\t\n\t      dialogEl.addClass('transition-out').removeClass('transition-in');\n\t      transformToClickElement(dialogEl, clickElement);\n\t\n\t      return $mdUtil.transitionEndPromise(dialogEl);\n\t    }\n\t\n\t    function transformToClickElement(dialogEl, clickElement) {\n\t      if (clickElement) {\n\t        var clickRect = clickElement[0].getBoundingClientRect();\n\t        var dialogRect = dialogEl[0].getBoundingClientRect();\n\t\n\t        var scaleX = Math.min(0.5, clickRect.width / dialogRect.width);\n\t        var scaleY = Math.min(0.5, clickRect.height / dialogRect.height);\n\t\n\t        dialogEl.css($mdConstant.CSS.TRANSFORM, 'translate3d(' +\n\t          (-dialogRect.left + clickRect.left + clickRect.width/2 - dialogRect.width/2) + 'px,' +\n\t          (-dialogRect.top + clickRect.top + clickRect.height/2 - dialogRect.height/2) + 'px,' +\n\t          '0) scale(' + scaleX + ',' + scaleY + ')'\n\t        );\n\t      }\n\t    }\n\t\n\t    function dialogTransitionEnd(dialogEl) {\n\t      var deferred = $q.defer();\n\t      dialogEl.on($mdConstant.CSS.TRANSITIONEND, finished);\n\t      function finished(ev) {\n\t        //Make sure this transitionend didn't bubble up from a child\n\t        if (ev.target === dialogEl[0]) {\n\t          dialogEl.off($mdConstant.CSS.TRANSITIONEND, finished);\n\t          deferred.resolve();\n\t        }\n\t      }\n\t      return deferred.promise;\n\t    }\n\t\n\t  }\n\t}\n\tMdDialogProvider.$inject = [\"$$interimElementProvider\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('material.components.fabActions', ['material.core'])\n\t    .directive('mdFabActions', MdFabActionsDirective);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdFabActions\n\t   * @module material.components.fabSpeedDial\n\t   *\n\t   * @restrict E\n\t   *\n\t   * @description\n\t   * The `<md-fab-actions>` directive is used inside of a `<md-fab-speed-dial>` or\n\t   * `<md-fab-toolbar>` directive to mark the an element (or elements) as the actions and setup the\n\t   * proper event listeners.\n\t   *\n\t   * @usage\n\t   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.\n\t   */\n\t  function MdFabActionsDirective() {\n\t    return {\n\t      restrict: 'E',\n\t\n\t      require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],\n\t\n\t      link: function(scope, element, attributes, controllers) {\n\t        // Grab whichever parent controller is used\n\t        var controller = controllers[0] || controllers[1];\n\t\n\t        // Make the children open/close their parent directive\n\t        if (controller) {\n\t          angular.forEach(element.children(), function(child) {\n\t            angular.element(child).on('focus', controller.open);\n\t            angular.element(child).on('blur', controller.close);\n\t          });\n\t        }\n\t\n\t        // After setting up the listeners, wrap every child in a new div and add a class that we can\n\t        // scale/fling independently\n\t        element.children().wrap('<div class=\"md-fab-action-item\">');\n\t      }\n\t    }\n\t  }\n\t\n\t})();\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.divider\n\t * @description Divider module!\n\t */\n\tangular.module('material.components.divider', [\n\t  'material.core'\n\t])\n\t  .directive('mdDivider', MdDividerDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdDivider\n\t * @module material.components.divider\n\t * @restrict E\n\t *\n\t * @description\n\t * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.\n\t *\n\t * @param {boolean=} md-inset Add this attribute to activate the inset divider style.\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-divider></md-divider>\n\t *\n\t * <md-divider md-inset></md-divider>\n\t * </hljs>\n\t *\n\t */\n\tfunction MdDividerDirective($mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    link: $mdTheming\n\t  };\n\t}\n\tMdDividerDirective.$inject = [\"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('material.components.fabSpeedDial', [\n\t      'material.core',\n\t      'material.components.fabTrigger',\n\t      'material.components.fabActions'\n\t    ])\n\t    .directive('mdFabSpeedDial', MdFabSpeedDialDirective)\n\t    .animation('.md-fling', MdFabSpeedDialFlingAnimation)\n\t    .animation('.md-scale', MdFabSpeedDialScaleAnimation);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdFabSpeedDial\n\t   * @module material.components.fabSpeedDial\n\t   *\n\t   * @restrict E\n\t   *\n\t   * @description\n\t   * The `<md-fab-speed-dial>` directive is used to present a series of popup elements (usually\n\t   * `<md-button>`s) for quick access to common actions.\n\t   *\n\t   * There are currently two animations available by applying one of the following classes to\n\t   * the component:\n\t   *\n\t   *  - `md-fling` - The speed dial items appear from underneath the trigger and move into their\n\t   *    appropriate positions.\n\t   *  - `md-scale` - The speed dial items appear in their proper places by scaling from 0% to 100%.\n\t   *\n\t   * @usage\n\t   * <hljs lang=\"html\">\n\t   * <md-fab-speed-dial direction=\"up\" class=\"md-fling\">\n\t   *   <md-fab-trigger>\n\t   *     <md-button aria-label=\"Add...\"><md-icon icon=\"/img/icons/plus.svg\"></md-icon></md-button>\n\t   *   </md-fab-trigger>\n\t   *\n\t   *   <md-fab-actions>\n\t   *     <md-button aria-label=\"Add User\">\n\t   *       <md-icon icon=\"/img/icons/user.svg\"></md-icon>\n\t   *     </md-button>\n\t   *\n\t   *     <md-button aria-label=\"Add Group\">\n\t   *       <md-icon icon=\"/img/icons/group.svg\"></md-icon>\n\t   *     </md-button>\n\t   *   </md-fab-actions>\n\t   * </md-fab-speed-dial>\n\t   * </hljs>\n\t   *\n\t   * @param {string=} md-direction From which direction you would like the speed dial to appear\n\t   * relative to the trigger element.\n\t   * @param {expression=} md-open Programmatically control whether or not the speed-dial is visible.\n\t   */\n\t  function MdFabSpeedDialDirective() {\n\t    FabSpeedDialController.$inject = [\"$scope\", \"$element\", \"$animate\"];\n\t    return {\n\t      restrict: 'E',\n\t\n\t      scope: {\n\t        direction: '@?mdDirection',\n\t        isOpen: '=?mdOpen'\n\t      },\n\t\n\t      bindToController: true,\n\t      controller: FabSpeedDialController,\n\t      controllerAs: 'vm',\n\t\n\t      link: FabSpeedDialLink\n\t    };\n\t\n\t    function FabSpeedDialLink(scope, element) {\n\t      // Prepend an element to hold our CSS variables so we can use them in the animations below\n\t      element.prepend('<div class=\"md-css-variables\"></div>');\n\t    }\n\t\n\t    function FabSpeedDialController($scope, $element, $animate) {\n\t      var vm = this;\n\t\n\t      // Define our open/close functions\n\t      // Note: Used by fabTrigger and fabActions directives\n\t      vm.open = function() {\n\t        $scope.$apply('vm.isOpen = true');\n\t      };\n\t\n\t      vm.close = function() {\n\t        $scope.$apply('vm.isOpen = false');\n\t      };\n\t\n\t      setupDefaults();\n\t      setupListeners();\n\t      setupWatchers();\n\t\n\t      // Set our default variables\n\t      function setupDefaults() {\n\t        // Set the default direction to 'down' if none is specified\n\t        vm.direction = vm.direction || 'down';\n\t\n\t        // Set the default to be closed\n\t        vm.isOpen = vm.isOpen || false;\n\t      }\n\t\n\t      // Setup our event listeners\n\t      function setupListeners() {\n\t        $element.on('mouseenter', vm.open);\n\t        $element.on('mouseleave', vm.close);\n\t      }\n\t\n\t      // Setup our watchers\n\t      function setupWatchers() {\n\t        // Watch for changes to the direction and update classes/attributes\n\t        $scope.$watch('vm.direction', function(newDir, oldDir) {\n\t          // Add the appropriate classes so we can target the direction in the CSS\n\t          $animate.removeClass($element, 'md-' + oldDir);\n\t          $animate.addClass($element, 'md-' + newDir);\n\t        });\n\t\n\t\n\t        // Watch for changes to md-open\n\t        $scope.$watch('vm.isOpen', function(isOpen) {\n\t          var toAdd = isOpen ? 'md-is-open' : '';\n\t          var toRemove = isOpen ? '' : 'md-is-open';\n\t\n\t          $animate.setClass($element, toAdd, toRemove);\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  function MdFabSpeedDialFlingAnimation() {\n\t    function runAnimation(element) {\n\t      var el = element[0];\n\t      var ctrl = element.controller('mdFabSpeedDial');\n\t      var items = el.querySelectorAll('.md-fab-action-item');\n\t\n\t      // Grab our element which stores CSS variables\n\t      var variablesElement = el.querySelector('.md-css-variables');\n\t\n\t      // Setup JS variables based on our CSS variables\n\t      var startZIndex = variablesElement.style.zIndex;\n\t\n\t      // Always reset the items to their natural position/state\n\t      angular.forEach(items, function(item, index) {\n\t        var styles = item.style;\n\t\n\t        styles.transform = '';\n\t        styles.transitionDelay = '';\n\t        styles.opacity = 1;\n\t\n\t        // Make the items closest to the trigger have the highest z-index\n\t        item.style.zIndex = (items.length - index) + startZIndex;\n\t      });\n\t\n\t      // If the control is closed, hide the items behind the trigger\n\t      if (!ctrl.isOpen) {\n\t        angular.forEach(items, function(item, index) {\n\t          var newPosition, axis;\n\t\n\t          switch (ctrl.direction) {\n\t            case 'up':\n\t              newPosition = item.scrollHeight * (index + 1);\n\t              axis = 'Y';\n\t              break;\n\t            case 'down':\n\t              newPosition = -item.scrollHeight * (index + 1);\n\t              axis = 'Y';\n\t              break;\n\t            case 'left':\n\t              newPosition = item.scrollWidth * (index + 1);\n\t              axis = 'X';\n\t              break;\n\t            case 'right':\n\t              newPosition = -item.scrollWidth * (index + 1);\n\t              axis = 'X';\n\t              break;\n\t          }\n\t\n\t          item.style.transform = 'translate' + axis + '(' + newPosition + 'px)';\n\t        });\n\t      }\n\t    }\n\t\n\t    return {\n\t      addClass: function(element, className, done) {\n\t        if (element.hasClass('md-fling')) {\n\t          runAnimation(element);\n\t        }\n\t      },\n\t      removeClass: function(element, className, done) {\n\t        runAnimation(element);\n\t      }\n\t    }\n\t  }\n\t\n\t  function MdFabSpeedDialScaleAnimation() {\n\t    var delay = 65;\n\t\n\t    function runAnimation(element) {\n\t      var el = element[0];\n\t      var ctrl = element.controller('mdFabSpeedDial');\n\t      var items = el.querySelectorAll('.md-fab-action-item');\n\t\n\t      // Always reset the items to their natural position/state\n\t      angular.forEach(items, function(item, index) {\n\t        var styles = item.style,\n\t          offsetDelay = index * delay;\n\t\n\t        styles.opacity = ctrl.isOpen ? 1 : 0;\n\t        styles.transform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';\n\t        styles.transitionDelay = (ctrl.isOpen ?  offsetDelay : (items.length - offsetDelay)) + 'ms';\n\t      });\n\t    }\n\t\n\t    return {\n\t      addClass: function(element, className, done) {\n\t        runAnimation(element);\n\t      },\n\t\n\t      removeClass: function(element, className, done) {\n\t        runAnimation(element);\n\t      }\n\t    }\n\t  }\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('material.components.fabToolbar', [\n\t      'material.core',\n\t      'material.components.fabTrigger',\n\t      'material.components.fabActions'\n\t    ])\n\t    .directive('mdFabToolbar', MdFabToolbarDirective)\n\t    .animation('.md-fab-toolbar', MdFabToolbarAnimation);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdFabToolbar\n\t   * @module material.components.fabToolbar\n\t   *\n\t   * @restrict E\n\t   *\n\t   * @description\n\t   *\n\t   * The `<md-fab-toolbar>` directive is used present a toolbar of elements (usually `<md-button>`s)\n\t   * for quick access to common actions when a floating action button is activated (via hover or\n\t   * keyboard navigation).\n\t   *\n\t   * @usage\n\t   *\n\t   * <hljs lang=\"html\">\n\t   * <md-fab-toolbar>\n\t   *   <md-fab-trigger>\n\t   *     <md-button aria-label=\"Add...\"><md-icon icon=\"/img/icons/plus.svg\"></md-icon></md-button>\n\t   *   </md-fab-trigger>\n\t   *\n\t   *   <md-fab-actions>\n\t   *     <md-button aria-label=\"Add User\">\n\t   *       <md-icon icon=\"/img/icons/user.svg\"></md-icon>\n\t   *     </md-button>\n\t   *\n\t   *     <md-button aria-label=\"Add Group\">\n\t   *       <md-icon icon=\"/img/icons/group.svg\"></md-icon>\n\t   *     </md-button>\n\t   *   </md-fab-actions>\n\t   * </md-fab-toolbar>\n\t   * </hljs>\n\t   *\n\t   * @param {expression=} md-open Programmatically control whether or not the toolbar is visible.\n\t   */\n\t  function MdFabToolbarDirective() {\n\t    FabToolbarController.$inject = [\"$scope\", \"$element\", \"$animate\"];\n\t    return {\n\t      restrict: 'E',\n\t      transclude: true,\n\t      template:\n\t        '<div class=\"md-fab-toolbar-wrapper\">' +\n\t        '  <div class=\"md-fab-toolbar-content\" ng-transclude></div>' +\n\t        '</div>',\n\t\n\t      scope: {\n\t        isOpen: '=?mdOpen'\n\t      },\n\t\n\t      bindToController: true,\n\t      controller: FabToolbarController,\n\t      controllerAs: 'vm',\n\t\n\t      link: link\n\t    };\n\t\n\t    function FabToolbarController($scope, $element, $animate) {\n\t      var vm = this;\n\t\n\t      // Set the default to be closed\n\t      vm.isOpen = vm.isOpen || false;\n\t\n\t      vm.open = function() {\n\t        vm.isOpen = true;\n\t        $scope.$apply();\n\t      };\n\t\n\t      vm.close = function() {\n\t        vm.isOpen = false;\n\t        $scope.$apply();\n\t      };\n\t\n\t      // Add our class so we can trigger the animation on start\n\t      $element.addClass('md-fab-toolbar');\n\t\n\t      // Setup some mouse events so the hover effect can be triggered\n\t      // anywhere over the toolbar\n\t      $element.on('mouseenter', vm.open);\n\t      $element.on('mouseleave', vm.close);\n\t\n\t      // Watch for changes to md-open and toggle our class\n\t      $scope.$watch('vm.isOpen', function(isOpen) {\n\t        var toAdd = isOpen ? 'md-is-open' : '';\n\t        var toRemove = isOpen ? '' : 'md-is-open';\n\t\n\t        $animate.setClass($element, toAdd, toRemove);\n\t      });\n\t    }\n\t\n\t    function link(scope, element, attributes) {\n\t      // Don't allow focus on the trigger\n\t      element.find('md-fab-trigger').find('button').attr('tabindex', '-1');\n\t\n\t      // Prepend the background element to the trigger's button\n\t      element.find('md-fab-trigger').find('button')\n\t        .prepend('<div class=\"md-fab-toolbar-background\"></div>');\n\t    }\n\t  }\n\t\n\t  function MdFabToolbarAnimation() {\n\t    var originalIconDelay;\n\t\n\t    function runAnimation(element, className, done) {\n\t      var el = element[0];\n\t      var ctrl = element.controller('mdFabToolbar');\n\t\n\t      // Grab the relevant child elements\n\t      var backgroundElement = el.querySelector('.md-fab-toolbar-background');\n\t      var triggerElement = el.querySelector('md-fab-trigger button');\n\t      var iconElement = el.querySelector('md-fab-trigger button md-icon');\n\t      var actions = element.find('md-fab-actions').children();\n\t\n\t      // If we have both elements, use them to position the new background\n\t      if (triggerElement && backgroundElement) {\n\t        // Get our variables\n\t        var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');\n\t        var width = el.offsetWidth;\n\t        var height = el.offsetHeight;\n\t\n\t        // Make a square\n\t        var scale = width * 2;\n\t\n\t        // Set some basic styles no matter what animation we're doing\n\t        backgroundElement.style.backgroundColor = color;\n\t        backgroundElement.style.borderRadius = width + 'px';\n\t\n\t        // If we're open\n\t        if (ctrl.isOpen) {\n\t\n\t          // Set the width/height to take up the full toolbar width\n\t          backgroundElement.style.width = scale + 'px';\n\t          backgroundElement.style.height = scale + 'px';\n\t\n\t          // Set the top/left to move up/left (or right) by the scale width/height\n\t          backgroundElement.style.top = -(scale / 2) + 'px';\n\t\n\t          if (element.hasClass('md-left')) {\n\t            backgroundElement.style.left = -(scale / 2) + 'px';\n\t            backgroundElement.style.right = null;\n\t          }\n\t\n\t          if (element.hasClass('md-right')) {\n\t            backgroundElement.style.right = -(scale / 2) + 'px';\n\t            backgroundElement.style.left = null;\n\t          }\n\t\n\t          // Set the next close animation to have the proper delays\n\t          backgroundElement.style.transitionDelay = '0ms';\n\t          iconElement.style.transitionDelay = '.3s';\n\t\n\t          // Apply a transition delay to actions\n\t          angular.forEach(actions, function(action, index) {\n\t            action.style.transitionDelay = (actions.length - index) * 25 + 'ms';\n\t          });\n\t        } else {\n\t          // Otherwise, set the width/height to the trigger's width/height\n\t          backgroundElement.style.width = triggerElement.offsetWidth + 'px';\n\t          backgroundElement.style.height = triggerElement.offsetHeight + 'px';\n\t\n\t          // Reset the position\n\t          backgroundElement.style.top = '0px';\n\t\n\t          if (element.hasClass('md-left')) {\n\t            backgroundElement.style.left = '0px';\n\t            backgroundElement.style.right = null;\n\t          }\n\t\n\t          if (element.hasClass('md-right')) {\n\t            backgroundElement.style.right = '0px';\n\t            backgroundElement.style.left = null;\n\t          }\n\t\n\t          // Set the next open animation to have the proper delays\n\t          backgroundElement.style.transitionDelay = '200ms';\n\t          iconElement.style.transitionDelay = '0ms';\n\t\n\t          // Apply a transition delay to actions\n\t          angular.forEach(actions, function(action, index) {\n\t            action.style.transitionDelay = (index * 25) + 'ms';\n\t          });\n\t        }\n\t      }\n\t    }\n\t\n\t    return {\n\t      addClass: function(element, className, done) {\n\t        runAnimation(element, className, done);\n\t      },\n\t\n\t      removeClass: function(element, className, done) {\n\t        runAnimation(element, className, done);\n\t      }\n\t    }\n\t  }\n\t})();\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.gridList\n\t */\n\tangular.module('material.components.gridList', ['material.core'])\n\t       .directive('mdGridList', GridListDirective)\n\t       .directive('mdGridTile', GridTileDirective)\n\t       .directive('mdGridTileFooter', GridTileCaptionDirective)\n\t       .directive('mdGridTileHeader', GridTileCaptionDirective)\n\t       .factory('$mdGridLayout', GridLayoutFactory);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdGridList\n\t * @module material.components.gridList\n\t * @restrict E\n\t * @description\n\t * Grid lists are an alternative to standard list views. Grid lists are distinct\n\t * from grids used for layouts and other visual presentations.\n\t *\n\t * A grid list is best suited to presenting a homogenous data type, typically\n\t * images, and is optimized for visual comprehension and differentiating between\n\t * like data types.\n\t *\n\t * A grid list is a continuous element consisting of tessellated, regular\n\t * subdivisions called cells that contain tiles (`md-grid-tile`).\n\t *\n\t * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png\"\n\t *    style=\"width: 300px; height: auto; margin-right: 16px;\" alt=\"Concept of grid explained visually\">\n\t * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png\"\n\t *    style=\"width: 300px; height: auto;\" alt=\"Grid concepts legend\">\n\t *\n\t * Cells are arrayed vertically and horizontally within the grid.\n\t *\n\t * Tiles hold content and can span one or more cells vertically or horizontally.\n\t *\n\t * ### Responsive Attributes\n\t *\n\t * The `md-grid-list` directive supports \"responsive\" attributes, which allow\n\t * different `md-cols`, `md-gutter` and `md-row-height` values depending on the\n\t * currently matching media query (as defined in `$mdConstant.MEDIA`).\n\t *\n\t * In order to set a responsive attribute, first define the fallback value with\n\t * the standard attribute name, then add additional attributes with the\n\t * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n\t * (ie. `md-cols-lg=\"8\"`)\n\t *\n\t * @param {number} md-cols Number of columns in the grid.\n\t * @param {string} md-row-height One of\n\t * <ul>\n\t *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>\n\t *   <li>`{width}:{height}` - Ratio of width to height (eg.\n\t *   `md-row-height=\"16:9\"`)</li>\n\t *   <li>`\"fit\"` - Height will be determined by subdividing the available\n\t *   height by the number of rows</li>\n\t * </ul>\n\t * @param {string=} md-gutter The amount of space between tiles in CSS units\n\t *     (default 1px)\n\t * @param {expression=} md-on-layout Expression to evaluate after layout. Event\n\t *     object is available as `$event`, and contains performance information.\n\t *\n\t * @usage\n\t * Basic:\n\t * <hljs lang=\"html\">\n\t * <md-grid-list md-cols=\"5\" md-gutter=\"1em\" md-row-height=\"4:3\">\n\t *   <md-grid-tile></md-grid-tile>\n\t * </md-grid-list>\n\t * </hljs>\n\t *\n\t * Fixed-height rows:\n\t * <hljs lang=\"html\">\n\t * <md-grid-list md-cols=\"4\" md-row-height=\"200px\" ...>\n\t *   <md-grid-tile></md-grid-tile>\n\t * </md-grid-list>\n\t * </hljs>\n\t *\n\t * Fit rows:\n\t * <hljs lang=\"html\">\n\t * <md-grid-list md-cols=\"4\" md-row-height=\"fit\" style=\"height: 400px;\" ...>\n\t *   <md-grid-tile></md-grid-tile>\n\t * </md-grid-list>\n\t * </hljs>\n\t *\n\t * Using responsive attributes:\n\t * <hljs lang=\"html\">\n\t * <md-grid-list\n\t *     md-cols-sm=\"2\"\n\t *     md-cols-md=\"4\"\n\t *     md-cols-lg=\"8\"\n\t *     md-cols-gt-lg=\"12\"\n\t *     ...>\n\t *   <md-grid-tile></md-grid-tile>\n\t * </md-grid-list>\n\t * </hljs>\n\t */\n\tfunction GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {\n\t  return {\n\t    restrict: 'E',\n\t    controller: GridListController,\n\t    scope: {\n\t      mdOnLayout: '&'\n\t    },\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attrs, ctrl) {\n\t    // Apply semantics\n\t    element.attr('role', 'list');\n\t\n\t    // Provide the controller with a way to trigger layouts.\n\t    ctrl.layoutDelegate = layoutDelegate;\n\t\n\t    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),\n\t        unwatchAttrs = watchMedia();\n\t      scope.$on('$destroy', unwatchMedia);\n\t\n\t    /**\n\t     * Watches for changes in media, invalidating layout as necessary.\n\t     */\n\t    function watchMedia() {\n\t      for (var mediaName in $mdConstant.MEDIA) {\n\t        $mdMedia(mediaName); // initialize\n\t        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n\t            .addListener(invalidateLayout);\n\t      }\n\t      return $mdMedia.watchResponsiveAttributes(\n\t          ['md-cols', 'md-row-height'], attrs, layoutIfMediaMatch);\n\t    }\n\t\n\t    function unwatchMedia() {\n\t      ctrl.layoutDelegate = angular.noop;\n\t\n\t      unwatchAttrs();\n\t      for (var mediaName in $mdConstant.MEDIA) {\n\t        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n\t            .removeListener(invalidateLayout);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Performs grid layout if the provided mediaName matches the currently\n\t     * active media type.\n\t     */\n\t    function layoutIfMediaMatch(mediaName) {\n\t      if (mediaName == null) {\n\t        // TODO(shyndman): It would be nice to only layout if we have\n\t        // instances of attributes using this media type\n\t        ctrl.invalidateLayout();\n\t      } else if ($mdMedia(mediaName)) {\n\t        ctrl.invalidateLayout();\n\t      }\n\t    }\n\t\n\t    var lastLayoutProps;\n\t\n\t    /**\n\t     * Invokes the layout engine, and uses its results to lay out our\n\t     * tile elements.\n\t     *\n\t     * @param {boolean} tilesInvalidated Whether tiles have been\n\t     *    added/removed/moved since the last layout. This is to avoid situations\n\t     *    where tiles are replaced with properties identical to their removed\n\t     *    counterparts.\n\t     */\n\t    function layoutDelegate(tilesInvalidated) {\n\t      var tiles = getTileElements();\n\t      var props = {\n\t        tileSpans: getTileSpans(tiles),\n\t        colCount: getColumnCount(),\n\t        rowMode: getRowMode(),\n\t        rowHeight: getRowHeight(),\n\t        gutter: getGutter()\n\t      };\n\t\n\t      if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {\n\t        return;\n\t      }\n\t\n\t      var performance =\n\t        $mdGridLayout(props.colCount, props.tileSpans, tiles)\n\t          .map(function(tilePositions, rowCount) {\n\t            return {\n\t              grid: {\n\t                element: element,\n\t                style: getGridStyle(props.colCount, rowCount,\n\t                    props.gutter, props.rowMode, props.rowHeight)\n\t              },\n\t              tiles: tilePositions.map(function(ps, i) {\n\t                return {\n\t                  element: angular.element(tiles[i]),\n\t                  style: getTileStyle(ps.position, ps.spans,\n\t                      props.colCount, props.rowCount,\n\t                      props.gutter, props.rowMode, props.rowHeight)\n\t                }\n\t              })\n\t            }\n\t          })\n\t          .reflow()\n\t          .performance();\n\t\n\t      // Report layout\n\t      scope.mdOnLayout({\n\t        $event: {\n\t          performance: performance\n\t        }\n\t      });\n\t\n\t      lastLayoutProps = props;\n\t    }\n\t\n\t    // Use $interpolate to do some simple string interpolation as a convenience.\n\t\n\t    var startSymbol = $interpolate.startSymbol();\n\t    var endSymbol = $interpolate.endSymbol();\n\t\n\t    // Returns an expression wrapped in the interpolator's start and end symbols.\n\t    function expr(exprStr) {\n\t      return startSymbol + exprStr + endSymbol;\n\t    }\n\t\n\t    // The amount of space a single 1x1 tile would take up (either width or height), used as\n\t    // a basis for other calculations. This consists of taking the base size percent (as would be\n\t    // if evenly dividing the size between cells), and then subtracting the size of one gutter.\n\t    // However, since there are no gutters on the edges, each tile only uses a fration\n\t    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per\n\t    // tile, and then breaking up the extra gutter on the edge evenly among the cells).\n\t    var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');\n\t\n\t    // The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n\t    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n\t    // row/column (offset).\n\t    var POSITION  = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');\n\t\n\t    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.\n\t    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back\n\t    // in the space that the gutter would normally have used (which was already accounted for in\n\t    // the base unit calculation).\n\t    var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');\n\t\n\t    /**\n\t     * Gets the styles applied to a tile element described by the given parameters.\n\t     * @param {{row: number, col: number}} position The row and column indices of the tile.\n\t     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.\n\t     * @param {number} colCount The number of columns.\n\t     * @param {number} rowCount The number of rows.\n\t     * @param {string} gutter The amount of space between tiles. This will be something like\n\t     *     '5px' or '2em'.\n\t     * @param {string} rowMode The row height mode. Can be one of:\n\t     *     'fixed': all rows have a fixed size, given by rowHeight,\n\t     *     'ratio': row height defined as a ratio to width, or\n\t     *     'fit': fit to the grid-list element height, divinding evenly among rows.\n\t     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and\n\t     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).\n\t     * @returns {Object} Map of CSS properties to be applied to the style element. Will define\n\t     *     values for top, left, width, height, marginTop, and paddingTop.\n\t     */\n\t    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {\n\t      // TODO(shyndman): There are style caching opportunities here.\n\t\n\t      // Percent of the available horizontal space that one column takes up.\n\t      var hShare = (1 / colCount) * 100;\n\t\n\t      // Fraction of the gutter size that each column takes up.\n\t      var hGutterShare = (colCount - 1) / colCount;\n\t\n\t      // Base horizontal size of a column.\n\t      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});\n\t\n\t      // The width and horizontal position of each tile is always calculated the same way, but the\n\t      // height and vertical position depends on the rowMode.\n\t      var style = {\n\t        left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),\n\t        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),\n\t        // resets\n\t        paddingTop: '',\n\t        marginTop: '',\n\t        top: '',\n\t        height: ''\n\t      };\n\t\n\t      switch (rowMode) {\n\t        case 'fixed':\n\t          // In fixed mode, simply use the given rowHeight.\n\t          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });\n\t          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });\n\t          break;\n\t\n\t        case 'ratio':\n\t          // Percent of the available vertical space that one row takes up. Here, rowHeight holds\n\t          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.\n\t          var vShare = hShare / rowHeight;\n\t\n\t          // Base veritcal size of a row.\n\t          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\t\n\t          // padidngTop and marginTop are used to maintain the given aspect ratio, as\n\t          // a percentage-based value for these properties is applied to the *width* of the\n\t          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n\t          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});\n\t          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });\n\t          break;\n\t\n\t        case 'fit':\n\t          // Fraction of the gutter size that each column takes up.\n\t          var vGutterShare = (rowCount - 1) / rowCount;\n\t\n\t          // Percent of the available vertical space that one row takes up.\n\t          var vShare = (1 / rowCount) * 100;\n\t\n\t          // Base vertical size of a row.\n\t          var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});\n\t\n\t          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n\t          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n\t          break;\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {\n\t      var style = {\n\t        height: '',\n\t        paddingBottom: ''\n\t      };\n\t\n\t      switch(rowMode) {\n\t        case 'fixed':\n\t          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });\n\t          break;\n\t\n\t        case 'ratio':\n\t          // rowHeight is width / height\n\t          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,\n\t              hShare = (1 / colCount) * 100,\n\t              vShare = hShare * (1 / rowHeight),\n\t              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\t\n\t          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});\n\t          break;\n\t\n\t        case 'fit':\n\t          // noop, as the height is user set\n\t          break;\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    function getTileElements() {\n\t      return [].filter.call(element.children(), function(ele) {\n\t        return ele.tagName == 'MD-GRID-TILE';\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets an array of objects containing the rowspan and colspan for each tile.\n\t     * @returns {Array<{row: number, col: number}>}\n\t     */\n\t    function getTileSpans(tileElements) {\n\t      return [].map.call(tileElements, function(ele) {\n\t        var ctrl = angular.element(ele).controller('mdGridTile');\n\t        return {\n\t          row: parseInt(\n\t              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,\n\t          col: parseInt(\n\t              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1\n\t        };\n\t      });\n\t    }\n\t\n\t    function getColumnCount() {\n\t      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);\n\t      if (isNaN(colCount)) {\n\t        throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';\n\t      }\n\t      return colCount;\n\t    }\n\t\n\t    function getGutter() {\n\t      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);\n\t    }\n\t\n\t    function getRowHeight() {\n\t      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n\t      switch (getRowMode()) {\n\t        case 'fixed':\n\t          return applyDefaultUnit(rowHeight);\n\t        case 'ratio':\n\t          var whRatio = rowHeight.split(':');\n\t          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);\n\t        case 'fit':\n\t          return 0; // N/A\n\t      }\n\t    }\n\t\n\t    function getRowMode() {\n\t      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n\t      if (rowHeight == 'fit') {\n\t        return 'fit';\n\t      } else if (rowHeight.indexOf(':') !== -1) {\n\t        return 'ratio';\n\t      } else {\n\t        return 'fixed';\n\t      }\n\t    }\n\t\n\t    function applyDefaultUnit(val) {\n\t      return /\\D$/.test(val) ? val : val + 'px';\n\t    }\n\t  }\n\t}\n\tGridListDirective.$inject = [\"$interpolate\", \"$mdConstant\", \"$mdGridLayout\", \"$mdMedia\"];\n\t\n\t/* @ngInject */\n\tfunction GridListController($timeout) {\n\t  this.layoutInvalidated = false;\n\t  this.tilesInvalidated = false;\n\t  this.$timeout_ = $timeout;\n\t  this.layoutDelegate = angular.noop;\n\t}\n\tGridListController.$inject = [\"$timeout\"];\n\t\n\tGridListController.prototype = {\n\t  invalidateTiles: function() {\n\t    this.tilesInvalidated = true;\n\t    this.invalidateLayout();\n\t  },\n\t\n\t  invalidateLayout: function() {\n\t    if (this.layoutInvalidated) {\n\t      return;\n\t    }\n\t    this.layoutInvalidated = true;\n\t    this.$timeout_(angular.bind(this, this.layout));\n\t  },\n\t\n\t  layout: function() {\n\t    try {\n\t      this.layoutDelegate(this.tilesInvalidated);\n\t    } finally {\n\t      this.layoutInvalidated = false;\n\t      this.tilesInvalidated = false;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/* @ngInject */\n\tfunction GridLayoutFactory($mdUtil) {\n\t  var defaultAnimator = GridTileAnimator;\n\t\n\t  /**\n\t   * Set the reflow animator callback\n\t   */\n\t  GridLayout.animateWith = function(customAnimator) {\n\t    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;\n\t  };\n\t\n\t  return GridLayout;\n\t\n\t  /**\n\t   * Publish layout function\n\t   */\n\t  function GridLayout(colCount, tileSpans) {\n\t      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;\n\t\n\t      layoutTime = $mdUtil.time(function() {\n\t        layoutInfo = calculateGridFor(colCount, tileSpans);\n\t      });\n\t\n\t      return self = {\n\t\n\t        /**\n\t         * An array of objects describing each tile's position in the grid.\n\t         */\n\t        layoutInfo: function() {\n\t          return layoutInfo;\n\t        },\n\t\n\t        /**\n\t         * Maps grid positioning to an element and a set of styles using the\n\t         * provided updateFn.\n\t         */\n\t        map: function(updateFn) {\n\t          mapTime = $mdUtil.time(function() {\n\t            var info = self.layoutInfo();\n\t            gridStyles = updateFn(info.positioning, info.rowCount);\n\t          });\n\t          return self;\n\t        },\n\t\n\t        /**\n\t         * Default animator simply sets the element.css( <styles> ). An alternate\n\t         * animator can be provided as an argument. The function has the following\n\t         * signature:\n\t         *\n\t         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)\n\t         */\n\t        reflow: function(animatorFn) {\n\t          reflowTime = $mdUtil.time(function() {\n\t            var animator = animatorFn || defaultAnimator;\n\t            animator(gridStyles.grid, gridStyles.tiles);\n\t          });\n\t          return self;\n\t        },\n\t\n\t        /**\n\t         * Timing for the most recent layout run.\n\t         */\n\t        performance: function() {\n\t          return {\n\t            tileCount: tileSpans.length,\n\t            layoutTime: layoutTime,\n\t            mapTime: mapTime,\n\t            reflowTime: reflowTime,\n\t            totalTime: layoutTime + mapTime + reflowTime\n\t          };\n\t        }\n\t      };\n\t    }\n\t\n\t  /**\n\t   * Default Gridlist animator simple sets the css for each element;\n\t   * NOTE: any transitions effects must be manually set in the CSS.\n\t   * e.g.\n\t   *\n\t   *  md-grid-tile {\n\t   *    transition: all 700ms ease-out 50ms;\n\t   *  }\n\t   *\n\t   */\n\t  function GridTileAnimator(grid, tiles) {\n\t    grid.element.css(grid.style);\n\t    tiles.forEach(function(t) {\n\t      t.element.css(t.style);\n\t    })\n\t  }\n\t\n\t  /**\n\t   * Calculates the positions of tiles.\n\t   *\n\t   * The algorithm works as follows:\n\t   *    An Array<Number> with length colCount (spaceTracker) keeps track of\n\t   *    available tiling positions, where elements of value 0 represents an\n\t   *    empty position. Space for a tile is reserved by finding a sequence of\n\t   *    0s with length <= than the tile's colspan. When such a space has been\n\t   *    found, the occupied tile positions are incremented by the tile's\n\t   *    rowspan value, as these positions have become unavailable for that\n\t   *    many rows.\n\t   *\n\t   *    If the end of a row has been reached without finding space for the\n\t   *    tile, spaceTracker's elements are each decremented by 1 to a minimum\n\t   *    of 0. Rows are searched in this fashion until space is found.\n\t   */\n\t  function calculateGridFor(colCount, tileSpans) {\n\t    var curCol = 0,\n\t        curRow = 0,\n\t        spaceTracker = newSpaceTracker();\n\t\n\t    return {\n\t      positioning: tileSpans.map(function(spans, i) {\n\t        return {\n\t          spans: spans,\n\t          position: reserveSpace(spans, i)\n\t        };\n\t      }),\n\t      rowCount: curRow + Math.max.apply(Math, spaceTracker)\n\t    };\n\t\n\t    function reserveSpace(spans, i) {\n\t      if (spans.col > colCount) {\n\t        throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +\n\t            '(' + spans.col + ') that exceeds the column count ' +\n\t            '(' + colCount + ')';\n\t      }\n\t\n\t      var start = 0,\n\t          end = 0;\n\t\n\t      // TODO(shyndman): This loop isn't strictly necessary if you can\n\t      // determine the minimum number of rows before a space opens up. To do\n\t      // this, recognize that you've iterated across an entire row looking for\n\t      // space, and if so fast-forward by the minimum rowSpan count. Repeat\n\t      // until the required space opens up.\n\t      while (end - start < spans.col) {\n\t        if (curCol >= colCount) {\n\t          nextRow();\n\t          continue;\n\t        }\n\t\n\t        start = spaceTracker.indexOf(0, curCol);\n\t        if (start === -1 || (end = findEnd(start + 1)) === -1) {\n\t          start = end = 0;\n\t          nextRow();\n\t          continue;\n\t        }\n\t\n\t        curCol = end + 1;\n\t      }\n\t\n\t      adjustRow(start, spans.col, spans.row);\n\t      curCol = start + spans.col;\n\t\n\t      return {\n\t        col: start,\n\t        row: curRow\n\t      };\n\t    }\n\t\n\t    function nextRow() {\n\t      curCol = 0;\n\t      curRow++;\n\t      adjustRow(0, colCount, -1); // Decrement row spans by one\n\t    }\n\t\n\t    function adjustRow(from, cols, by) {\n\t      for (var i = from; i < from + cols; i++) {\n\t        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);\n\t      }\n\t    }\n\t\n\t    function findEnd(start) {\n\t      var i;\n\t      for (i = start; i < spaceTracker.length; i++) {\n\t        if (spaceTracker[i] !== 0) {\n\t          return i;\n\t        }\n\t      }\n\t\n\t      if (i === spaceTracker.length) {\n\t        return i;\n\t      }\n\t    }\n\t\n\t    function newSpaceTracker() {\n\t      var tracker = [];\n\t      for (var i = 0; i < colCount; i++) {\n\t        tracker.push(0);\n\t      }\n\t      return tracker;\n\t    }\n\t  }\n\t}\n\tGridLayoutFactory.$inject = [\"$mdUtil\"];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdGridTile\n\t * @module material.components.gridList\n\t * @restrict E\n\t * @description\n\t * Tiles contain the content of an `md-grid-list`. They span one or more grid\n\t * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to\n\t * display secondary content.\n\t *\n\t * ### Responsive Attributes\n\t *\n\t * The `md-grid-tile` directive supports \"responsive\" attributes, which allow\n\t * different `md-rowspan` and `md-colspan` values depending on the currently\n\t * matching media query (as defined in `$mdConstant.MEDIA`).\n\t *\n\t * In order to set a responsive attribute, first define the fallback value with\n\t * the standard attribute name, then add additional attributes with the\n\t * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n\t * (ie. `md-colspan-sm=\"4\"`)\n\t *\n\t * @param {number=} md-colspan The number of columns to span (default 1). Cannot\n\t *    exceed the number of columns in the grid. Supports interpolation.\n\t * @param {number=} md-rowspan The number of rows to span (default 1). Supports\n\t *     interpolation.\n\t *\n\t * @usage\n\t * With header:\n\t * <hljs lang=\"html\">\n\t * <md-grid-tile>\n\t *   <md-grid-tile-header>\n\t *     <h3>This is a header</h3>\n\t *   </md-grid-tile-header>\n\t * </md-grid-tile>\n\t * </hljs>\n\t *\n\t * With footer:\n\t * <hljs lang=\"html\">\n\t * <md-grid-tile>\n\t *   <md-grid-tile-footer>\n\t *     <h3>This is a footer</h3>\n\t *   </md-grid-tile-footer>\n\t * </md-grid-tile>\n\t * </hljs>\n\t *\n\t * Spanning multiple rows/columns:\n\t * <hljs lang=\"html\">\n\t * <md-grid-tile md-colspan=\"2\" md-rowspan=\"3\">\n\t * </md-grid-tile>\n\t * </hljs>\n\t *\n\t * Responsive attributes:\n\t * <hljs lang=\"html\">\n\t * <md-grid-tile md-colspan=\"1\" md-colspan-sm=\"3\" md-colspan-md=\"5\">\n\t * </md-grid-tile>\n\t * </hljs>\n\t */\n\tfunction GridTileDirective($mdMedia) {\n\t  return {\n\t    restrict: 'E',\n\t    require: '^mdGridList',\n\t    template: '<figure ng-transclude></figure>',\n\t    transclude: true,\n\t    scope: {},\n\t    // Simple controller that exposes attributes to the grid directive\n\t    controller: [\"$attrs\", function($attrs) {\n\t      this.$attrs = $attrs;\n\t    }],\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attrs, gridCtrl) {\n\t    // Apply semantics\n\t    element.attr('role', 'listitem');\n\t\n\t    // If our colspan or rowspan changes, trigger a layout\n\t    var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'],\n\t        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));\n\t\n\t    // Tile registration/deregistration\n\t    gridCtrl.invalidateTiles();\n\t    scope.$on('$destroy', function() {\n\t      unwatchAttrs();\n\t      gridCtrl.invalidateLayout();\n\t    });\n\t\n\t    if (angular.isDefined(scope.$parent.$index)) {\n\t      scope.$watch(function() { return scope.$parent.$index; },\n\t        function indexChanged(newIdx, oldIdx) {\n\t          if (newIdx === oldIdx) {\n\t            return;\n\t          }\n\t          gridCtrl.invalidateTiles();\n\t        });\n\t    }\n\t  }\n\t}\n\tGridTileDirective.$inject = [\"$mdMedia\"];\n\t\n\t\n\tfunction GridTileCaptionDirective() {\n\t  return {\n\t    template: '<figcaption ng-transclude></figcaption>',\n\t    transclude: true\n\t  };\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('material.components.fabTrigger', [ 'material.core' ])\n\t    .directive('mdFabTrigger', MdFabTriggerDirective);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdFabTrigger\n\t   * @module material.components.fabSpeedDial\n\t   *\n\t   * @restrict E\n\t   *\n\t   * @description\n\t   * The `<md-fab-trigger>` directive is used inside of a `<md-fab-speed-dial>` or\n\t   * `<md-fab-toolbar>` directive to mark the an element (or elements) as the trigger and setup the\n\t   * proper event listeners.\n\t   *\n\t   * @usage\n\t   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.\n\t   */\n\t  function MdFabTriggerDirective() {\n\t    return {\n\t      restrict: 'E',\n\t\n\t      require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],\n\t\n\t      link: function(scope, element, attributes, controllers) {\n\t        // Grab whichever parent controller is used\n\t        var controller = controllers[0] || controllers[1];\n\t\n\t        // Make the children open/close their parent directive\n\t        if (controller) {\n\t          angular.forEach(element.children(), function(child) {\n\t            angular.element(child).on('focus', controller.open);\n\t            angular.element(child).on('blur', controller.close);\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }\n\t})();\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.icon\n\t * @description\n\t * Icon\n\t */\n\tangular.module('material.components.icon', [\n\t    'material.core'\n\t  ])\n\t  .directive('mdIcon', mdIconDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdIcon\n\t * @module material.components.icon\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-icon>` directive is an markup element useful for showing an icon based on a font-icon\n\t * or a SVG. Icons are view-only elements that should not be used directly as buttons; instead nest a `<md-icon>`\n\t * inside a `md-button` to add hover and click features.\n\t *\n\t * When using SVGs, both external SVGs (via URLs) or sets of SVGs [from icon sets] can be\n\t * easily loaded and used.When use font-icons, developers must following three (3) simple steps:\n\t *\n\t * <ol>\n\t * <li>Load the font library. e.g.<br/>\n\t *    &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n\t *    rel=\"stylesheet\"&gt;\n\t * </li>\n\t * <li> Use either (a) font-icon class names or (b) font ligatures to render the font glyph by using its textual name</li>\n\t * <li> Use &lt;md-icon md-font-icon=\"classname\" /&gt; or <br/>\n\t *     use &lt;md-icon md-font-set=\"font library classname or alias\"&gt; textual_name &lt;/md-icon&gt; or <br/>\n\t *     use &lt;md-icon md-font-set=\"font library classname or alias\"&gt; numerical_character_reference &lt;/md-icon&gt;\n\t * </li>\n\t * </ol>\n\t *\n\t * Full details for these steps can be found:\n\t *\n\t * <ul>\n\t * <li>http://google.github.io/material-design-icons/</li>\n\t * <li>http://google.github.io/material-design-icons/#icon-font-for-the-web</li>\n\t * </ul>\n\t *\n\t * The Material Design icon style <code>.material-icons</code> and the icon font references are published in\n\t * Material Design Icons:\n\t *\n\t * <ul>\n\t * <li>http://www.google.com/design/icons/</li>\n\t * <li>https://www.google.com/design/icons/#ic_accessibility</li>\n\t * </ul>\n\t *\n\t * <h2 id=\"material_design_icons\">Material Design Icons</h2>\n\t * Using the Material Design Icon-Selector, developers can easily and quickly search for a Material Design font-icon and\n\t * determine its textual name and character reference code. Click on any icon to see the slide-up information\n\t * panel with details regarding a SVG download or information on the font-icon usage.\n\t *\n\t * <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\" style=\"border-bottom:none;\">\n\t * <img src=\"https://cloud.githubusercontent.com/assets/210413/7902490/fe8dd14c-0780-11e5-98fb-c821cc6475e6.png\"\n\t *      aria-label=\"Material Design Icon-Selector\" style=\"max-width:75%;padding-left:10%\">\n\t * </a>\n\t *\n\t * <span class=\"image_caption\">\n\t *  Click on the image above to link to the\n\t *  <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\">Material Design Icon-Selector</a>.\n\t * </span>\n\t *\n\t * @param {string} md-font-icon Name of CSS icon associated with the font-face will be used\n\t * to render the icon. Requires the fonts and the named CSS styles to be preloaded.\n\t * @param {string} md-font-set CSS style name associated with the font library; which will be assigned as\n\t * the class for the font-icon ligature. This value may also be an alias that is used to lookup the classname;\n\t * internally use `$mdIconProvider.fontSet(<alias>)` to determine the style name.\n\t * @param {string} md-svg-src URL [or expression ] used to load, cache, and display an external SVG.\n\t * @param {string} md-svg-icon Name used for lookup of the icon from the internal cache; interpolated strings or\n\t * expressions may also be used. Specific set names can be used with the syntax `<set name>:<icon name>`.<br/><br/>\n\t * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.\n\t * @param {string=} aria-label Labels icon for accessibility. If an empty string is provided, icon\n\t * will be hidden from accessibility layer with `aria-hidden=\"true\"`. If there's no aria-label on the icon\n\t * nor a label on the parent element, a warning will be logged to the console.\n\t *\n\t * @usage\n\t * When using SVGs:\n\t * <hljs lang=\"html\">\n\t *\n\t *  <!-- Icon ID; may contain optional icon set prefix; icons must registered using $mdIconProvider -->\n\t *  <md-icon md-svg-icon=\"social:android\"    aria-label=\"android \" ></md-icon>\n\t *\n\t *  <!-- Icon urls; may be preloaded in templateCache -->\n\t *  <md-icon md-svg-src=\"/android.svg\"       aria-label=\"android \" ></md-icon>\n\t *  <md-icon md-svg-src=\"{{ getAndroid() }}\" aria-label=\"android \" ></md-icon>\n\t *\n\t * </hljs>\n\t *\n\t * Use the <code>$mdIconProvider</code> to configure your application with\n\t * svg iconsets.\n\t *\n\t * <hljs lang=\"js\">\n\t *  angular.module('appSvgIconSets', ['ngMaterial'])\n\t *    .controller('DemoCtrl', function($scope) {})\n\t *    .config(function($mdIconProvider) {\n\t *      $mdIconProvider\n\t *         .iconSet('social', 'img/icons/sets/social-icons.svg', 24)\n\t *         .defaultIconSet('img/icons/sets/core-icons.svg', 24);\n\t *     });\n\t * </hljs>\n\t *\n\t *\n\t * When using Font Icons with classnames:\n\t * <hljs lang=\"html\">\n\t *\n\t *  <md-icon md-font-icon=\"android\" aria-label=\"android\" ></md-icon>\n\t *  <md-icon class=\"icon_home\"      aria-label=\"Home\"    ></md-icon>\n\t *\n\t * </hljs>\n\t *\n\t * When using Material Font Icons with ligatures:\n\t * <hljs lang=\"html\">\n\t *  <!-- For Material Design Icons -->\n\t *  <!-- The class '.material-icons' is auto-added. -->\n\t *  <md-icon> face </md-icon>\n\t *  <md-icon class=\"md-light md-48\"> face </md-icon>\n\t *  <md-icon md-font-set=\"material-icons\"> face </md-icon>\n\t *  <md-icon> #xE87C; </md-icon>\n\t * </hljs>\n\t *\n\t * When using other Font-Icon libraries:\n\t *\n\t * <hljs lang=\"js\">\n\t *  // Specify a font-icon style alias\n\t *  angular.config(function($mdIconProvider) {\n\t *    $mdIconProvider.fontSet('fa', 'fontawesome');\n\t *  });\n\t * </hljs>\n\t *\n\t * <hljs lang=\"html\">\n\t *  <md-icon md-font-set=\"fa\">email</md-icon>\n\t * </hljs>\n\t *\n\t */\n\tfunction mdIconDirective($mdIcon, $mdTheming, $mdAria, $interpolate ) {\n\t\n\t  return {\n\t    scope: {\n\t      fontSet : '@mdFontSet',\n\t      fontIcon: '@mdFontIcon',\n\t      svgIcon : '@mdSvgIcon',\n\t      svgSrc  : '@mdSvgSrc'\n\t    },\n\t    restrict: 'E',\n\t    link : postLink\n\t  };\n\t\n\t\n\t  /**\n\t   * Directive postLink\n\t   * Supports embedded SVGs, font-icons, & external SVGs\n\t   */\n\t  function postLink(scope, element, attr) {\n\t    $mdTheming(element);\n\t\n\t    prepareForFontIcon();\n\t\n\t    // If using a font-icon, then the textual name of the icon itself\n\t    // provides the aria-label.\n\t\n\t    var label = attr.alt || scope.fontIcon || scope.svgIcon || element.text();\n\t    var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');\n\t\n\t    if ( !attr['aria-label'] ) {\n\t\n\t      if (label != '' && !parentsHaveText() ) {\n\t\n\t        $mdAria.expect(element, 'aria-label', label);\n\t        $mdAria.expect(element, 'role', 'img');\n\t\n\t      } else if ( !element.text() ) {\n\t        // If not a font-icon with ligature, then\n\t        // hide from the accessibility layer.\n\t\n\t        $mdAria.expect(element, 'aria-hidden', 'true');\n\t      }\n\t    }\n\t\n\t    if (attrName) {\n\t      // Use either pre-configured SVG or URL source, respectively.\n\t      attr.$observe(attrName, function(attrVal) {\n\t\n\t        element.empty();\n\t        if (attrVal) {\n\t          $mdIcon(attrVal).then(function(svg) {\n\t            element.append(svg);\n\t          });\n\t        }\n\t\n\t      });\n\t    }\n\t\n\t    function parentsHaveText() {\n\t      var parent = element.parent();\n\t      if (parent.attr('aria-label') || parent.text()) {\n\t        return true;\n\t      }\n\t      else if(parent.parent().attr('aria-label') || parent.parent().text()) {\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t\n\t    function prepareForFontIcon () {\n\t      if (!scope.svgIcon && !scope.svgSrc) {\n\t        if (scope.fontIcon) {\n\t          element.addClass('md-font');\n\t          element.addClass(scope.fontIcon);\n\t        } else {\n\t          element.addClass($mdIcon.fontSet(scope.fontSet));\n\t        }\n\t      }\n\t\n\t    }\n\t  }\n\t}\n\tmdIconDirective.$inject = [\"$mdIcon\", \"$mdTheming\", \"$mdAria\", \"$interpolate\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  angular\n\t    .module('material.components.icon' )\n\t    .provider('$mdIcon', MdIconProvider);\n\t\n\t  /**\n\t    * @ngdoc service\n\t    * @name $mdIconProvider\n\t    * @module material.components.icon\n\t    *\n\t    * @description\n\t    * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow\n\t    * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`\n\t    * directives are compiled.\n\t    *\n\t    * If using font-icons, the developer is repsonsible for loading the fonts.\n\t    *\n\t    * If using SVGs, loading of the actual svg files are deferred to on-demand requests and are loaded\n\t    * internally by the `$mdIcon` service using the `$http` service. When an SVG is requested by name/ID,\n\t    * the `$mdIcon` service searches its registry for the associated source URL;\n\t    * that URL is used to on-demand load and parse the SVG dynamically.\n\t    *\n\t    * @usage\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Configure URLs for icons specified by [set:]id.\n\t    *\n\t    *     $mdIconProvider\n\t    *          .defaultFontSet( 'fontawesome' )\n\t    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons\n\t    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs\n\t    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n\t    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n\t    *   });\n\t    * </hljs>\n\t    *\n\t    * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime\n\t    * **startup** process (shown below):\n\t    *\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Register a default set of SVG icon definitions\n\t    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')\n\t    *\n\t    *   })\n\t    *   .run(function($http, $templateCache){\n\t    *\n\t    *     // Pre-fetch icons sources by URL and cache in the $templateCache...\n\t    *     // subsequent $http calls will look there first.\n\t    *\n\t    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];\n\t    *\n\t    *     angular.forEach(urls, function(url) {\n\t    *       $http.get(url, {cache: $templateCache});\n\t    *     });\n\t    *\n\t    *   });\n\t    *\n\t    * </hljs>\n\t    *\n\t    * NOTE: the loaded SVG data is subsequently cached internally for future requests.\n\t    *\n\t    */\n\t\n\t   /**\n\t    * @ngdoc method\n\t    * @name $mdIconProvider#icon\n\t    *\n\t    * @description\n\t    * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.\n\t    * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`\n\t    *\n\t    * @param {string} id Icon name/id used to register the icon\n\t    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n\t    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n\t    * @param {number=} viewBoxSize Sets the width and height the icon's viewBox.\n\t    * It is ignored for icons with an existing viewBox. Default size is 24.\n\t    *\n\t    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n\t    *\n\t    * @usage\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Configure URLs for icons specified by [set:]id.\n\t    *\n\t    *     $mdIconProvider\n\t    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n\t    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n\t    *   });\n\t    * </hljs>\n\t    *\n\t    */\n\t   /**\n\t    * @ngdoc method\n\t    * @name $mdIconProvider#iconSet\n\t    *\n\t    * @description\n\t    * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition\n\t    * has an icon id. Individual icons can be subsequently retrieved from this cached set using\n\t    * `$mdIcon(<icon set name>:<icon name>)`\n\t    *\n\t    * @param {string} id Icon name/id used to register the iconset\n\t    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n\t    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n\t    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set. \n\t    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.\n\t    * Default value is 24.\n\t    *\n\t    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n\t    *\n\t    *\n\t    * @usage\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Configure URLs for icons specified by [set:]id.\n\t    *\n\t    *     $mdIconProvider\n\t    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set\n\t    *   });\n\t    * </hljs>\n\t    *\n\t    */\n\t   /**\n\t    * @ngdoc method\n\t    * @name $mdIconProvider#defaultIconSet\n\t    *\n\t    * @description\n\t    * Register a source URL for the default 'named' set of icons. Unless explicitly registered,\n\t    * subsequent lookups of icons will failover to search this 'default' icon set.\n\t    * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`\n\t    *\n\t    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n\t    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n\t    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set. \n\t    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.\n\t    * Default value is 24.\n\t    *\n\t    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n\t    *\n\t    * @usage\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Configure URLs for icons specified by [set:]id.\n\t    *\n\t    *     $mdIconProvider\n\t    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set\n\t    *   });\n\t    * </hljs>\n\t    *\n\t    */\n\t  /**\n\t   * @ngdoc method\n\t   * @name $mdIconProvider#defaultFontSet\n\t   *\n\t   * @description\n\t   * When using Font-Icons, Angular Material assumes the the Material Design icons will be used and automatically\n\t   * configures the default font-set == 'material-icons'. Note that the font-set references the font-icon library\n\t   * class style that should be applied to the `<md-icon>`.\n\t   *\n\t   * Configuring the default means that the attributes\n\t   * `md-font-set=\"material-icons\"` or `class=\"material-icons\"` do not need to be explicitly declared on the\n\t   * `<md-icon>` markup. For example:\n\t   *\n\t   *  `<md-icon> face </md-icon>`\n\t   *  will render as\n\t   *  `<span class=\"material-icons\"> face </span>`, and\n\t   *\n\t   *  `<md-icon md-font-set=\"fa\"> face </md-icon>`\n\t   *  will render as\n\t   *  `<span class=\"fa\"> face </span>`\n\t   *\n\t   * @param {string} name of the font-library style that should be applied to the md-icon DOM element\n\t   *\n\t   * @usage\n\t   * <hljs lang=\"js\">\n\t   *   app.config(function($mdIconProvider) {\n\t   *     $mdIconProvider.defaultFontSet( 'fontawesome' );\n\t   *   });\n\t   * </hljs>\n\t   *\n\t   */\n\t\n\t   /**\n\t    * @ngdoc method\n\t    * @name $mdIconProvider#defaultViewBoxSize\n\t    *\n\t    * @description\n\t    * While `<md-icon />` markup can also be style with sizing CSS, this method configures\n\t    * the default width **and** height used for all icons; unless overridden by specific CSS.\n\t    * The default sizing is (24px, 24px).\n\t    * @param {number=} viewBoxSize Sets the width and height of the viewBox for an icon or an icon set.\n\t    * All icons in a set should be the same size. The default value is 24.\n\t    *\n\t    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n\t    *\n\t    * @usage\n\t    * <hljs lang=\"js\">\n\t    *   app.config(function($mdIconProvider) {\n\t    *\n\t    *     // Configure URLs for icons specified by [set:]id.\n\t    *\n\t    *     $mdIconProvider\n\t    *          .defaultViewBoxSize(36)   // Register a default icon size (width == height)\n\t    *   });\n\t    * </hljs>\n\t    *\n\t    */\n\t\n\t var config = {\n\t   defaultViewBoxSize: 24,\n\t   defaultFontSet: 'material-icons',\n\t   fontSets : [ ]\n\t };\n\t\n\t function MdIconProvider() { }\n\t\n\t MdIconProvider.prototype = {\n\t   icon : function (id, url, viewBoxSize) {\n\t     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\t\n\t     config[id] = new ConfigurationItem(url, viewBoxSize );\n\t     return this;\n\t   },\n\t\n\t   iconSet : function (id, url, viewBoxSize) {\n\t     config[id] = new ConfigurationItem(url, viewBoxSize );\n\t     return this;\n\t   },\n\t\n\t   defaultIconSet : function (url, viewBoxSize) {\n\t     var setName = '$default';\n\t\n\t     if ( !config[setName] ) {\n\t       config[setName] = new ConfigurationItem(url, viewBoxSize );\n\t     }\n\t\n\t     config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;\n\t\n\t     return this;\n\t   },\n\t\n\t   defaultViewBoxSize : function (viewBoxSize) {\n\t     config.defaultViewBoxSize = viewBoxSize;\n\t     return this;\n\t   },\n\t   \n\t   /**\n\t    * Register an alias name associated with a font-icon library style ;\n\t    */\n\t   fontSet : function fontSet(alias, className) {\n\t    config.fontSets.push({\n\t      alias : alias,\n\t      fontSet : className || alias\n\t    });\n\t   },\n\t\n\t   /**\n\t    * Specify a default style name associated with a font-icon library\n\t    * fallback to Material Icons.\n\t    *\n\t    */\n\t   defaultFontSet : function defaultFontSet(className) {\n\t    config.defaultFontSet = !className ? '' : className;\n\t    return this;\n\t   },\n\t\n\t   defaultIconSize : function defaultIconSize(iconSize) {\n\t     config.defaultIconSize = iconSize;\n\t     return this;\n\t   },\n\t\n\t   preloadIcons: function ($templateCache) {\n\t     var iconProvider = this;\n\t     var svgRegistry = [\n\t       {\n\t         id : 'md-tabs-arrow',\n\t         url: 'md-tabs-arrow.svg',\n\t         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><polygon points=\"15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 \"/></g></svg>'\n\t       },\n\t       {\n\t         id : 'md-close',\n\t         url: 'md-close.svg',\n\t         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z\"/></g></svg>'\n\t       },\n\t       {\n\t         id:  'md-cancel',\n\t         url: 'md-cancel.svg',\n\t         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z\"/></g></svg>'\n\t       },\n\t       {\n\t         id:  'md-menu',\n\t         url: 'md-menu.svg',\n\t         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\"><path d=\"M 50 0 L 100 14 L 92 80 L 50 100 L 8 80 L 0 14 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 5 L 6 18 L 13.5 77 L 50 94 Z\" fill=\"#E42939\"></path><path d=\"M 50 5 L 94 18 L 86.5 77 L 50 94 Z\" fill=\"#B72833\"></path><path d=\"M 50 7 L 83 75 L 72 75 L 65 59 L 50 59 L 50 50 L 61 50 L 50 26 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 7 L 17 75 L 28 75 L 35 59 L 50 59 L 50 50 L 39 50 L 50 26 Z\" fill=\"#fff\"></path></svg>'\n\t       },\n\t       {\n\t         id:  'md-toggle-arrow',\n\t         url: 'md-toggle-arrow-svg',\n\t         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 48 48\"><path d=\"M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z\"/><path d=\"M0 0h48v48h-48z\" fill=\"none\"/></svg>'\n\t       }\n\t     ];\n\t\n\t     svgRegistry.forEach(function(asset){\n\t       iconProvider.icon(asset.id,  asset.url);\n\t       $templateCache.put(asset.url, asset.svg);\n\t     });\n\t\n\t   },\n\t\n\t   $get : ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {\n\t     this.preloadIcons($templateCache);\n\t     return MdIconService(config, $http, $q, $log, $templateCache);\n\t   }]\n\t };\n\t\n\t   /**\n\t    *  Configuration item stored in the Icon registry; used for lookups\n\t    *  to load if not already cached in the `loaded` cache\n\t    */\n\t   function ConfigurationItem(url, viewBoxSize) {\n\t     this.url = url;\n\t     this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;\n\t   }\n\t\n\t /**\n\t  * @ngdoc service\n\t  * @name $mdIcon\n\t  * @module material.components.icon\n\t  *\n\t  * @description\n\t  * The `$mdIcon` service is a function used to lookup SVG icons.\n\t  *\n\t  * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element\n\t  * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is\n\t  * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.\n\t  *\n\t  * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured\n\t  * using the `$mdIconProvider`.\n\t  *\n\t  * @returns {obj} Clone of the initial SVG DOM element; which was created from the SVG markup in the SVG data file.\n\t  *\n\t  * @usage\n\t  * <hljs lang=\"js\">\n\t  * function SomeDirective($mdIcon) {\n\t  *\n\t  *   // See if the icon has already been loaded, if not\n\t  *   // then lookup the icon from the registry cache, load and cache\n\t  *   // it for future requests.\n\t  *   // NOTE: ID queries require configuration with $mdIconProvider\n\t  *\n\t  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });\n\t  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });\n\t  *\n\t  *   // Load and cache the external SVG using a URL\n\t  *\n\t  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {\n\t  *     element.append(iconEl);\n\t  *   });\n\t  * };\n\t  * </hljs>\n\t  *\n\t  * NOTE: The `<md-icon />  ` directive internally uses the `$mdIcon` service to query, loaded, and instantiate\n\t  * SVG DOM elements.\n\t  */\n\t function MdIconService(config, $http, $q, $log, $templateCache) {\n\t   var iconCache = {};\n\t   var urlRegex = /[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,4}\\b(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?/i;\n\t\n\t   Icon.prototype = { clone : cloneSVG, prepare: prepareAndStyle };\n\t   getIcon.fontSet = findRegisteredFontSet;\n\t\n\t   // Publish service...\n\t   return getIcon;\n\t\n\t   /**\n\t    * Actual $mdIcon service is essentially a lookup function\n\t    */\n\t   function getIcon(id) {\n\t     id = id || '';\n\t\n\t     // If already loaded and cached, use a clone of the cached icon.\n\t     // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.\n\t\n\t     if ( iconCache[id]         ) return $q.when( iconCache[id].clone() );\n\t     if ( urlRegex.test(id)     ) return loadByURL(id).then( cacheIcon(id) );\n\t     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\t\n\t     return loadByID(id)\n\t         .catch(loadFromIconSet)\n\t         .catch(announceIdNotFound)\n\t         .catch(announceNotFound)\n\t         .then( cacheIcon(id) );\n\t   }\n\t\n\t   /**\n\t    * Lookup registered fontSet style using its alias...\n\t    * If not found,\n\t    */\n\t   function findRegisteredFontSet(alias) {\n\t      var useDefault = angular.isUndefined(alias) || !(alias && alias.length);\n\t      if ( useDefault ) return config.defaultFontSet;\n\t\n\t      var result = alias;\n\t      angular.forEach(config.fontSets, function(it){\n\t        if ( it.alias == alias ) result = it.fontSet || result;\n\t      });\n\t\n\t      return result;\n\t   }\n\t\n\t   /**\n\t    * Prepare and cache the loaded icon for the specified `id`\n\t    */\n\t   function cacheIcon( id ) {\n\t\n\t     return function updateCache( icon ) {\n\t       iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);\n\t\n\t       return iconCache[id].clone();\n\t     };\n\t   }\n\t\n\t   /**\n\t    * Lookup the configuration in the registry, if !registered throw an error\n\t    * otherwise load the icon [on-demand] using the registered URL.\n\t    *\n\t    */\n\t   function loadByID(id) {\n\t     var iconConfig = config[id];\n\t\n\t     return !iconConfig ? $q.reject(id) : loadByURL(iconConfig.url).then(function(icon) {\n\t       return new Icon(icon, iconConfig);\n\t     });\n\t   }\n\t\n\t   /**\n\t    *    Loads the file as XML and uses querySelector( <id> ) to find\n\t    *    the desired node...\n\t    */\n\t   function loadFromIconSet(id) {\n\t     var setName = id.substring(0, id.lastIndexOf(':')) || '$default';\n\t     var iconSetConfig = config[setName];\n\t\n\t     return !iconSetConfig ? $q.reject(id) : loadByURL(iconSetConfig.url).then(extractFromSet);\n\t\n\t     function extractFromSet(set) {\n\t       var iconName = id.slice(id.lastIndexOf(':') + 1);\n\t       var icon = set.querySelector('#' + iconName);\n\t       return !icon ? $q.reject(id) : new Icon(icon, iconSetConfig);\n\t     }\n\t   }\n\t\n\t   /**\n\t    * Load the icon by URL (may use the $templateCache).\n\t    * Extract the data for later conversion to Icon\n\t    */\n\t   function loadByURL(url) {\n\t     return $http\n\t       .get(url, { cache: $templateCache })\n\t       .then(function(response) {\n\t         return angular.element('<div>').append(response.data).find('svg')[0];\n\t       });\n\t   }\n\t\n\t   /**\n\t    * User did not specify a URL and the ID has not been registered with the $mdIcon\n\t    * registry\n\t    */\n\t   function announceIdNotFound(id) {\n\t     var msg;\n\t\n\t     if (angular.isString(id)) {\n\t       msg = 'icon ' + id + ' not found';\n\t       $log.warn(msg);\n\t     }\n\t\n\t     return $q.reject(msg || id);\n\t   }\n\t\n\t   /**\n\t    * Catch HTTP or generic errors not related to incorrect icon IDs.\n\t    */\n\t   function announceNotFound(err) {\n\t     var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);\n\t     $log.warn(msg);\n\t\n\t     return $q.reject(msg);\n\t   }\n\t\n\t   /**\n\t    * Check target signature to see if it is an Icon instance.\n\t    */\n\t   function isIcon(target) {\n\t     return angular.isDefined(target.element) && angular.isDefined(target.config);\n\t   }\n\t\n\t   /**\n\t    *  Define the Icon class\n\t    */\n\t   function Icon(el, config) {\n\t     if (el.tagName != 'svg') {\n\t       el = angular.element('<svg xmlns=\"http://www.w3.org/2000/svg\">').append(el)[0];\n\t     }\n\t\n\t     // Inject the namespace if not available...\n\t     if ( !el.getAttribute('xmlns') ) {\n\t       el.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n\t     }\n\t\n\t     this.element = el;\n\t     this.config = config;\n\t     this.prepare();\n\t   }\n\t\n\t   /**\n\t    *  Prepare the DOM element that will be cached in the\n\t    *  loaded iconCache store.\n\t    */\n\t   function prepareAndStyle() {\n\t     var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;\n\t         angular.forEach({\n\t           'fit'   : '',\n\t           'height': '100%',\n\t           'width' : '100%',\n\t           'preserveAspectRatio': 'xMidYMid meet',\n\t           'viewBox' : this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize)\n\t         }, function(val, attr) {\n\t           this.element.setAttribute(attr, val);\n\t         }, this);\n\t\n\t         angular.forEach({\n\t           'pointer-events' : 'none',\n\t           'display' : 'block'\n\t         }, function(val, style) {\n\t           this.element.style[style] = val;\n\t         }, this);\n\t   }\n\t\n\t   /**\n\t    * Clone the Icon DOM element.\n\t    */\n\t   function cloneSVG(){\n\t     return this.element.cloneNode(true);\n\t   }\n\t\n\t }\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.input\n\t */\n\t\n\tangular.module('material.components.input', [\n\t  'material.core'\n\t])\n\t  .directive('mdInputContainer', mdInputContainerDirective)\n\t  .directive('label', labelDirective)\n\t  .directive('input', inputTextareaDirective)\n\t  .directive('textarea', inputTextareaDirective)\n\t  .directive('mdMaxlength', mdMaxlengthDirective)\n\t  .directive('placeholder', placeholderDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdInputContainer\n\t * @module material.components.input\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * `<md-input-container>` is the parent of any input or textarea element.\n\t *\n\t * Input and textarea elements will not behave properly unless the md-input-container\n\t * parent is provided.\n\t *\n\t * @param md-is-error {expression=} When the given expression evaluates to true, the input container will go into error state. Defaults to erroring if the input has been touched and is invalid.\n\t * @param md-no-float {boolean=} When present, placeholders will not be converted to floating labels\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t *\n\t * <md-input-container>\n\t *   <label>Username</label>\n\t *   <input type=\"text\" ng-model=\"user.name\">\n\t * </md-input-container>\n\t *\n\t * <md-input-container>\n\t *   <label>Description</label>\n\t *   <textarea ng-model=\"user.description\"></textarea>\n\t * </md-input-container>\n\t *\n\t * </hljs>\n\t */\n\tfunction mdInputContainerDirective($mdTheming, $parse) {\n\t  ContainerCtrl.$inject = [\"$scope\", \"$element\", \"$attrs\"];\n\t  return {\n\t    restrict: 'E',\n\t    link: postLink,\n\t    controller: ContainerCtrl\n\t  };\n\t\n\t  function postLink(scope, element, attr) {\n\t    $mdTheming(element);\n\t  }\n\t  function ContainerCtrl($scope, $element, $attrs) {\n\t    var self = this;\n\t\n\t    self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);\n\t\n\t    self.delegateClick = function() {\n\t      self.input.focus();\n\t    };\n\t    self.element = $element;\n\t    self.setFocused = function(isFocused) {\n\t      $element.toggleClass('md-input-focused', !!isFocused);\n\t    };\n\t    self.setHasValue = function(hasValue) {\n\t      $element.toggleClass('md-input-has-value', !!hasValue);\n\t    };\n\t    self.setInvalid = function(isInvalid) {\n\t      $element.toggleClass('md-input-invalid', !!isInvalid);\n\t    };\n\t    $scope.$watch(function() {\n\t      return self.label && self.input;\n\t    }, function(hasLabelAndInput) {\n\t      if (hasLabelAndInput && !self.label.attr('for')) {\n\t        self.label.attr('for', self.input.attr('id'));\n\t      }\n\t    });\n\t  }\n\t}\n\tmdInputContainerDirective.$inject = [\"$mdTheming\", \"$parse\"];\n\t\n\tfunction labelDirective() {\n\t  return {\n\t    restrict: 'E',\n\t    require: '^?mdInputContainer',\n\t    link: function(scope, element, attr, containerCtrl) {\n\t      if (!containerCtrl || attr.mdNoFloat) return;\n\t\n\t      containerCtrl.label = element;\n\t      scope.$on('$destroy', function() {\n\t        containerCtrl.label = null;\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdInput\n\t * @restrict E\n\t * @module material.components.input\n\t *\n\t * @description\n\t * Use the `<input>` or the  `<textarea>` as a child of an `<md-input-container>`.\n\t *\n\t * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is specified, a character counter will be shown underneath the input.<br/><br/>\n\t * The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't want the counter text and only need \"plain\" validation, you can use the \"simple\" `ng-maxlength` or maxlength attributes.\n\t * @param {string=} aria-label Aria-label is required when no label is present.  A warning message will be logged in the console if not present.\n\t * @param {string=} placeholder An alternative approach to using aria-label when the label is not present.  The placeholder text is copied to the aria-label attribute.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-input-container>\n\t *   <label>Color</label>\n\t *   <input type=\"text\" ng-model=\"color\" required md-maxlength=\"10\">\n\t * </md-input-container>\n\t * </hljs>\n\t * <h3>With Errors</h3>\n\t *\n\t * <hljs lang=\"html\">\n\t * <form name=\"userForm\">\n\t *   <md-input-container>\n\t *     <label>Last Name</label>\n\t *     <input name=\"lastName\" ng-model=\"lastName\" required md-maxlength=\"10\" minlength=\"4\">\n\t *     <div ng-messages=\"userForm.lastName.$error\" ng-show=\"userForm.lastName.$dirty\">\n\t *       <div ng-message=\"required\">This is required!</div>\n\t *       <div ng-message=\"md-maxlength\">That's too long!</div>\n\t *       <div ng-message=\"minlength\">That's too short!</div>\n\t *     </div>\n\t *   </md-input-container>\n\t *   <md-input-container>\n\t *     <label>Biography</label>\n\t *     <textarea name=\"bio\" ng-model=\"biography\" required md-maxlength=\"150\"></textarea>\n\t *     <div ng-messages=\"userForm.bio.$error\" ng-show=\"userForm.bio.$dirty\">\n\t *       <div ng-message=\"required\">This is required!</div>\n\t *       <div ng-message=\"md-maxlength\">That's too long!</div>\n\t *     </div>\n\t *   </md-input-container>\n\t *   <md-input-container>\n\t *     <input aria-label='title' ng-model='title'>\n\t *   </md-input-container>\n\t *   <md-input-container>\n\t *     <input placeholder='title' ng-model='title'>\n\t *   </md-input-container>\n\t * </form>\n\t * </hljs>\n\t *\n\t * Requires [ngMessages](https://docs.angularjs.org/api/ngMessages).\n\t * Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).\n\t *\n\t */\n\t\n\tfunction inputTextareaDirective($mdUtil, $window, $mdAria) {\n\t  return {\n\t    restrict: 'E',\n\t    require: ['^?mdInputContainer', '?ngModel'],\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr, ctrls) {\n\t\n\t    var containerCtrl = ctrls[0];\n\t    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n\t    var isReadonly = angular.isDefined(attr.readonly);\n\t\n\t    if ( !containerCtrl ) return;\n\t    if (containerCtrl.input) {\n\t      throw new Error(\"<md-input-container> can only have *one* <input> or <textarea> child element!\");\n\t    }\n\t    containerCtrl.input = element;\n\t\n\t    if(!containerCtrl.label) {\n\t      $mdAria.expect(element, 'aria-label', element.attr('placeholder'));\n\t    }\n\t\n\t    element.addClass('md-input');\n\t    if (!element.attr('id')) {\n\t      element.attr('id', 'input_' + $mdUtil.nextUid());\n\t    }\n\t\n\t    if (element[0].tagName.toLowerCase() === 'textarea') {\n\t      setupTextarea();\n\t    }\n\t\n\t    var isErrorGetter = containerCtrl.isErrorGetter || function() {\n\t      return ngModelCtrl.$invalid && ngModelCtrl.$touched;\n\t    };\n\t    scope.$watch(isErrorGetter, containerCtrl.setInvalid);\n\t\n\t    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);\n\t    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);\n\t\n\t    element.on('input', inputCheckValue);\n\t\n\t    if (!isReadonly) {\n\t      element\n\t        .on('focus', function(ev) {\n\t          containerCtrl.setFocused(true);\n\t        })\n\t        .on('blur', function(ev) {\n\t          containerCtrl.setFocused(false);\n\t          inputCheckValue();\n\t        });\n\t\n\t    }\n\t\n\t    //ngModelCtrl.$setTouched();\n\t    //if( ngModelCtrl.$invalid ) containerCtrl.setInvalid();\n\t\n\t    scope.$on('$destroy', function() {\n\t      containerCtrl.setFocused(false);\n\t      containerCtrl.setHasValue(false);\n\t      containerCtrl.input = null;\n\t    });\n\t\n\t    /**\n\t     *\n\t     */\n\t    function ngModelPipelineCheckValue(arg) {\n\t      containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));\n\t      return arg;\n\t    }\n\t    function inputCheckValue() {\n\t      // An input's value counts if its length > 0,\n\t      // or if the input's validity state says it has bad input (eg string in a number input)\n\t      containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity||{}).badInput);\n\t    }\n\t\n\t    function setupTextarea() {\n\t      var node = element[0];\n\t      var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);\n\t\n\t      function pipelineListener(value) {\n\t        onChangeTextarea();\n\t        return value;\n\t      }\n\t\n\t      if (ngModelCtrl) {\n\t        ngModelCtrl.$formatters.push(pipelineListener);\n\t        ngModelCtrl.$viewChangeListeners.push(pipelineListener);\n\t      } else {\n\t        onChangeTextarea();\n\t      }\n\t      element.on('keydown input', onChangeTextarea);\n\t      element.on('scroll', onScroll);\n\t      angular.element($window).on('resize', onChangeTextarea);\n\t\n\t      scope.$on('$destroy', function() {\n\t        angular.element($window).off('resize', onChangeTextarea);\n\t      });\n\t\n\t      function growTextarea() {\n\t        node.style.height = \"auto\";\n\t        node.scrollTop = 0;\n\t        var height = getHeight();\n\t        if (height) node.style.height = height + 'px';\n\t      }\n\t\n\t      function getHeight () {\n\t        var line = node.scrollHeight - node.offsetHeight;\n\t        return node.offsetHeight + (line > 0 ? line : 0);\n\t      }\n\t\n\t      function onScroll(e) {\n\t        node.scrollTop = 0;\n\t        // for smooth new line adding\n\t        var line = node.scrollHeight - node.offsetHeight;\n\t        var height = node.offsetHeight + line;\n\t        node.style.height = height + 'px';\n\t      }\n\t    }\n\t  }\n\t}\n\tinputTextareaDirective.$inject = [\"$mdUtil\", \"$window\", \"$mdAria\"];\n\t\n\tfunction mdMaxlengthDirective($animate) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['ngModel', '^mdInputContainer'],\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr, ctrls) {\n\t    var maxlength;\n\t    var ngModelCtrl = ctrls[0];\n\t    var containerCtrl = ctrls[1];\n\t    var charCountEl = angular.element('<div class=\"md-char-counter\">');\n\t\n\t    // Stop model from trimming. This makes it so whitespace\n\t    // over the maxlength still counts as invalid.\n\t    attr.$set('ngTrim', 'false');\n\t    containerCtrl.element.append(charCountEl);\n\t\n\t    ngModelCtrl.$formatters.push(renderCharCount);\n\t    ngModelCtrl.$viewChangeListeners.push(renderCharCount);\n\t    element.on('input keydown', function() {\n\t      renderCharCount(); //make sure it's called with no args\n\t    });\n\t\n\t    scope.$watch(attr.mdMaxlength, function(value) {\n\t      maxlength = value;\n\t      if (angular.isNumber(value) && value > 0) {\n\t        if (!charCountEl.parent().length) {\n\t          $animate.enter(charCountEl, containerCtrl.element,\n\t                         angular.element(containerCtrl.element[0].lastElementChild));\n\t        }\n\t        renderCharCount();\n\t      } else {\n\t        $animate.leave(charCountEl);\n\t      }\n\t    });\n\t\n\t    ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {\n\t      if (!angular.isNumber(maxlength) || maxlength < 0) {\n\t        return true;\n\t      }\n\t      return ( modelValue || element.val() || viewValue || '' ).length <= maxlength;\n\t    };\n\t\n\t    function renderCharCount(value) {\n\t      charCountEl.text( ( element.val() || value || '' ).length + '/' + maxlength );\n\t      return value;\n\t    }\n\t  }\n\t}\n\tmdMaxlengthDirective.$inject = [\"$animate\"];\n\t\n\tfunction placeholderDirective($log) {\n\t  var blackListElements = ['MD-SELECT'];\n\t  return {\n\t    restrict: 'A',\n\t    require: '^^?mdInputContainer',\n\t    priority: 200,\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr, inputContainer) {\n\t    if (!inputContainer) return;\n\t    if (blackListElements.indexOf(element[0].nodeName) != -1) return;\n\t    if (angular.isDefined(inputContainer.element.attr('md-no-float'))) return;\n\t\n\t    var placeholderText = attr.placeholder;\n\t    element.removeAttr('placeholder');\n\t\n\t    if ( inputContainer.element.find('label').length == 0 ) {\n\t      var placeholder = '<label ng-click=\"delegateClick()\">' + placeholderText + '</label>';\n\t\n\t      inputContainer.element.addClass('md-icon-float');\n\t      inputContainer.element.prepend(placeholder);\n\t    } else {\n\t      $log.warn(\"The placeholder='\" + placeholderText + \"' will be ignored since this md-input-container has a child label element.\");\n\t    }\n\t\n\t  }\n\t}\n\tplaceholderDirective.$inject = [\"$log\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.list\n\t * @description\n\t * List module\n\t */\n\tangular.module('material.components.list', [\n\t  'material.core'\n\t])\n\t  .controller('MdListController', MdListController)\n\t  .directive('mdList', mdListDirective)\n\t  .directive('mdListItem', mdListItemDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdList\n\t * @module material.components.list\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-list>\n\t *   <md-list-item class=\"md-2-line\" ng-repeat=\"item in todos\">\n\t *     <md-checkbox ng-model=\"item.done\"></md-checkbox>\n\t *     <div class=\"md-list-item-text\">\n\t *       <h3>{{item.title}}</h3>\n\t *       <p>{{item.description}}</p>\n\t *     </div>\n\t *   </md-list-item>\n\t * </md-list>\n\t * </hljs>\n\t */\n\t\n\tfunction mdListDirective($mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    compile: function(tEl) {\n\t      tEl[0].setAttribute('role', 'list');\n\t      return $mdTheming;\n\t    }\n\t  };\n\t}\n\tmdListDirective.$inject = [\"$mdTheming\"];\n\t/**\n\t * @ngdoc directive\n\t * @name mdListItem\n\t * @module material.components.list\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-list-item>` directive is a container intended for row items in a `<md-list>` container.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t *  <md-list>\n\t *    <md-list-item>\n\t *            Item content in list\n\t *    </md-list-item>\n\t *  </md-list>\n\t * </hljs>\n\t *\n\t */\n\tfunction mdListItemDirective($mdAria, $mdConstant, $timeout) {\n\t  var proxiedTypes = ['md-checkbox', 'md-switch'];\n\t  return {\n\t    restrict: 'E',\n\t    controller: 'MdListController',\n\t    compile: function(tEl, tAttrs) {\n\t      // Check for proxy controls (no ng-click on parent, and a control inside)\n\t      var secondaryItem = tEl[0].querySelector('.md-secondary');\n\t      var hasProxiedElement;\n\t      var proxyElement;\n\t\n\t      tEl[0].setAttribute('role', 'listitem');\n\t\n\t      if (!tAttrs.ngClick) {\n\t        for (var i = 0, type; type = proxiedTypes[i]; ++i) {\n\t          if (proxyElement = tEl[0].querySelector(type)) {\n\t            hasProxiedElement = true;\n\t            break;\n\t          }\n\t        }\n\t        if (hasProxiedElement) {\n\t          wrapIn('div');\n\t        } else if (!tEl[0].querySelector('md-button')) {\n\t          tEl.addClass('md-no-proxy');\n\t        }\n\t      } else {\n\t        wrapIn('button');\n\t      }\n\t      setupToggleAria();\n\t\n\t\n\t      function setupToggleAria() {\n\t        var toggleTypes = ['md-switch', 'md-checkbox'];\n\t        var toggle;\n\t\n\t        for (var i = 0, toggleType; toggleType = toggleTypes[i]; ++i) {\n\t          if (toggle = tEl.find(toggleType)[0]) {\n\t            if (!toggle.hasAttribute('aria-label')) {\n\t              var p = tEl.find('p')[0];\n\t              if (!p) return;\n\t              toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      function wrapIn(type) {\n\t        var container;\n\t        if (type == 'div') {\n\t          container = angular.element('<div class=\"md-no-style md-list-item-inner\">');\n\t          container.append(tEl.contents());\n\t          tEl.addClass('md-proxy-focus');\n\t        } else {\n\t          container = angular.element('<md-button class=\"md-no-style\"><div class=\"md-list-item-inner\"></div></md-button>');\n\t          var copiedAttrs = ['ng-click', 'aria-label', 'ng-disabled'];\n\t          angular.forEach(copiedAttrs, function(attr) {\n\t            if (tEl[0].hasAttribute(attr)) {\n\t              container[0].setAttribute(attr, tEl[0].getAttribute(attr));\n\t              tEl[0].removeAttribute(attr);\n\t            }\n\t          });\n\t          container.children().eq(0).append(tEl.contents());\n\t        }\n\t\n\t        tEl[0].setAttribute('tabindex', '-1');\n\t        tEl.append(container);\n\t\n\t        if (secondaryItem && secondaryItem.hasAttribute('ng-click')) {\n\t          $mdAria.expect(secondaryItem, 'aria-label');\n\t          var buttonWrapper = angular.element('<md-button class=\"md-secondary-container md-icon-button\">');\n\t          buttonWrapper.attr('ng-click', secondaryItem.getAttribute('ng-click'));\n\t          secondaryItem.removeAttribute('ng-click');\n\t          secondaryItem.setAttribute('tabindex', '-1');\n\t          secondaryItem.classList.remove('md-secondary');\n\t          buttonWrapper.append(secondaryItem);\n\t          secondaryItem = buttonWrapper[0];\n\t        }\n\t\n\t        // Check for a secondary item and move it outside\n\t        if ( secondaryItem && (\n\t          secondaryItem.hasAttribute('ng-click') ||\n\t            ( tAttrs.ngClick &&\n\t             isProxiedElement(secondaryItem) )\n\t        )) {\n\t          tEl.addClass('md-with-secondary');\n\t          tEl.append(secondaryItem);\n\t        }\n\t      }\n\t\n\t      function isProxiedElement(el) {\n\t        return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;\n\t      }\n\t\n\t      return postLink;\n\t\n\t      function postLink($scope, $element, $attr, ctrl) {\n\t\n\t        var proxies    = [],\n\t            firstChild = $element[0].firstElementChild,\n\t            hasClick   = firstChild && firstChild.hasAttribute('ng-click');\n\t\n\t        computeProxies();\n\t        computeClickable();\n\t\n\t        if ($element.hasClass('md-proxy-focus') && proxies.length) {\n\t          angular.forEach(proxies, function(proxy) {\n\t            proxy = angular.element(proxy);\n\t\n\t            $scope.mouseActive = false;\n\t            proxy.on('mousedown', function() {\n\t              $scope.mouseActive = true;\n\t              $timeout(function(){\n\t                $scope.mouseActive = false;\n\t              }, 100);\n\t            })\n\t            .on('focus', function() {\n\t              if ($scope.mouseActive === false) { $element.addClass('md-focused'); }\n\t              proxy.on('blur', function proxyOnBlur() {\n\t                $element.removeClass('md-focused');\n\t                proxy.off('blur', proxyOnBlur);\n\t              });\n\t            });\n\t          });\n\t        }\n\t\n\t        function computeProxies() {\n\t          var children = $element.children();\n\t          if (children.length && !children[0].hasAttribute('ng-click')) {\n\t            angular.forEach(proxiedTypes, function(type) {\n\t              angular.forEach(firstChild.querySelectorAll(type), function(child) {\n\t                proxies.push(child);\n\t              });\n\t            });\n\t          }\n\t        }\n\t        function computeClickable() {\n\t          if (proxies.length || hasClick) {\n\t            $element.addClass('md-clickable');\n\t\n\t            ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));\n\t          }\n\t        }\n\t\n\t        if (!hasClick && !proxies.length) {\n\t          firstChild && firstChild.addEventListener('keypress', function(e) {\n\t            if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA') {\n\t              var keyCode = e.which || e.keyCode;\n\t              if (keyCode == $mdConstant.KEY_CODE.SPACE) {\n\t                if (firstChild) {\n\t                  firstChild.click();\n\t                  e.preventDefault();\n\t                  e.stopPropagation();\n\t                }\n\t              }\n\t            }\n\t          });\n\t        }\n\t\n\t        $element.off('click');\n\t        $element.off('keypress');\n\t\n\t        if (proxies.length && firstChild) {\n\t          $element.children().eq(0).on('click', function(e) {\n\t            if (firstChild.contains(e.target)) {\n\t              angular.forEach(proxies, function(proxy) {\n\t                if (e.target !== proxy && !proxy.contains(e.target)) {\n\t                  angular.element(proxy).triggerHandler('click');\n\t                }\n\t              });\n\t            }\n\t          });\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\tmdListItemDirective.$inject = [\"$mdAria\", \"$mdConstant\", \"$timeout\"];\n\t\n\t/*\n\t * @private\n\t * @ngdoc controller\n\t * @name MdListController\n\t * @module material.components.list\n\t *\n\t */\n\tfunction MdListController($scope, $element, $mdListInkRipple) {\n\t  var ctrl = this;\n\t  ctrl.attachRipple = attachRipple;\n\t\n\t  function attachRipple (scope, element) {\n\t    var options = {};\n\t    $mdListInkRipple.attach(scope, element, options);\n\t  }\n\t}\n\tMdListController.$inject = [\"$scope\", \"$element\", \"$mdListInkRipple\"];\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.menu\n\t */\n\t\n\tangular.module('material.components.menu', [\n\t  'material.core',\n\t  'material.components.backdrop'\n\t])\n\t.directive('mdMenu', MenuDirective)\n\t.controller('mdMenuCtrl', MenuController);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdMenu\n\t * @module material.components.menu\n\t * @restrict E\n\t * @description\n\t *\n\t * Menus are elements that open when clicked. They are useful for displaying\n\t * additional options within the context of an action.\n\t *\n\t * Every `md-menu` must specify exactly two child elements. The first element is what is\n\t * left in the DOM and is used to open the menu. This element is called the trigger element.\n\t * The trigger element's scope has access to `$mdOpenMenu()`\n\t * which it may call to open the menu.\n\t *\n\t * The second element is the `md-menu-content` element which represents the\n\t * contents of the menu when it is open. Typically this will contain `md-menu-item`s,\n\t * but you can do custom content as well.\n\t *\n\t * <hljs lang=\"html\">\n\t * <md-menu>\n\t *  <!-- Trigger element is a md-button with an icon -->\n\t *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\" aria-label=\"Open sample menu\">\n\t *    <md-icon md-svg-icon=\"call:phone\"></md-icon>\n\t *  </md-button>\n\t *  <md-menu-content>\n\t *    <md-menu-item><md-button ng-click=\"doSomething()\">Do Something</md-button></md-menu-item>\n\t *  </md-menu-content>\n\t * </md-menu>\n\t * </hljs>\n\t\n\t * ## Sizing Menus\n\t *\n\t * The width of the menu when it is open may be specified by specifying a `width`\n\t * attribute on the `md-menu-content` element.\n\t * See the [Material Design Spec](http://www.google.com/design/spec/components/menus.html#menus-specs)\n\t * for more information.\n\t *\n\t *\n\t * ## Aligning Menus\n\t *\n\t * When a menu opens, it is important that the content aligns with the trigger element.\n\t * Failure to align menus can result in jarring experiences for users as content\n\t * suddenly shifts. To help with this, `md-menu` provides serveral APIs to help\n\t * with alignment.\n\t *\n\t * ### Target Mode\n\t *\n\t * By default, `md-menu` will attempt to align the `md-menu-content` by aligning\n\t * designated child elements in both the trigger and the menu content.\n\t *\n\t * To specify the alignment element in the `trigger` you can use the `md-menu-origin`\n\t * attribute on a child element. If no `md-menu-origin` is specified, the `md-menu`\n\t * will be used as the origin element.\n\t *\n\t * Similarly, the `md-menu-content` may specify a `md-menu-align-target` for a\n\t * `md-menu-item` to specify the node that it should try and align with.\n\t *\n\t * In this example code, we specify an icon to be our origin element, and an\n\t * icon in our menu content to be our alignment target. This ensures that both\n\t * icons are aligned when the menu opens.\n\t *\n\t * <hljs lang=\"html\">\n\t * <md-menu>\n\t *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\" aria-label=\"Open some menu\">\n\t *    <md-icon md-menu-origin md-svg-icon=\"call:phone\"></md-icon>\n\t *  </md-button>\n\t *  <md-menu-content>\n\t *    <md-menu-item>\n\t *      <md-button ng-click=\"doSomething()\" aria-label=\"Do something\">\n\t *        <md-icon md-menu-align-target md-svg-icon=\"call:phone\"></md-icon>\n\t *        Do Something\n\t *      </md-button>\n\t *    </md-menu-item>\n\t *  </md-menu-content>\n\t * </md-menu>\n\t * </hljs>\n\t *\n\t * Sometimes we want to specify alignment on the right side of an element, for example\n\t * if we have a menu on the right side a toolbar, we want to right align our menu content.\n\t *\n\t * We can specify the origin by using the `md-position-mode` attribute on both\n\t * the `x` and `y` axis. Right now only the `x-axis` has more than one option.\n\t * You may specify the default mode of `target target` or\n\t * `target-right target` to specify a right-oriented alignment target. See the\n\t * position section of the demos for more examples.\n\t *\n\t * ### Menu Offsets\n\t *\n\t * It is sometimes unavoidable to need to have a deeper level of control for\n\t * the positioning of a menu to ensure perfect alignment. `md-menu` provides\n\t * the `md-offset` attribute to allow pixel level specificty of adjusting the\n\t * exact positioning.\n\t *\n\t * This offset is provided in the format of `x y` or `n` where `n` will be used\n\t * in both the `x` and `y` axis.\n\t *\n\t * For example, to move a menu by `2px` from the top, we can use:\n\t * <hljs lang=\"html\">\n\t * <md-menu md-offset=\"2 0\">\n\t *   <!-- menu-content -->\n\t * </md-menu>\n\t * </hljs>\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-menu>\n\t *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\">\n\t *    <md-icon md-svg-icon=\"call:phone\"></md-icon>\n\t *  </md-button>\n\t *  <md-menu-content>\n\t *    <md-menu-item><md-button ng-click=\"doSomething()\">Do Something</md-button></md-menu-item>\n\t *  </md-menu-content>\n\t * </md-menu>\n\t * </hljs>\n\t *\n\t * @param {string} md-position-mode The position mode in the form of\n\t             `x`, `y`. Default value is `target`,`target`. Right now the `x` axis\n\t             also suppports `target-right`.\n\t * @param {string} md-offset An offset to apply to the dropdown after positioning\n\t             `x`, `y`. Default value is `0`,`0`.\n\t *\n\t */\n\t\n\tfunction MenuDirective($mdMenu) {\n\t  return {\n\t    restrict: 'E',\n\t    require: 'mdMenu',\n\t    controller: 'mdMenuCtrl', // empty function to be built by link\n\t    scope: true,\n\t    compile: compile\n\t  };\n\t\n\t  function compile(templateElement) {\n\t    templateElement.addClass('md-menu');\n\t    var triggerElement = templateElement.children()[0];\n\t    if (!triggerElement.hasAttribute('ng-click')) {\n\t      triggerElement = triggerElement.querySelector('[ng-click]');\n\t    }\n\t    triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');\n\t    if (templateElement.children().length != 2) {\n\t      throw Error('Invalid HTML for md-menu. Expected two children elements.');\n\t    }\n\t    return link;\n\t  }\n\t\n\t  function link(scope, element, attrs, mdMenuCtrl) {\n\t\n\t    // Move everything into a md-menu-container and pass it to the controller\n\t    var menuContainer = angular.element(\n\t      '<div class=\"md-open-menu-container md-whiteframe-z2\"></div>'\n\t    );\n\t    var menuContents = element.children()[1];\n\t    menuContainer.append(menuContents);\n\t    mdMenuCtrl.init(menuContainer);\n\t\n\t    scope.$on('$destroy', function() {\n\t      if (mdMenuCtrl.isOpen) {\n\t        menuContainer.remove();\n\t        mdMenuCtrl.close();\n\t      }\n\t    });\n\t\n\t  }\n\t}\n\tMenuDirective.$inject = [\"$mdMenu\"];\n\t\n\tfunction MenuController($mdMenu, $attrs, $element, $scope) {\n\t\n\t  var menuContainer;\n\t  var ctrl = this;\n\t  var triggerElement;\n\t\n\t  // Called by our linking fn to provide access to the menu-content\n\t  // element removed during link\n\t  this.init = function(setMenuContainer) {\n\t    menuContainer = setMenuContainer;\n\t    triggerElement = $element[0].querySelector('[ng-click]');\n\t  };\n\t\n\t  // Uses the $mdMenu interim element service to open the menu contents\n\t  this.open = function openMenu() {\n\t    ctrl.isOpen = true;\n\t    triggerElement.setAttribute('aria-expanded', 'true');\n\t    $mdMenu.show({\n\t      mdMenuCtrl: ctrl,\n\t      element: menuContainer,\n\t      target: $element[0]\n\t    });\n\t  };\n\t  // Expose a open function to the child scope for html to use\n\t  $scope.$mdOpenMenu = this.open;\n\t\n\t  // Use the $mdMenu interim element service to close the menu contents\n\t  this.close = function closeMenu(skipFocus) {\n\t    ctrl.isOpen = false;\n\t    triggerElement.setAttribute('aria-expanded', 'false');\n\t    $mdMenu.hide();\n\t\n\t    if (!skipFocus) {\n\t      $element.children()[0].focus();\n\t    }\n\t  };\n\t\n\t  // Build a nice object out of our string attribute which specifies the\n\t  // target mode for left and top positioning\n\t  this.positionMode = function() {\n\t    var attachment = ($attrs.mdPositionMode || 'target').split(' ');\n\t\n\t    // If attachment is a single item, duplicate it for our second value.\n\t    // ie. 'target' -> 'target target'\n\t    if (attachment.length == 1) {\n\t      attachment.push(attachment[0]);\n\t    }\n\t\n\t    return {\n\t      left: attachment[0],\n\t      top: attachment[1]\n\t    };\n\t  };\n\t\n\t  // Build a nice object out of our string attribute which specifies\n\t  // the offset of top and left in pixels.\n\t  this.offsets = function() {\n\t    var offsets = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);\n\t    if (offsets.length == 2) {\n\t      return {\n\t        left: offsets[0],\n\t        top: offsets[1]\n\t      };\n\t    } else if (offsets.length == 1) {\n\t      return {\n\t        top: offsets[0],\n\t        left: offsets[0]\n\t      };\n\t    } else {\n\t      throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');\n\t    }\n\t  };\n\t}\n\tMenuController.$inject = [\"$mdMenu\", \"$attrs\", \"$element\", \"$scope\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.components.menu')\n\t.provider('$mdMenu', MenuProvider);\n\t\n\t/*\n\t * Interim element provider for the menu.\n\t * Handles behavior for a menu while it is open, including:\n\t *    - handling animating the menu opening/closing\n\t *    - handling key/mouse events on the menu element\n\t *    - handling enabling/disabling scroll while the menu is open\n\t *    - handling redrawing during resizes and orientation changes\n\t *\n\t */\n\t\n\tfunction MenuProvider($$interimElementProvider) {\n\t  var MENU_EDGE_MARGIN = 8;\n\t\n\t  menuDefaultOptions.$inject = [\"$$rAF\", \"$window\", \"$mdUtil\", \"$mdTheming\", \"$timeout\", \"$mdConstant\", \"$document\"];\n\t  return $$interimElementProvider('$mdMenu')\n\t    .setDefaults({\n\t      methods: ['target'],\n\t      options: menuDefaultOptions\n\t    });\n\t\n\t  /* @ngInject */\n\t  function menuDefaultOptions($$rAF, $window, $mdUtil, $mdTheming, $timeout, $mdConstant, $document) {\n\t    return {\n\t      parent: 'body',\n\t      onShow: onShow,\n\t      onRemove: onRemove,\n\t      hasBackdrop: true,\n\t      disableParentScroll: true,\n\t      skipCompile: true,\n\t      themable: true\n\t    };\n\t\n\t    /**\n\t     * Boilerplate interimElement onShow function\n\t     * Handles inserting the menu into the DOM, positioning it, and wiring up\n\t     * various interaction events\n\t     */\n\t    function onShow(scope, element, opts) {\n\t\n\t      // Sanitize and set defaults on opts\n\t      buildOpts(opts);\n\t\n\t      // Wire up theming on our menu element\n\t      $mdTheming.inherit(opts.menuContentEl, opts.target);\n\t\n\t      // Register various listeners to move menu on resize/orientation change\n\t      handleResizing();\n\t\n\t      // Disable scrolling\n\t      if (opts.disableParentScroll) {\n\t        opts.restoreScroll = $mdUtil.disableScrollAround(opts.element);\n\t      }\n\t\n\t      // Only activate click listeners after a short time to stop accidental double taps/clicks\n\t      // from clicking the wrong item\n\t      $timeout(activateInteraction, 75, false);\n\t\n\t      if (opts.backdrop) {\n\t        $mdTheming.inherit(opts.backdrop, opts.parent);\n\t        opts.parent.append(opts.backdrop);\n\t      }\n\t      showMenu();\n\t\n\t      // Return the promise for when our menu is done animating in\n\t      return $mdUtil.transitionEndPromise(element, {timeout: 350});\n\t\n\t      /** Check for valid opts and set some sane defaults */\n\t      function buildOpts() {\n\t        if (!opts.target) {\n\t          throw Error(\n\t            '$mdMenu.show() expected a target to animate from in options.target'\n\t          );\n\t        }\n\t        angular.extend(opts, {\n\t          alreadyOpen: false,\n\t          isRemoved: false,\n\t          target: angular.element(opts.target), //make sure it's not a naked dom node\n\t          parent: angular.element(opts.parent),\n\t          menuContentEl: angular.element(element[0].querySelector('md-menu-content')),\n\t          backdrop: opts.hasBackdrop && angular.element('<md-backdrop class=\"md-menu-backdrop md-click-catcher\">')\n\t        });\n\t      }\n\t\n\t      /** Wireup various resize listeners for screen changes */\n\t      function handleResizing() {\n\t        opts.resizeFn = function() {\n\t          positionMenu(element, opts);\n\t        };\n\t        angular.element($window).on('resize', opts.resizeFn);\n\t        angular.element($window).on('orientationchange', opts.resizeFn);\n\t      }\n\t\n\t      /**\n\t       * Place the menu into the DOM and call positioning related functions\n\t       */\n\t      function showMenu() {\n\t        opts.parent.append(element);\n\t\n\t        element.removeClass('md-leave');\n\t        // Kick off our animation/positioning but first, wait a few frames\n\t        // so all of our computed positions/sizes are accurate\n\t        $$rAF(function() {\n\t          $$rAF(function() {\n\t            positionMenu(element, opts);\n\t            // Wait a frame before fading in menu (md-active) so that we don't trigger\n\t            // transitions on the menu position changing\n\t            $$rAF(function() {\n\t              element.addClass('md-active');\n\t              opts.alreadyOpen = true;\n\t              element[0].style[$mdConstant.CSS.TRANSFORM] = '';\n\t            });\n\t          });\n\t        });\n\t      }\n\t\n\t\n\t      /**\n\t       * Activate interaction on the menu. Wire up keyboard listerns for\n\t       * clicks, keypresses, backdrop closing, etc.\n\t       */\n\t      function activateInteraction() {\n\t        element.addClass('md-clickable');\n\t\n\t        // close on backdrop click\n\t        opts.backdrop && opts.backdrop.on('click', function(e) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t          opts.mdMenuCtrl.close(true);\n\t        });\n\t\n\t        // Wire up keyboard listeners.\n\t        // Close on escape, focus next item on down arrow, focus prev item on up\n\t        opts.menuContentEl.on('keydown', function(ev) {\n\t          scope.$apply(function() {\n\t            switch (ev.keyCode) {\n\t              case $mdConstant.KEY_CODE.ESCAPE: opts.mdMenuCtrl.close(); break;\n\t              case $mdConstant.KEY_CODE.UP_ARROW: focusMenuItem(ev, opts.menuContentEl, opts, -1); break;\n\t              case $mdConstant.KEY_CODE.DOWN_ARROW: focusMenuItem(ev, opts.menuContentEl, opts, 1); break;\n\t            }\n\t          });\n\t        });\n\t\n\t        // Close menu on menu item click, if said menu-item is not disabled\n\t        opts.menuContentEl.on('click', function(e) {\n\t          var target = e.target;\n\t          // Traverse up the event until we get to the menuContentEl to see if\n\t          // there is an ng-click and that the ng-click is not disabled\n\t          do {\n\t            if (target && target.hasAttribute('ng-click')) {\n\t              if (!target.hasAttribute('disabled')) {\n\t                close();\n\t              }\n\t              break;\n\t            }\n\t          } while ((target = target.parentNode) && target != opts.menuContentEl)\n\t\n\t          function close() {\n\t            scope.$apply(function() {\n\t              opts.mdMenuCtrl.close();\n\t            });\n\t          }\n\t        });\n\t\n\t        // kick off initial focus in the menu on the first element\n\t        var focusTarget = opts.menuContentEl[0].querySelector('[md-menu-focus-target]');\n\t        if (!focusTarget) focusTarget = opts.menuContentEl[0].firstElementChild.firstElementChild;\n\t        focusTarget.focus();\n\t      }\n\t    }\n\t\n\t    /**\n\t      * Takes a keypress event and focuses the next/previous menu\n\t      * item from the emitting element\n\t      * @param {event} e - The origin keypress event\n\t      * @param {angular.element} menuEl - The menu element\n\t      * @param {object} opts - The interim element options for the mdMenu\n\t      * @param {number} direction - The direction to move in (+1 = next, -1 = prev)\n\t      */\n\t    function focusMenuItem(e, menuEl, opts, direction) {\n\t      var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');\n\t\n\t      var items = $mdUtil.nodesToArray(menuEl[0].children);\n\t      var currentIndex = items.indexOf(currentItem);\n\t\n\t      // Traverse through our elements in the specified direction (+/-1) and try to\n\t      // focus them until we find one that accepts focus\n\t      for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {\n\t        var focusTarget = items[i].firstElementChild || items[i];\n\t        var didFocus = attemptFocus(focusTarget);\n\t        if (didFocus) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Attempts to focus an element. Checks whether that element is the currently\n\t     * focused element after attempting.\n\t     * @param {HTMLElement} el - the element to attempt focus on\n\t     * @returns {bool} - whether the element was successfully focused\n\t     */\n\t    function attemptFocus(el) {\n\t      if (el && el.getAttribute('tabindex') != -1) {\n\t        el.focus();\n\t        if ($document[0].activeElement == el) {\n\t          return true;\n\t        } else {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Boilerplate interimElement onRemove function\n\t     * Handles removing the menu from the DOM, cleaning up the element\n\t     * and removing various listeners\n\t     */\n\t    function onRemove(scope, element, opts) {\n\t      opts.isRemoved = true;\n\t      element.addClass('md-leave')\n\t        .removeClass('md-clickable');\n\t\n\t      // Disable resizing handlers\n\t      angular.element($window).off('resize', opts.resizeFn);\n\t      angular.element($window).off('orientationchange', opts.resizeFn);\n\t      opts.resizeFn = undefined;\n\t\n\t      // Wait for animate out, then remove from the DOM\n\t      return $mdUtil.transitionEndPromise(element, { timeout: 350 }).then(function() {\n\t        element.removeClass('md-active');\n\t        opts.backdrop && opts.backdrop.remove();\n\t        if (element[0].parentNode === opts.parent[0]) {\n\t          opts.parent[0].removeChild(element[0]);\n\t        }\n\t        opts.restoreScroll && opts.restoreScroll();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Computes menu position and sets the style on the menu container\n\t     * @param {HTMLElement} el - the menu container element\n\t     * @param {object} opts - the interim element options object\n\t     */\n\t    function positionMenu(el, opts) {\n\t      if (opts.isRemoved) return;\n\t\n\t      var containerNode = el[0],\n\t          openMenuNode = el[0].firstElementChild,\n\t          openMenuNodeRect = openMenuNode.getBoundingClientRect(),\n\t          boundryNode = opts.parent[0],\n\t          boundryNodeRect = boundryNode.getBoundingClientRect();\n\t\n\t      var originNode = opts.target[0].querySelector('[md-menu-origin]') || opts.target[0],\n\t          originNodeRect = originNode.getBoundingClientRect();\n\t\n\t\n\t      var bounds = {\n\t        left: boundryNodeRect.left + MENU_EDGE_MARGIN,\n\t        top: boundryNodeRect.top + MENU_EDGE_MARGIN,\n\t        bottom: boundryNodeRect.bottom - MENU_EDGE_MARGIN,\n\t        right: boundryNodeRect.right - MENU_EDGE_MARGIN\n\t      };\n\t\n\t\n\t      var alignTarget, alignTargetRect, existingOffsets;\n\t      var positionMode = opts.mdMenuCtrl.positionMode();\n\t\n\t      if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {\n\t        // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child\n\t        alignTarget = openMenuNode.firstElementChild.firstElementChild || openMenuNode.firstElementChild;\n\t        alignTarget = alignTarget.querySelector('[md-menu-align-target]') || alignTarget;\n\t        alignTargetRect = alignTarget.getBoundingClientRect();\n\t\n\t        existingOffsets = {\n\t          top: parseFloat(containerNode.style.top || 0),\n\t          left: parseFloat(containerNode.style.left || 0)\n\t        };\n\t      }\n\t\n\t      var position = { };\n\t      var transformOrigin = 'top ';\n\t\n\t      switch (positionMode.top) {\n\t        case 'target':\n\t          position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;\n\t          break;\n\t        // Future support for mdMenuBar\n\t        // case 'top':\n\t        //   position.top = originNodeRect.top;\n\t        //   break;\n\t        // case 'bottom':\n\t        //   position.top = originNodeRect.top + originNodeRect.height;\n\t        //   break;\n\t        default:\n\t          throw new Error('Invalid target mode \"' + positionMode.top + '\" specified for md-menu on Y axis.');\n\t      }\n\t\n\t      switch (positionMode.left) {\n\t        case 'target':\n\t          position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;\n\t          transformOrigin += 'left';\n\t          break;\n\t        case 'target-right':\n\t          position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);\n\t          transformOrigin += 'right';\n\t          break;\n\t        // Future support for mdMenuBar\n\t        // case 'left':\n\t        //   position.left = originNodeRect.left;\n\t        //   transformOrigin += 'left';\n\t        //   break;\n\t        // case 'right':\n\t        //   position.left = originNodeRect.right - containerNode.offsetWidth;\n\t        //   transformOrigin += 'right';\n\t        //   break;\n\t        default:\n\t          throw new Error('Invalid target mode \"' + positionMode.left + '\" specified for md-menu on X axis.');\n\t      }\n\t\n\t      var offsets = opts.mdMenuCtrl.offsets();\n\t      position.top += offsets.top;\n\t      position.left += offsets.left;\n\t\n\t      clamp(position);\n\t\n\t      el.css({\n\t        top: position.top + 'px',\n\t        left: position.left + 'px'\n\t      });\n\t\n\t      containerNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;\n\t\n\t      // Animate a scale out if we aren't just repositioning\n\t      if (!opts.alreadyOpen) {\n\t        containerNode.style[$mdConstant.CSS.TRANSFORM] = 'scale(' +\n\t          Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0) + ',' +\n\t          Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0) +\n\t        ')';\n\t      }\n\t\n\t      /**\n\t       * Clamps the repositioning of the menu within the confines of\n\t       * bounding element (often the screen/body)\n\t       */\n\t      function clamp(pos) {\n\t        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);\n\t        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);\n\t      }\n\t    }\n\t  }\n\t}\n\tMenuProvider.$inject = [\"$$interimElementProvider\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.progressCircular\n\t * @description Circular Progress module!\n\t */\n\tangular.module('material.components.progressCircular', [\n\t  'material.core'\n\t])\n\t  .directive('mdProgressCircular', MdProgressCircularDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdProgressCircular\n\t * @module material.components.progressCircular\n\t * @restrict E\n\t *\n\t* @description\n\t * The circular progress directive is used to make loading content in your app as delightful and\n\t * painless as possible by minimizing the amount of visual change a user sees before they can view\n\t * and interact with content.\n\t *\n\t * For operations where the percentage of the operation completed can be determined, use a\n\t * determinate indicator. They give users a quick sense of how long an operation will take.\n\t *\n\t * For operations where the user is asked to wait a moment while something finishes up, and it’s\n\t * not necessary to expose what's happening behind the scenes and how long it will take, use an\n\t * indeterminate indicator.\n\t *\n\t * @param {string} md-mode Select from one of two modes: determinate and indeterminate.\n\t * @param {number=} value In determinate mode, this number represents the percentage of the\n\t *     circular progress. Default: 0\n\t * @param {number=} md-diameter This specifies the diamter of the circular progress. Default: 48\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-progress-circular md-mode=\"determinate\" value=\"...\"></md-progress-circular>\n\t *\n\t * <md-progress-circular md-mode=\"determinate\" ng-value=\"...\"></md-progress-circular>\n\t *\n\t * <md-progress-circular md-mode=\"determinate\" value=\"...\" md-diameter=\"100\"></md-progress-circular>\n\t *\n\t * <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n\t * </hljs>\n\t */\n\tfunction MdProgressCircularDirective($mdConstant, $mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    template:\n\t        // The progress 'circle' is composed of two half-circles: the left side and the right\n\t        // side. Each side has CSS applied to 'fill-in' the half-circle to the appropriate progress.\n\t        '<div class=\"md-spinner-wrapper\">' +\n\t          '<div class=\"md-inner\">' +\n\t            '<div class=\"md-gap\"></div>' +\n\t            '<div class=\"md-left\">' +\n\t              '<div class=\"md-half-circle\"></div>' +\n\t            '</div>' +\n\t            '<div class=\"md-right\">' +\n\t              '<div class=\"md-half-circle\"></div>' +\n\t            '</div>' +\n\t          '</div>' +\n\t        '</div>',\n\t    compile: compile\n\t  };\n\t\n\t  function compile(tElement) {\n\t    // The javascript in this file is mainly responsible for setting the correct aria attributes.\n\t    // The animation of the progress spinner is done entirely with just CSS.\n\t    tElement.attr('aria-valuemin', 0);\n\t    tElement.attr('aria-valuemax', 100);\n\t    tElement.attr('role', 'progressbar');\n\t\n\t    return postLink;\n\t  }\n\t\n\t  function postLink(scope, element, attr) {\n\t    $mdTheming(element);\n\t    var circle = element[0];\n\t\n\t    // Scale the progress circle based on the default diameter.\n\t    var diameter = attr.mdDiameter || 48;\n\t    var scale = diameter / 48;\n\t    circle.style[$mdConstant.CSS.TRANSFORM] = 'scale(' + scale + ')';\n\t\n\t    attr.$observe('value', function(value) {\n\t      var percentValue = clamp(value);\n\t      element.attr('aria-valuenow', percentValue);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Clamps the value to be between 0 and 100.\n\t   * @param {number} value The value to clamp.\n\t   * @returns {number}\n\t   */\n\t  function clamp(value) {\n\t    return Math.max(0, Math.min(value || 0, 100));\n\t  }\n\t}\n\tMdProgressCircularDirective.$inject = [\"$mdConstant\", \"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.progressLinear\n\t * @description Linear Progress module!\n\t */\n\tangular.module('material.components.progressLinear', [\n\t  'material.core'\n\t])\n\t  .directive('mdProgressLinear', MdProgressLinearDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdProgressLinear\n\t * @module material.components.progressLinear\n\t * @restrict E\n\t *\n\t * @description\n\t * The linear progress directive is used to make loading content in your app as delightful and painless as possible by minimizing the amount of visual change a user sees before they can view and interact with content. Each operation should only be represented by one activity indicator—for example, one refresh operation should not display both a refresh bar and an activity circle.\n\t *\n\t * For operations where the percentage of the operation completed can be determined, use a determinate indicator. They give users a quick sense of how long an operation will take.\n\t *\n\t * For operations where the user is asked to wait a moment while something finishes up, and it’s not necessary to expose what's happening behind the scenes and how long it will take, use an indeterminate indicator.\n\t *\n\t * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.\n\t * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0\n\t * @param {number=} md-buffer-value In the buffer mode, this number represents the precentage of the secondary progress bar. Default: 0\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-progress-linear md-mode=\"determinate\" value=\"...\"></md-progress-linear>\n\t *\n\t * <md-progress-linear md-mode=\"determinate\" ng-value=\"...\"></md-progress-linear>\n\t *\n\t * <md-progress-linear md-mode=\"indeterminate\"></md-progress-linear>\n\t *\n\t * <md-progress-linear md-mode=\"buffer\" value=\"...\" md-buffer-value=\"...\"></md-progress-linear>\n\t *\n\t * <md-progress-linear md-mode=\"query\"></md-progress-linear>\n\t * </hljs>\n\t */\n\tfunction MdProgressLinearDirective($$rAF, $mdConstant, $mdTheming) {\n\t\n\t  return {\n\t    restrict: 'E',\n\t    template: '<div class=\"md-container\">' +\n\t      '<div class=\"md-dashed\"></div>' +\n\t      '<div class=\"md-bar md-bar1\"></div>' +\n\t      '<div class=\"md-bar md-bar2\"></div>' +\n\t      '</div>',\n\t    compile: compile\n\t  };\n\t  \n\t  function compile(tElement, tAttrs, transclude) {\n\t    tElement.attr('aria-valuemin', 0);\n\t    tElement.attr('aria-valuemax', 100);\n\t    tElement.attr('role', 'progressbar');\n\t\n\t    return postLink;\n\t  }\n\t  function postLink(scope, element, attr) {\n\t    $mdTheming(element);\n\t    var bar1Style = element[0].querySelector('.md-bar1').style,\n\t      bar2Style = element[0].querySelector('.md-bar2').style,\n\t      container = angular.element(element[0].querySelector('.md-container'));\n\t\n\t    attr.$observe('value', function(value) {\n\t      if (attr.mdMode == 'query') {\n\t        return;\n\t      }\n\t\n\t      var clamped = clamp(value);\n\t      element.attr('aria-valuenow', clamped);\n\t      bar2Style[$mdConstant.CSS.TRANSFORM] = transforms[clamped];\n\t    });\n\t\n\t    attr.$observe('mdBufferValue', function(value) {\n\t      bar1Style[$mdConstant.CSS.TRANSFORM] = transforms[clamp(value)];\n\t    });\n\t\n\t    $$rAF(function() {\n\t      container.addClass('md-ready');\n\t    });\n\t  }\n\t\n\t  function clamp(value) {\n\t    if (value > 100) {\n\t      return 100;\n\t    }\n\t\n\t    if (value < 0) {\n\t      return 0;\n\t    }\n\t\n\t    return Math.ceil(value || 0);\n\t  }\n\t}\n\tMdProgressLinearDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdTheming\"];\n\t\n\t\n\t// **********************************************************\n\t// Private Methods\n\t// **********************************************************\n\tvar transforms = (function() {\n\t  var values = new Array(101);\n\t  for(var i = 0; i < 101; i++){\n\t    values[i] = makeTransform(i);\n\t  }\n\t\n\t  return values;\n\t\n\t  function makeTransform(value){\n\t    var scale = value/100;\n\t    var translateX = (value-100)/2;\n\t    return 'translateX(' + translateX.toString() + '%) scale(' + scale.toString() + ', 1)';\n\t  }\n\t})();\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.radioButton\n\t * @description radioButton module!\n\t */\n\tangular.module('material.components.radioButton', [\n\t  'material.core'\n\t])\n\t  .directive('mdRadioGroup', mdRadioGroupDirective)\n\t  .directive('mdRadioButton', mdRadioButtonDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @module material.components.radioButton\n\t * @name mdRadioGroup\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-radio-group>` directive identifies a grouping\n\t * container for the 1..n grouped radio buttons; specified using nested\n\t * `<md-radio-button>` tags.\n\t *\n\t * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n\t * the radio button is in the accent color by default. The primary color palette may be used with\n\t * the `md-primary` class.\n\t *\n\t * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently\n\t * than the native `<input type='radio'>` controls. Whereas the native controls\n\t * force the user to tab through all the radio buttons, `<md-radio-group>`\n\t * is focusable, and by default the `<md-radio-button>`s are not.\n\t *\n\t * @param {string} ng-model Assignable angular expression to data-bind to.\n\t * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-radio-group ng-model=\"selected\">\n\t *\n\t *   <md-radio-button\n\t *        ng-repeat=\"d in colorOptions\"\n\t *        ng-value=\"d.value\" aria-label=\"{{ d.label }}\">\n\t *\n\t *          {{ d.label }}\n\t *\n\t *   </md-radio-button>\n\t *\n\t * </md-radio-group>\n\t * </hljs>\n\t *\n\t */\n\tfunction mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {\n\t  RadioGroupController.prototype = createRadioGroupControllerProto();\n\t\n\t  return {\n\t    restrict: 'E',\n\t    controller: ['$element', RadioGroupController],\n\t    require: ['mdRadioGroup', '?ngModel'],\n\t    link: { pre: linkRadioGroup }\n\t  };\n\t\n\t  function linkRadioGroup(scope, element, attr, ctrls) {\n\t    $mdTheming(element);\n\t    var rgCtrl = ctrls[0];\n\t    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n\t\n\t    function setFocus() {\n\t      if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n\t    }\n\t\n\t    function keydownListener(ev) {\n\t      var keyCode = ev.which || ev.keyCode;\n\t      switch(keyCode) {\n\t        case $mdConstant.KEY_CODE.LEFT_ARROW:\n\t        case $mdConstant.KEY_CODE.UP_ARROW:\n\t          ev.preventDefault();\n\t          rgCtrl.selectPrevious();\n\t          setFocus();\n\t          break;\n\t\n\t        case $mdConstant.KEY_CODE.RIGHT_ARROW:\n\t        case $mdConstant.KEY_CODE.DOWN_ARROW:\n\t          ev.preventDefault();\n\t          rgCtrl.selectNext();\n\t          setFocus();\n\t          break;\n\t\n\t        case $mdConstant.KEY_CODE.ENTER:\n\t          var form = angular.element($mdUtil.getClosest(element[0], 'form'));\n\t          if (form.length > 0) {\n\t            form.triggerHandler('submit');\n\t          }\n\t          break;\n\t      }\n\t    }\n\t\n\t    rgCtrl.init(ngModelCtrl);\n\t\n\t    scope.mouseActive = false;\n\t    element.attr({\n\t              'role': 'radiogroup',\n\t              'tabIndex': element.attr('tabindex') || '0'\n\t            })\n\t            .on('keydown', keydownListener)\n\t            .on('mousedown', function(event) {\n\t              scope.mouseActive = true;\n\t              $timeout(function() {\n\t                scope.mouseActive = false;\n\t              }, 100);\n\t            })\n\t            .on('focus', function() {\n\t              if(scope.mouseActive === false) { rgCtrl.$element.addClass('md-focused'); }\n\t            })\n\t            .on('blur', function() { rgCtrl.$element.removeClass('md-focused'); });\n\t  }\n\t\n\t  function RadioGroupController($element) {\n\t    this._radioButtonRenderFns = [];\n\t    this.$element = $element;\n\t  }\n\t\n\t  function createRadioGroupControllerProto() {\n\t    return {\n\t      init: function(ngModelCtrl) {\n\t        this._ngModelCtrl = ngModelCtrl;\n\t        this._ngModelCtrl.$render = angular.bind(this, this.render);\n\t      },\n\t      add: function(rbRender) {\n\t        this._radioButtonRenderFns.push(rbRender);\n\t      },\n\t      remove: function(rbRender) {\n\t        var index = this._radioButtonRenderFns.indexOf(rbRender);\n\t        if (index !== -1) {\n\t          this._radioButtonRenderFns.splice(index, 1);\n\t        }\n\t      },\n\t      render: function() {\n\t        this._radioButtonRenderFns.forEach(function(rbRender) {\n\t          rbRender();\n\t        });\n\t      },\n\t      setViewValue: function(value, eventType) {\n\t        this._ngModelCtrl.$setViewValue(value, eventType);\n\t        // update the other radio buttons as well\n\t        this.render();\n\t      },\n\t      getViewValue: function() {\n\t        return this._ngModelCtrl.$viewValue;\n\t      },\n\t      selectNext: function() {\n\t        return changeSelectedButton(this.$element, 1);\n\t      },\n\t      selectPrevious: function() {\n\t        return changeSelectedButton(this.$element, -1);\n\t      },\n\t      setActiveDescendant: function (radioId) {\n\t        this.$element.attr('aria-activedescendant', radioId);\n\t      }\n\t    };\n\t  }\n\t  /**\n\t   * Change the radio group's selected button by a given increment.\n\t   * If no button is selected, select the first button.\n\t   */\n\t  function changeSelectedButton(parent, increment) {\n\t    // Coerce all child radio buttons into an array, then wrap then in an iterator\n\t    var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);\n\t\n\t    if (buttons.count()) {\n\t      var validate = function (button) {\n\t        // If disabled, then NOT valid\n\t        return !angular.element(button).attr(\"disabled\");\n\t      };\n\t      var selected = parent[0].querySelector('md-radio-button.md-checked');\n\t      var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();\n\t      // Activate radioButton's click listener (triggerHandler won't create a real click event)\n\t      angular.element(target).triggerHandler('click');\n\t\n\t\n\t    }\n\t  }\n\t\n\t}\n\tmdRadioGroupDirective.$inject = [\"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$timeout\"];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @module material.components.radioButton\n\t * @name mdRadioButton\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.\n\t *\n\t * While similar to the `<input type=\"radio\" ng-model=\"\" value=\"\">` directive,\n\t * the `<md-radio-button>` directive provides ink effects, ARIA support, and\n\t * supports use within named radio groups.\n\t *\n\t * @param {string} ngModel Assignable angular expression to data-bind to.\n\t * @param {string=} ngChange Angular expression to be executed when input changes due to user\n\t *    interaction with the input element.\n\t * @param {string} ngValue Angular expression which sets the value to which the expression should\n\t *    be set when selected.*\n\t * @param {string} value The value to which the expression should be set when selected.\n\t * @param {string=} name Property name of the form under which the control is published.\n\t * @param {string=} aria-label Adds label to radio button for accessibility.\n\t * Defaults to radio button's text. If no text content is available, a warning will be logged.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t *\n\t * <md-radio-button value=\"1\" aria-label=\"Label 1\">\n\t *   Label 1\n\t * </md-radio-button>\n\t *\n\t * <md-radio-button ng-model=\"color\" ng-value=\"specialValue\" aria-label=\"Green\">\n\t *   Green\n\t * </md-radio-button>\n\t *\n\t * </hljs>\n\t *\n\t */\n\tfunction mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {\n\t\n\t  var CHECKED_CSS = 'md-checked';\n\t\n\t  return {\n\t    restrict: 'E',\n\t    require: '^mdRadioGroup',\n\t    transclude: true,\n\t    template: '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n\t                '<div class=\"md-off\"></div>' +\n\t                '<div class=\"md-on\"></div>' +\n\t              '</div>' +\n\t              '<div ng-transclude class=\"md-label\"></div>',\n\t    link: link\n\t  };\n\t\n\t  function link(scope, element, attr, rgCtrl) {\n\t    var lastChecked;\n\t\n\t    $mdTheming(element);\n\t    configureAria(element, scope);\n\t\n\t    rgCtrl.add(render);\n\t    attr.$observe('value', render);\n\t\n\t    element\n\t      .on('click', listener)\n\t      .on('$destroy', function() {\n\t        rgCtrl.remove(render);\n\t      });\n\t\n\t    function listener(ev) {\n\t      if (element[0].hasAttribute('disabled')) return;\n\t\n\t      scope.$apply(function() {\n\t        rgCtrl.setViewValue(attr.value, ev && ev.type);\n\t      });\n\t    }\n\t\n\t    function render() {\n\t      var checked = (rgCtrl.getViewValue() == attr.value);\n\t      if (checked === lastChecked) {\n\t        return;\n\t      }\n\t      lastChecked = checked;\n\t      element.attr('aria-checked', checked);\n\t      if (checked) {\n\t        element.addClass(CHECKED_CSS);\n\t        rgCtrl.setActiveDescendant(element.attr('id'));\n\t      } else {\n\t        element.removeClass(CHECKED_CSS);\n\t      }\n\t    }\n\t    /**\n\t     * Inject ARIA-specific attributes appropriate for each radio button\n\t     */\n\t    function configureAria( element, scope ){\n\t      scope.ariaId = buildAriaID();\n\t\n\t      element.attr({\n\t        'id' :  scope.ariaId,\n\t        'role' : 'radio',\n\t        'aria-checked' : 'false'\n\t      });\n\t\n\t      $mdAria.expectWithText(element, 'aria-label');\n\t\n\t      /**\n\t       * Build a unique ID for each radio button that will be used with aria-activedescendant.\n\t       * Preserve existing ID if already specified.\n\t       * @returns {*|string}\n\t       */\n\t      function buildAriaID() {\n\t        return attr.id || ( 'radio' + \"_\" + $mdUtil.nextUid() );\n\t      }\n\t    }\n\t  }\n\t}\n\tmdRadioButtonDirective.$inject = [\"$mdAria\", \"$mdUtil\", \"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.select\n\t */\n\t\n\t/***************************************************\n\t\n\t### TODO ###\n\t**DOCUMENTATION AND DEMOS**\n\t\n\t- [ ] ng-model with child mdOptions (basic)\n\t- [ ] ng-model=\"foo\" ng-model-options=\"{ trackBy: '$value.id' }\" for objects\n\t- [ ] mdOption with value\n\t- [ ] Usage with input inside\n\t\n\t### TODO - POST RC1 ###\n\t- [ ] Abstract placement logic in $mdSelect service to $mdMenu service\n\t\n\t***************************************************/\n\t\n\tvar SELECT_EDGE_MARGIN = 8;\n\tvar selectNextId = 0;\n\t\n\tangular.module('material.components.select', [\n\t  'material.core',\n\t  'material.components.backdrop'\n\t])\n\t.directive('mdSelect', SelectDirective)\n\t.directive('mdSelectMenu', SelectMenuDirective)\n\t.directive('mdOption', OptionDirective)\n\t.directive('mdOptgroup', OptgroupDirective)\n\t.provider('$mdSelect', SelectProvider);\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdSelect\n\t * @restrict E\n\t * @module material.components.select\n\t *\n\t * @description Displays a select box, bound to an ng-model.\n\t *\n\t * @param {expression} ng-model The model!\n\t * @param {expression=} md-on-close expression to be evaluated when the select is closed\n\t * @param {boolean=} multiple Whether it's multiple.\n\t * @param {string=} placeholder Placeholder hint text.\n\t * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or\n\t * explicit label is present.\n\t *\n\t * @usage\n\t * With a placeholder (label and aria-label are added dynamically)\n\t * <hljs lang=\"html\">\n\t *   <md-select\n\t *     ng-model=\"someModel\"\n\t *     placeholder=\"Select a state\">\n\t *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n\t *   </md-select>\n\t * </hljs>\n\t *\n\t * With an explicit label\n\t * <hljs lang=\"html\">\n\t *   <md-select\n\t *     ng-model=\"someModel\">\n\t *     <md-select-label>Select a state</md-select-label>\n\t *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n\t *   </md-select>\n\t * </hljs>\n\t */\n\tfunction SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $interpolate, $compile, $parse) {\n\t  return {\n\t    restrict: 'E',\n\t    require: ['mdSelect', 'ngModel', '?^form'],\n\t    compile: compile,\n\t    controller: function() { } // empty placeholder controller to be initialized in link\n\t  };\n\t\n\t  function compile(element, attr) {\n\t    // The user is allowed to provide a label for the select as md-select-label child\n\t    var labelEl = element.find('md-select-label').remove();\n\t\n\t    // If not provided, we automatically make one\n\t    if (!labelEl.length) {\n\t      labelEl = angular.element('<md-select-label><span></span></md-select-label>');\n\t    } else {\n\t      if (!labelEl[0].firstElementChild) {\n\t        var spanWrapper = angular.element('<span>');\n\t        spanWrapper.append(labelEl.contents());\n\t        labelEl.append(spanWrapper);\n\t      }\n\t    }\n\t    labelEl.append('<span class=\"md-select-icon\" aria-hidden=\"true\"></span>');\n\t    labelEl.addClass('md-select-label');\n\t    if (!labelEl[0].hasAttribute('id')) {\n\t      labelEl.attr('id', 'select_label_' + $mdUtil.nextUid());\n\t    }\n\t\n\t    // There's got to be an md-content inside. If there's not one, let's add it.\n\t    if (!element.find('md-content').length) {\n\t      element.append( angular.element('<md-content>').append(element.contents()) );\n\t    }\n\t\n\t    // Add progress spinner for md-options-loading\n\t    if (attr.mdOnOpen) {\n\t      element.find('md-content').prepend(\n\t        angular.element('<md-progress-circular>')\n\t               .attr('md-mode', 'indeterminate')\n\t               .attr('ng-hide', '$$loadingAsyncDone')\n\t               .wrap('<div>')\n\t               .parent()\n\t      );\n\t    }\n\t\n\t    if (attr.name) {\n\t      var autofillClone = angular.element('<select class=\"md-visually-hidden\">');\n\t      autofillClone.attr({\n\t        'name': '.' + attr.name,\n\t        'ng-model': attr.ngModel,\n\t        'aria-hidden': 'true',\n\t        'tabindex': '-1'\n\t      });\n\t      var opts = element.find('md-option');\n\t      angular.forEach(opts, function(el) {\n\t        var newEl = angular.element('<option>' + el.innerHTML + '</option>');\n\t        if (el.hasAttribute('ng-value')) newEl.attr('ng-value', el.getAttribute('ng-value'));\n\t        else if (el.hasAttribute('value')) newEl.attr('value', el.getAttribute('value'));\n\t        autofillClone.append(newEl);\n\t      });\n\t\n\t      element.parent().append(autofillClone);\n\t    }\n\t\n\t    // Use everything that's left inside element.contents() as the contents of the menu\n\t    var selectTemplate = '<div class=\"md-select-menu-container\">' +\n\t        '<md-select-menu ' +\n\t        (angular.isDefined(attr.multiple) ? 'multiple' : '') + '>' +\n\t          element.html() +\n\t        '</md-select-menu></div>';\n\t\n\t    element.empty().append(labelEl);\n\t\n\t    attr.tabindex = attr.tabindex || '0';\n\t\n\t    return function postLink(scope, element, attr, ctrls) {\n\t      var isOpen;\n\t      var isDisabled;\n\t\n\t      var mdSelectCtrl = ctrls[0];\n\t      var ngModel = ctrls[1];\n\t      var formCtrl = ctrls[2];\n\t\n\t      var labelEl = element.find('md-select-label');\n\t      var customLabel = labelEl.text().length !== 0;\n\t      var selectContainer, selectScope, selectMenuCtrl;\n\t      createSelect();\n\t\n\t      $mdTheming(element);\n\t\n\t      if (attr.name && formCtrl) {\n\t        var selectEl = element.parent()[0].querySelector('select[name=\".' + attr.name + '\"]');\n\t        formCtrl.$removeControl(angular.element(selectEl).controller());\n\t      }\n\t\n\t      var originalRender = ngModel.$render;\n\t      ngModel.$render = function() {\n\t        originalRender();\n\t        syncLabelText();\n\t      };\n\t\n\t      mdSelectCtrl.setLabelText = function(text) {\n\t        if (customLabel) return; // Assume that user is handling it on their own\n\t        mdSelectCtrl.setIsPlaceholder(!text);\n\t        text = text || attr.placeholder || '';\n\t        var target = customLabel ? labelEl : labelEl.children().eq(0);\n\t        target.text(text);\n\t      };\n\t\n\t      mdSelectCtrl.setIsPlaceholder = function(val) {\n\t        val ? labelEl.addClass('md-placeholder') : labelEl.removeClass('md-placeholder');\n\t      };\n\t\n\t      mdSelectCtrl.triggerClose = function() {\n\t        $parse(attr.mdOnClose)(scope);\n\t      };\n\t\n\t      scope.$$postDigest(function() {\n\t        setAriaLabel();\n\t        syncLabelText();\n\t      });\n\t\n\t      function setAriaLabel() {\n\t        var labelText = element.attr('placeholder');\n\t        if (!labelText) {\n\t          labelText = element.find('md-select-label').text();\n\t        }\n\t        $mdAria.expect(element, 'aria-label', labelText);\n\t      }\n\t\n\t      function syncLabelText() {\n\t        if (selectContainer) {\n\t          selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');\n\t          mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());\n\t        }\n\t      }\n\t\n\t      var deregisterWatcher;\n\t      attr.$observe('ngMultiple', function(val) {\n\t        if (deregisterWatcher) deregisterWatcher();\n\t        var parser = $parse(val);\n\t        deregisterWatcher = scope.$watch(function() { return parser(scope); }, function(multiple, prevVal) {\n\t          if (multiple === undefined && prevVal === undefined) return; // assume compiler did a good job\n\t          if (multiple) {\n\t            element.attr('multiple', 'multiple');\n\t          } else {\n\t            element.removeAttr('multiple');\n\t          }\n\t          if (selectContainer) {\n\t            selectMenuCtrl.setMultiple(multiple);\n\t            originalRender = ngModel.$render;\n\t            ngModel.$render = function() {\n\t              originalRender();\n\t              syncLabelText();\n\t            };\n\t            selectMenuCtrl.refreshViewValue();\n\t            ngModel.$render();\n\t          }\n\t        });\n\t      });\n\t\n\t      attr.$observe('disabled', function(disabled) {\n\t        if (typeof disabled == \"string\") {\n\t          disabled = true;\n\t        }\n\t        // Prevent click event being registered twice\n\t        if (isDisabled !== undefined && isDisabled === disabled) {\n\t          return;\n\t        }\n\t        isDisabled = disabled;\n\t        if (disabled) {\n\t          element.attr({'tabindex': -1, 'aria-disabled': 'true'});\n\t          element.off('click', openSelect);\n\t          element.off('keydown', handleKeypress);\n\t        } else {\n\t          element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n\t          element.on('click', openSelect);\n\t          element.on('keydown', handleKeypress);\n\t        }\n\t      });\n\t\n\t      if (!attr.disabled && !attr.ngDisabled) {\n\t        element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n\t        element.on('click', openSelect);\n\t        element.on('keydown', handleKeypress);\n\t      }\n\t\n\t      var ariaAttrs = {\n\t        role: 'combobox',\n\t        'aria-expanded': 'false'\n\t      };\n\t      if (!element[0].hasAttribute('id')) {\n\t        ariaAttrs.id = 'select_' + $mdUtil.nextUid();\n\t      }\n\t      element.attr(ariaAttrs);\n\t\n\t      scope.$on('$destroy', function() {\n\t        if (isOpen) {\n\t          $mdSelect.cancel().then(function() {\n\t            selectContainer.remove();\n\t          });\n\t        } else {\n\t          selectContainer.remove();\n\t        }\n\t      });\n\t\n\t\n\t      // Create a fake select to find out the label value\n\t      function createSelect() {\n\t        selectContainer = angular.element(selectTemplate);\n\t        var selectEl = selectContainer.find('md-select-menu');\n\t        selectEl.data('$ngModelController', ngModel);\n\t        selectEl.data('$mdSelectController', mdSelectCtrl);\n\t        selectScope = scope.$new();\n\t        selectContainer = $compile(selectContainer)(selectScope);\n\t        selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');\n\t      }\n\t\n\t      function handleKeypress(e) {\n\t        var allowedCodes = [32, 13, 38, 40];\n\t        if (allowedCodes.indexOf(e.keyCode) != -1 ) {\n\t          // prevent page scrolling on interaction\n\t          e.preventDefault();\n\t          openSelect(e);\n\t        } else {\n\t          if (e.keyCode <= 90 && e.keyCode >= 31) {\n\t            e.preventDefault();\n\t            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);\n\t            if (!node) return;\n\t            var optionCtrl = angular.element(node).controller('mdOption');\n\t            if (!selectMenuCtrl.isMultiple) {\n\t              selectMenuCtrl.deselect( Object.keys(selectMenuCtrl.selected)[0] );\n\t            }\n\t            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n\t            selectMenuCtrl.refreshViewValue();\n\t            ngModel.$render();\n\t          }\n\t        }\n\t      }\n\t\n\t      function openSelect() {\n\t        scope.$evalAsync(function() {\n\t          isOpen = true;\n\t          $mdSelect.show({\n\t            scope: selectScope,\n\t            preserveScope: true,\n\t            skipCompile: true,\n\t            element: selectContainer,\n\t            target: element[0],\n\t            hasBackdrop: true,\n\t            loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false,\n\t          }).then(function(selectedText) {\n\t            isOpen = false;\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }\n\t}\n\tSelectDirective.$inject = [\"$mdSelect\", \"$mdUtil\", \"$mdTheming\", \"$mdAria\", \"$interpolate\", \"$compile\", \"$parse\"];\n\t\n\tfunction SelectMenuDirective($parse, $mdUtil, $mdTheming) {\n\t\n\t  SelectMenuController.$inject = [\"$scope\", \"$attrs\", \"$element\"];\n\t  return {\n\t    restrict: 'E',\n\t    require: ['mdSelectMenu', '?ngModel'],\n\t    controller: SelectMenuController,\n\t    link: { pre: preLink }\n\t  };\n\t\n\t  // We use preLink instead of postLink to ensure that the select is initialized before\n\t  // its child options run postLink.\n\t  function preLink(scope, element, attr, ctrls) {\n\t    var selectCtrl = ctrls[0];\n\t    var ngModel = ctrls[1];\n\t\n\t    $mdTheming(element);\n\t    element.on('click', clickListener);\n\t    element.on('keypress', keyListener);\n\t    if (ngModel) selectCtrl.init(ngModel);\n\t    configureAria();\n\t\n\t    function configureAria() {\n\t      element.attr({\n\t        'id': 'select_menu_' + $mdUtil.nextUid(),\n\t        'role': 'listbox',\n\t        'aria-multiselectable': (selectCtrl.isMultiple ? 'true' : 'false')\n\t      });\n\t    }\n\t\n\t    function keyListener(e) {\n\t      if (e.keyCode == 13 || e.keyCode == 32) {\n\t        clickListener(e);\n\t      }\n\t    }\n\t\n\t    function clickListener(ev) {\n\t      var option = $mdUtil.getClosest(ev.target, 'md-option');\n\t      var optionCtrl = option && angular.element(option).data('$mdOptionController');\n\t      if (!option || !optionCtrl) return;\n\t\n\t      var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);\n\t      var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);\n\t\n\t      scope.$apply(function() {\n\t        if (selectCtrl.isMultiple) {\n\t          if (isSelected) {\n\t            selectCtrl.deselect(optionHashKey);\n\t          } else {\n\t            selectCtrl.select(optionHashKey, optionCtrl.value);\n\t          }\n\t        } else {\n\t          if (!isSelected) {\n\t            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n\t            selectCtrl.select( optionHashKey, optionCtrl.value );\n\t          }\n\t        }\n\t        selectCtrl.refreshViewValue();\n\t      });\n\t    }\n\t  }\n\t\n\t\n\t\n\t  function SelectMenuController($scope, $attrs, $element) {\n\t    var self = this;\n\t    self.isMultiple = angular.isDefined($attrs.multiple);\n\t    // selected is an object with keys matching all of the selected options' hashed values\n\t    self.selected = {};\n\t    // options is an object with keys matching every option's hash value,\n\t    // and values matching every option's controller.\n\t    self.options = {};\n\t\n\t    $scope.$watch(function() { return self.options; }, function() {\n\t      self.ngModel.$render();\n\t    }, true);\n\t\n\t    var deregisterCollectionWatch;\n\t    self.setMultiple = function(isMultiple) {\n\t      var ngModel = self.ngModel;\n\t      self.isMultiple = isMultiple;\n\t      if (deregisterCollectionWatch) deregisterCollectionWatch();\n\t\n\t      if (self.isMultiple) {\n\t        ngModel.$validators['md-multiple'] = validateArray;\n\t        ngModel.$render = renderMultiple;\n\t\n\t        // watchCollection on the model because by default ngModel only watches the model's\n\t        // reference. This allowed the developer to also push and pop from their array.\n\t        $scope.$watchCollection($attrs.ngModel, function(value) {\n\t          if (validateArray(value)) renderMultiple(value);\n\t        });\n\t      } else {\n\t        delete ngModel.$validators['md-multiple'];\n\t        ngModel.$render = renderSingular;\n\t      }\n\t\n\t      function validateArray(modelValue, viewValue) {\n\t        // If a value is truthy but not an array, reject it.\n\t        // If value is undefined/falsy, accept that it's an empty array.\n\t        return angular.isArray(modelValue || viewValue || []);\n\t      }\n\t    };\n\t\n\t    var searchStr = '';\n\t    var clearSearchTimeout, optNodes, optText;\n\t    var CLEAR_SEARCH_AFTER = 300;\n\t    self.optNodeForKeyboardSearch = function(e) {\n\t      clearSearchTimeout && clearTimeout(clearSearchTimeout);\n\t      clearSearchTimeout = setTimeout(function() {\n\t        clearSearchTimeout = undefined;\n\t        searchStr = '';\n\t        optText = undefined;\n\t        optNodes = undefined;\n\t      }, CLEAR_SEARCH_AFTER);\n\t      searchStr += String.fromCharCode(e.keyCode);\n\t      var search = new RegExp('^' + searchStr, 'i');\n\t      if (!optNodes) {\n\t        optNodes = $element.find('md-option');\n\t        optText = new Array(optNodes.length);\n\t        angular.forEach(optNodes, function(el, i) {\n\t          optText[i] = el.textContent.trim();\n\t        });\n\t      }\n\t      for (var i = 0; i < optText.length; ++i) {\n\t        if (search.test(optText[i])) {\n\t          return optNodes[i];\n\t        }\n\t      }\n\t    };\n\t\n\t\n\t    self.init = function(ngModel) {\n\t      self.ngModel = ngModel;\n\t\n\t      // Allow users to provide `ng-model=\"foo\" ng-model-options=\"{trackBy: 'foo.id'}\"` so\n\t      // that we can properly compare objects set on the model to the available options\n\t      if (ngModel.$options && ngModel.$options.trackBy) {\n\t        var trackByLocals = {};\n\t        var trackByParsed = $parse(ngModel.$options.trackBy);\n\t        self.hashGetter = function(value, valueScope) {\n\t          trackByLocals.$value = value;\n\t          return trackByParsed(valueScope || $scope, trackByLocals);\n\t        };\n\t      // If the user doesn't provide a trackBy, we automatically generate an id for every\n\t      // value passed in\n\t      } else {\n\t        self.hashGetter = function getHashValue(value) {\n\t          if (angular.isObject(value)) {\n\t            return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));\n\t          }\n\t          return value;\n\t        };\n\t      }\n\t      self.setMultiple(self.isMultiple);\n\t    };\n\t\n\t    self.selectedLabels = function() {\n\t      var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));\n\t      if (selectedOptionEls.length) {\n\t        return selectedOptionEls.map(function(el) { return el.textContent; }).join(', ');\n\t      } else {\n\t        return '';\n\t      }\n\t    };\n\t\n\t    self.select = function(hashKey, hashedValue) {\n\t      var option = self.options[hashKey];\n\t      option && option.setSelected(true);\n\t      self.selected[hashKey] = hashedValue;\n\t    };\n\t    self.deselect = function(hashKey) {\n\t      var option = self.options[hashKey];\n\t      option && option.setSelected(false);\n\t      delete self.selected[hashKey];\n\t    };\n\t\n\t    self.addOption = function(hashKey, optionCtrl) {\n\t      if (angular.isDefined(self.options[hashKey])) {\n\t        throw new Error('Duplicate md-option values are not allowed in a select. ' +\n\t                        'Duplicate value \"' + optionCtrl.value + '\" found.');\n\t      }\n\t      self.options[hashKey] = optionCtrl;\n\t\n\t      // If this option's value was already in our ngModel, go ahead and select it.\n\t      if (angular.isDefined(self.selected[hashKey])) {\n\t        self.select(hashKey, optionCtrl.value);\n\t        self.refreshViewValue();\n\t      }\n\t    };\n\t    self.removeOption = function(hashKey) {\n\t      delete self.options[hashKey];\n\t      // Don't deselect an option when it's removed - the user's ngModel should be allowed\n\t      // to have values that do not match a currently available option.\n\t    };\n\t\n\t    self.refreshViewValue = function() {\n\t      var values = [];\n\t      var option;\n\t      for (var hashKey in self.selected) {\n\t         // If this hashKey has an associated option, push that option's value to the model.\n\t         if ((option = self.options[hashKey])) {\n\t           values.push(option.value);\n\t         } else {\n\t           // Otherwise, the given hashKey has no associated option, and we got it\n\t           // from an ngModel value at an earlier time. Push the unhashed value of\n\t           // this hashKey to the model.\n\t           // This allows the developer to put a value in the model that doesn't yet have\n\t           // an associated option.\n\t           values.push(self.selected[hashKey]);\n\t         }\n\t      }\n\t      self.ngModel.$setViewValue(self.isMultiple ? values : values[0]);\n\t    };\n\t\n\t    function renderMultiple() {\n\t      var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue;\n\t      if (!angular.isArray(newSelectedValues)) return;\n\t\n\t      var oldSelected = Object.keys(self.selected);\n\t\n\t      var newSelectedHashes = newSelectedValues.map(self.hashGetter);\n\t      var deselected = oldSelected.filter(function(hash) {\n\t        return newSelectedHashes.indexOf(hash) === -1;\n\t      });\n\t\n\t      deselected.forEach(self.deselect);\n\t      newSelectedHashes.forEach(function(hashKey, i) {\n\t        self.select(hashKey, newSelectedValues[i]);\n\t      });\n\t    }\n\t    function renderSingular() {\n\t      var value = self.ngModel.$viewValue || self.ngModel.$modelValue;\n\t      Object.keys(self.selected).forEach(self.deselect);\n\t      self.select( self.hashGetter(value), value );\n\t    }\n\t  }\n\t\n\t}\n\tSelectMenuDirective.$inject = [\"$parse\", \"$mdUtil\", \"$mdTheming\"];\n\t\n\tfunction OptionDirective($mdButtonInkRipple, $mdUtil) {\n\t\n\t  OptionController.$inject = [\"$element\"];\n\t  return {\n\t    restrict: 'E',\n\t    require: ['mdOption', '^^mdSelectMenu'],\n\t    controller: OptionController,\n\t    compile: compile\n\t  };\n\t\n\t  function compile(element, attr) {\n\t    // Manual transclusion to avoid the extra inner <span> that ng-transclude generates\n\t    element.append( angular.element('<div class=\"md-text\">').append(element.contents()) );\n\t\n\t    element.attr('tabindex', attr.tabindex || '0');\n\t    return postLink;\n\t  }\n\t\n\t  function postLink(scope, element, attr, ctrls) {\n\t    var optionCtrl = ctrls[0];\n\t    var selectCtrl = ctrls[1];\n\t\n\t    if (angular.isDefined(attr.ngValue)) {\n\t      scope.$watch(attr.ngValue, setOptionValue);\n\t    } else if (angular.isDefined(attr.value)) {\n\t      setOptionValue(attr.value);\n\t    } else {\n\t      scope.$watch(function() { return element.text(); }, setOptionValue);\n\t    }\n\t\n\t    scope.$$postDigest(function() {\n\t      attr.$observe('selected', function(selected) {\n\t        if (!angular.isDefined(selected)) return;\n\t        if (selected) {\n\t          if (!selectCtrl.isMultiple) {\n\t            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n\t          }\n\t          selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n\t        } else {\n\t          selectCtrl.deselect(optionCtrl.hashKey);\n\t        }\n\t        selectCtrl.refreshViewValue();\n\t        selectCtrl.ngModel.$render();\n\t      });\n\t    });\n\t\n\t    $mdButtonInkRipple.attach(scope, element);\n\t    configureAria();\n\t\n\t    function setOptionValue(newValue, oldValue) {\n\t      var oldHashKey = selectCtrl.hashGetter(oldValue, scope);\n\t      var newHashKey = selectCtrl.hashGetter(newValue, scope);\n\t\n\t      optionCtrl.hashKey = newHashKey;\n\t      optionCtrl.value = newValue;\n\t\n\t      selectCtrl.removeOption(oldHashKey, optionCtrl);\n\t      selectCtrl.addOption(newHashKey, optionCtrl);\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);\n\t    });\n\t\n\t    function configureAria() {\n\t      var ariaAttrs = {\n\t        'role': 'option',\n\t        'aria-selected': 'false'\n\t      };\n\t\n\t      if (!element[0].hasAttribute('id')) {\n\t        ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();\n\t      }\n\t      element.attr(ariaAttrs);\n\t    }\n\t  }\n\t\n\t  function OptionController($element) {\n\t    this.selected = false;\n\t    this.setSelected = function(isSelected) {\n\t      if (isSelected && !this.selected) {\n\t        $element.attr({\n\t          'selected': 'selected',\n\t          'aria-selected': 'true'\n\t        });\n\t      } else if (!isSelected && this.selected) {\n\t        $element.removeAttr('selected');\n\t        $element.attr('aria-selected', 'false');\n\t      }\n\t      this.selected = isSelected;\n\t    };\n\t  }\n\t\n\t}\n\tOptionDirective.$inject = [\"$mdButtonInkRipple\", \"$mdUtil\"];\n\t\n\tfunction OptgroupDirective() {\n\t  return {\n\t    restrict: 'E',\n\t    compile: compile\n\t  };\n\t  function compile(el, attrs) {\n\t    var labelElement = el.find('label');\n\t    if (!labelElement.length) {\n\t      labelElement = angular.element('<label>');\n\t      el.prepend(labelElement);\n\t    }\n\t    if (attrs.label) labelElement.text(attrs.label);\n\t  }\n\t}\n\t\n\tfunction SelectProvider($$interimElementProvider) {\n\t  selectDefaultOptions.$inject = [\"$mdSelect\", \"$mdConstant\", \"$$rAF\", \"$mdUtil\", \"$mdTheming\", \"$timeout\", \"$window\"];\n\t  return $$interimElementProvider('$mdSelect')\n\t    .setDefaults({\n\t      methods: ['target'],\n\t      options: selectDefaultOptions\n\t    });\n\t\n\t  /* @ngInject */\n\t  function selectDefaultOptions($mdSelect, $mdConstant, $$rAF, $mdUtil, $mdTheming, $timeout, $window ) {\n\t    return {\n\t      parent: 'body',\n\t      onShow: onShow,\n\t      onRemove: onRemove,\n\t      hasBackdrop: true,\n\t      disableParentScroll: true,\n\t      themable: true\n\t    };\n\t\n\t    function onShow(scope, element, opts) {\n\t      if (!opts.target) {\n\t        throw new Error('$mdSelect.show() expected a target element in options.target but got ' +\n\t                        '\"' + opts.target + '\"!');\n\t      }\n\t\n\t      angular.extend(opts, {\n\t        isRemoved: false,\n\t        target: angular.element(opts.target), //make sure it's not a naked dom node\n\t        parent: angular.element(opts.parent),\n\t        selectEl: element.find('md-select-menu'),\n\t        contentEl: element.find('md-content'),\n\t        backdrop: opts.hasBackdrop && angular.element('<md-backdrop class=\"md-select-backdrop md-click-catcher\">')\n\t      });\n\t\n\t      opts.resizeFn = function() {\n\t        $$rAF(function() {\n\t          $$rAF(function() {\n\t            animateSelect(scope, element, opts);\n\t          });\n\t        });\n\t      };\n\t\n\t      angular.element($window).on('resize', opts.resizeFn);\n\t      angular.element($window).on('orientationchange', opts.resizeFn);\n\t\n\t\n\t      configureAria();\n\t\n\t      element.removeClass('md-leave');\n\t\n\t      var optionNodes = opts.selectEl[0].getElementsByTagName('md-option');\n\t\n\t      if (opts.loadingAsync && opts.loadingAsync.then) {\n\t        opts.loadingAsync.then(function() {\n\t          scope.$$loadingAsyncDone = true;\n\t          // Give ourselves two frames for the progress loader to clear out.\n\t          $$rAF(function() {\n\t            $$rAF(function() {\n\t              // Don't go forward if the select has been removed in this time...\n\t              if (opts.isRemoved) return;\n\t              animateSelect(scope, element, opts);\n\t            });\n\t          });\n\t        });\n\t      } else if (opts.loadingAsync) {\n\t        scope.$$loadingAsyncDone = true;\n\t      }\n\t\n\t      if (opts.disableParentScroll && !$mdUtil.getClosest(opts.target, 'MD-DIALOG')) {\n\t        opts.restoreScroll = $mdUtil.disableScrollAround(opts.element);\n\t      } else {\n\t        opts.disableParentScroll = false;\n\t      }\n\t      // Only activate click listeners after a short time to stop accidental double taps/clicks\n\t      // from clicking the wrong item\n\t      $timeout(activateInteraction, 75, false);\n\t\n\t      if (opts.backdrop) {\n\t        $mdTheming.inherit(opts.backdrop, opts.parent);\n\t        opts.parent.append(opts.backdrop);\n\t      }\n\t      opts.parent.append(element);\n\t\n\t      // Give the select a frame to 'initialize' in the DOM,\n\t      // so we can read its height/width/position\n\t      $$rAF(function() {\n\t        $$rAF(function() {\n\t          if (opts.isRemoved) return;\n\t          animateSelect(scope, element, opts);\n\t        });\n\t      });\n\t\n\t      return $mdUtil.transitionEndPromise(opts.selectEl, {timeout: 350});\n\t\n\t      function configureAria() {\n\t        opts.target.attr('aria-expanded', 'true');\n\t      }\n\t\n\t      function activateInteraction() {\n\t        if (opts.isRemoved) return;\n\t        var selectCtrl = opts.selectEl.controller('mdSelectMenu') || {};\n\t        element.addClass('md-clickable');\n\t\n\t        opts.backdrop && opts.backdrop.on('click', function(e) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t          opts.restoreFocus = false;\n\t          scope.$apply($mdSelect.cancel);\n\t        });\n\t\n\t        // Escape to close\n\t        opts.selectEl.on('keydown', function(ev) {\n\t          switch (ev.keyCode) {\n\t            case $mdConstant.KEY_CODE.SPACE:\n\t            case $mdConstant.KEY_CODE.ENTER:\n\t              var option = $mdUtil.getClosest(ev.target, 'md-option');\n\t              if (option) {\n\t                opts.selectEl.triggerHandler({\n\t                  type: 'click',\n\t                  target: option\n\t                });\n\t                ev.preventDefault();\n\t              }\n\t              break;\n\t            case $mdConstant.KEY_CODE.TAB:\n\t            case $mdConstant.KEY_CODE.ESCAPE:\n\t              ev.preventDefault();\n\t              opts.restoreFocus = true;\n\t              scope.$apply($mdSelect.cancel);\n\t          }\n\t        });\n\t\n\t        // Cycling of options, and closing on enter\n\t        opts.selectEl.on('keydown', function(ev) {\n\t          switch (ev.keyCode) {\n\t            case $mdConstant.KEY_CODE.UP_ARROW: return focusPrevOption();\n\t            case $mdConstant.KEY_CODE.DOWN_ARROW: return focusNextOption();\n\t            default:\n\t              if (ev.keyCode >= 31 && ev.keyCode <= 90) {\n\t                var optNode = opts.selectEl.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);\n\t                optNode && optNode.focus();\n\t              }\n\t          }\n\t        });\n\t\n\t\n\t        function focusOption(direction) {\n\t          var optionsArray = $mdUtil.nodesToArray(optionNodes);\n\t          var index = optionsArray.indexOf(opts.focusedNode);\n\t          if (index === -1) {\n\t            // We lost the previously focused element, reset to first option\n\t            index = 0;\n\t          } else if (direction === 'next' && index < optionsArray.length - 1) {\n\t            index++;\n\t          } else if (direction === 'prev' && index > 0) {\n\t            index--;\n\t          }\n\t          var newOption = opts.focusedNode = optionsArray[index];\n\t          newOption && newOption.focus();\n\t        }\n\t        function focusNextOption() {\n\t          focusOption('next');\n\t        }\n\t        function focusPrevOption() {\n\t          focusOption('prev');\n\t        }\n\t\n\t        opts.selectEl.on('click', checkCloseMenu);\n\t        opts.selectEl.on('keydown', function(e) {\n\t          if (e.keyCode == 32 || e.keyCode == 13) {\n\t            checkCloseMenu();\n\t          }\n\t        });\n\t\n\t        function checkCloseMenu() {\n\t          if (!selectCtrl.isMultiple) {\n\t            opts.restoreFocus = true;\n\t            scope.$evalAsync(function() {\n\t              $mdSelect.hide(selectCtrl.ngModel.$viewValue);\n\t            });\n\t          }\n\t        }\n\t      }\n\t\n\t    }\n\t\n\t    function onRemove(scope, element, opts) {\n\t      opts.isRemoved = true;\n\t      element.addClass('md-leave')\n\t        .removeClass('md-clickable');\n\t      opts.target.attr('aria-expanded', 'false');\n\t\n\t\n\t      angular.element($window).off('resize', opts.resizeFn);\n\t      angular.element($window).off('orientationchange', opts.resizefn);\n\t      opts.resizeFn = undefined;\n\t\n\t      var mdSelect = opts.selectEl.controller('mdSelect');\n\t      if (mdSelect) {\n\t        mdSelect.setLabelText(opts.selectEl.controller('mdSelectMenu').selectedLabels());\n\t      }\n\t\n\t      return $mdUtil.transitionEndPromise(element, { timeout: 350 }).then(function() {\n\t        element.removeClass('md-active');\n\t        opts.backdrop && opts.backdrop.remove();\n\t        if (element[0].parentNode === opts.parent[0]) {\n\t          opts.parent[0].removeChild(element[0]); // use browser to avoid $destroy event\n\t        }\n\t        if (opts.disableParentScroll) {\n\t          opts.restoreScroll();\n\t        }\n\t        if (opts.restoreFocus) opts.target.focus();\n\t        mdSelect && mdSelect.triggerClose();\n\t      });\n\t    }\n\t\n\t    function animateSelect(scope, element, opts) {\n\t      var containerNode = element[0],\n\t          targetNode = opts.target[0].firstElementChild.firstElementChild, // target the first span, functioning as the label\n\t          parentNode = opts.parent[0],\n\t          selectNode = opts.selectEl[0],\n\t          contentNode = opts.contentEl[0],\n\t          parentRect = parentNode.getBoundingClientRect(),\n\t          targetRect = targetNode.getBoundingClientRect(),\n\t          shouldOpenAroundTarget = false,\n\t          bounds = {\n\t            left: parentRect.left + SELECT_EDGE_MARGIN,\n\t            top: SELECT_EDGE_MARGIN,\n\t            bottom: parentRect.height - SELECT_EDGE_MARGIN,\n\t            right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)\n\t          },\n\t          spaceAvailable = {\n\t            top: targetRect.top - bounds.top,\n\t            left: targetRect.left - bounds.left,\n\t            right: bounds.right - (targetRect.left + targetRect.width),\n\t            bottom: bounds.bottom - (targetRect.top + targetRect.height)\n\t          },\n\t          maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,\n\t          isScrollable = contentNode.scrollHeight > contentNode.offsetHeight,\n\t          selectedNode = selectNode.querySelector('md-option[selected]'),\n\t          optionNodes = selectNode.getElementsByTagName('md-option'),\n\t          optgroupNodes = selectNode.getElementsByTagName('md-optgroup');\n\t\n\t\n\t      var centeredNode;\n\t      // If a selected node, center around that\n\t      if (selectedNode) {\n\t        centeredNode = selectedNode;\n\t      // If there are option groups, center around the first option group\n\t      } else if (optgroupNodes.length) {\n\t        centeredNode = optgroupNodes[0];\n\t      // Otherwise, center around the first optionNode\n\t      } else if (optionNodes.length){\n\t        centeredNode = optionNodes[0];\n\t      // In case there are no options, center on whatever's in there... (eg progress indicator)\n\t      } else {\n\t        centeredNode = contentNode.firstElementChild || contentNode;\n\t      }\n\t\n\t      if (contentNode.offsetWidth > maxWidth) {\n\t        contentNode.style['max-width'] = maxWidth + 'px';\n\t      }\n\t      if (shouldOpenAroundTarget) {\n\t        contentNode.style['min-width'] = targetRect.width + 'px';\n\t      }\n\t\n\t      // Remove padding before we compute the position of the menu\n\t      if (isScrollable) {\n\t        selectNode.classList.add('md-overflow');\n\t      }\n\t\n\t      // Get the selectMenuRect *after* max-width is possibly set above\n\t      var selectMenuRect = selectNode.getBoundingClientRect();\n\t      var centeredRect = getOffsetRect(centeredNode);\n\t\n\t      if (centeredNode) {\n\t        var centeredStyle = $window.getComputedStyle(centeredNode);\n\t        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;\n\t        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;\n\t      }\n\t\n\t      var focusedNode = centeredNode;\n\t      if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {\n\t        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;\n\t      }\n\t\n\t      if (isScrollable) {\n\t        var scrollBuffer = contentNode.offsetHeight / 2;\n\t        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;\n\t\n\t        if (spaceAvailable.top < scrollBuffer) {\n\t          contentNode.scrollTop = Math.min(\n\t            centeredRect.top,\n\t            contentNode.scrollTop + scrollBuffer - spaceAvailable.top\n\t          );\n\t        } else if (spaceAvailable.bottom < scrollBuffer) {\n\t          contentNode.scrollTop = Math.max(\n\t            centeredRect.top + centeredRect.height - selectMenuRect.height,\n\t            contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom\n\t          );\n\t        }\n\t      }\n\t\n\t      var left, top, transformOrigin;\n\t      if (shouldOpenAroundTarget) {\n\t        left = targetRect.left;\n\t        top = targetRect.top + targetRect.height;\n\t        transformOrigin = '50% 0';\n\t        if (top + selectMenuRect.height > bounds.bottom) {\n\t          top = targetRect.top - selectMenuRect.height;\n\t          transformOrigin = '50% 100%';\n\t        }\n\t      } else {\n\t        left = targetRect.left + centeredRect.left - centeredRect.paddingLeft;\n\t        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -\n\t          centeredRect.top + contentNode.scrollTop);\n\t\n\t\n\t        transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' +\n\t        (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';\n\t\n\t        containerNode.style.minWidth = targetRect.width + centeredRect.paddingLeft +\n\t          centeredRect.paddingRight + 'px';\n\t      }\n\t\n\t      // Keep left and top within the window\n\t      var containerRect = containerNode.getBoundingClientRect();\n\t      containerNode.style.left = clamp(bounds.left, left, bounds.right - containerRect.width) + 'px';\n\t      containerNode.style.top = clamp(bounds.top, top, bounds.bottom - containerRect.height) + 'px';\n\t      selectNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;\n\t\n\t      selectNode.style[$mdConstant.CSS.TRANSFORM] = 'scale(' +\n\t        Math.min(targetRect.width / selectMenuRect.width, 1.0) + ',' +\n\t        Math.min(targetRect.height / selectMenuRect.height, 1.0) +\n\t      ')';\n\t\n\t\n\t      $$rAF(function() {\n\t        element.addClass('md-active');\n\t        selectNode.style[$mdConstant.CSS.TRANSFORM] = '';\n\t        if (focusedNode) {\n\t          opts.focusedNode = focusedNode;\n\t          focusedNode.focus();\n\t        }\n\t      });\n\t    }\n\t\n\t  }\n\t\n\t  function clamp(min, n, max) {\n\t    return Math.max(min, Math.min(n, max));\n\t  }\n\t\n\t  function getOffsetRect(node) {\n\t    return node ? {\n\t      left: node.offsetLeft,\n\t      top: node.offsetTop,\n\t      width: node.offsetWidth,\n\t      height: node.offsetHeight\n\t    } : { left: 0, top: 0, width: 0, height: 0 };\n\t  }\n\t}\n\tSelectProvider.$inject = [\"$$interimElementProvider\"];\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.sidenav\n\t *\n\t * @description\n\t * A Sidenav QP component.\n\t */\n\tangular.module('material.components.sidenav', [\n\t    'material.core',\n\t    'material.components.backdrop'\n\t  ])\n\t  .factory('$mdSidenav', SidenavService )\n\t  .directive('mdSidenav', SidenavDirective)\n\t  .directive('mdSidenavFocus', SidenavFocusDirective)\n\t  .controller('$mdSidenavController', SidenavController);\n\t\n\t\n\t/**\n\t * @private\n\t * @ngdoc service\n\t * @name $mdSidenav\n\t * @module material.components.sidenav\n\t *\n\t * @description\n\t * `$mdSidenav` makes it easy to interact with multiple sidenavs\n\t * in an app.\n\t *\n\t * @usage\n\t * <hljs lang=\"js\">\n\t * // Async lookup for sidenav instance; will resolve when the instance is available\n\t * $mdSidenav(componentId).then(function(instance) {\n\t *   $log.debug( componentId + \"is now ready\" );\n\t * });\n\t * // Async toggle the given sidenav;\n\t * // when instance is known ready and lazy lookup is not needed.\n\t * $mdSidenav(componentId)\n\t *    .toggle()\n\t *    .then(function(){\n\t *      $log.debug('toggled');\n\t *    });\n\t * // Async open the given sidenav\n\t * $mdSidenav(componentId)\n\t *    .open()\n\t *    .then(function(){\n\t *      $log.debug('opened');\n\t *    });\n\t * // Async close the given sidenav\n\t * $mdSidenav(componentId)\n\t *    .close()\n\t *    .then(function(){\n\t *      $log.debug('closed');\n\t *    });\n\t * // Sync check to see if the specified sidenav is set to be open\n\t * $mdSidenav(componentId).isOpen();\n\t * // Sync check to whether given sidenav is locked open\n\t * // If this is true, the sidenav will be open regardless of close()\n\t * $mdSidenav(componentId).isLockedOpen();\n\t * </hljs>\n\t */\n\tfunction SidenavService($mdComponentRegistry, $q) {\n\t  return function(handle) {\n\t\n\t    // Lookup the controller instance for the specified sidNav instance\n\t    var self;\n\t    var errorMsg = \"SideNav '\" + handle + \"' is not available!\";\n\t    var instance = $mdComponentRegistry.get(handle);\n\t\n\t    if(!instance) {\n\t      $mdComponentRegistry.notFoundError(handle);\n\t    }\n\t\n\t    return self = {\n\t      // -----------------\n\t      // Sync methods\n\t      // -----------------\n\t      isOpen: function() {\n\t        return instance && instance.isOpen();\n\t      },\n\t      isLockedOpen: function() {\n\t        return instance && instance.isLockedOpen();\n\t      },\n\t      // -----------------\n\t      // Async methods\n\t      // -----------------\n\t      toggle: function() {\n\t        return instance ? instance.toggle() : $q.reject(errorMsg);\n\t      },\n\t      open: function() {\n\t        return instance ? instance.open() : $q.reject(errorMsg);\n\t      },\n\t      close: function() {\n\t        return instance ? instance.close() : $q.reject(errorMsg);\n\t      },\n\t      then : function( callbackFn ) {\n\t        var promise = instance ? $q.when(instance) : waitForInstance();\n\t        return promise.then( callbackFn || angular.noop );\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Deferred lookup of component instance using $component registry\n\t     */\n\t    function waitForInstance() {\n\t      return $mdComponentRegistry\n\t                .when(handle)\n\t                .then(function( it ){\n\t                  instance = it;\n\t                  return it;\n\t                });\n\t    }\n\t  };\n\t}\n\tSidenavService.$inject = [\"$mdComponentRegistry\", \"$q\"];\n\t/**\n\t * @ngdoc directive\n\t * @name mdSidenavFocus\n\t * @module material.components.sidenav\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * `$mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.\n\t * This is completely optional, as the sidenav itself is focused by default.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-sidenav>\n\t *   <form>\n\t *     <md-input-container>\n\t *       <label for=\"testInput\">Label</label>\n\t *       <input id=\"testInput\" type=\"text\" md-sidenav-focus>\n\t *     </md-input-container>\n\t *   </form>\n\t * </md-sidenav>\n\t * </hljs>\n\t **/\n\tfunction SidenavFocusDirective() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^mdSidenav',\n\t    link: function(scope, element, attr, sidenavCtrl) {\n\t      sidenavCtrl.focusElement(element);\n\t    }\n\t  };\n\t}\n\t/**\n\t * @ngdoc directive\n\t * @name mdSidenav\n\t * @module material.components.sidenav\n\t * @restrict E\n\t *\n\t * @description\n\t *\n\t * A Sidenav component that can be opened and closed programatically.\n\t *\n\t * By default, upon opening it will slide out on top of the main content area.\n\t *\n\t * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.\n\t * It can be overridden with the `md-sidenav-focus` directive on the child element you want focused.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div layout=\"row\" ng-controller=\"MyController\">\n\t *   <md-sidenav md-component-id=\"left\" class=\"md-sidenav-left\">\n\t *     Left Nav!\n\t *   </md-sidenav>\n\t *\n\t *   <md-content>\n\t *     Center Content\n\t *     <md-button ng-click=\"openLeftMenu()\">\n\t *       Open Left Menu\n\t *     </md-button>\n\t *   </md-content>\n\t *\n\t *   <md-sidenav md-component-id=\"right\"\n\t *     md-is-locked-open=\"$mdMedia('min-width: 333px')\"\n\t *     class=\"md-sidenav-right\">\n\t *     <form>\n\t *       <md-input-container>\n\t *         <label for=\"testInput\">Test input</label>\n\t *         <input id=\"testInput\" type=\"text\"\n\t *                ng-model=\"data\" md-sidenav-focus>\n\t *       </md-input-container>\n\t *     </form>\n\t *   </md-sidenav>\n\t * </div>\n\t * </hljs>\n\t *\n\t * <hljs lang=\"js\">\n\t * var app = angular.module('myApp', ['ngMaterial']);\n\t * app.controller('MyController', function($scope, $mdSidenav) {\n\t *   $scope.openLeftMenu = function() {\n\t *     $mdSidenav('left').toggle();\n\t *   };\n\t * });\n\t * </hljs>\n\t *\n\t * @param {expression=} md-is-open A model bound to whether the sidenav is opened.\n\t * @param {string=} md-component-id componentId to use with $mdSidenav service.\n\t * @param {expression=} md-is-locked-open When this expression evalutes to true,\n\t * the sidenav 'locks open': it falls into the content's flow instead\n\t * of appearing over it. This overrides the `is-open` attribute.\n\t *\n\t * The $mdMedia() service is exposed to the is-locked-open attribute, which\n\t * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.\n\t * Examples:\n\t *\n\t *   - `<md-sidenav md-is-locked-open=\"shouldLockOpen\"></md-sidenav>`\n\t *   - `<md-sidenav md-is-locked-open=\"$mdMedia('min-width: 1000px')\"></md-sidenav>`\n\t *   - `<md-sidenav md-is-locked-open=\"$mdMedia('sm')\"></md-sidenav>` (locks open on small screens)\n\t */\n\tfunction SidenavDirective($timeout, $animate, $parse, $log, $mdMedia, $mdConstant, $compile, $mdTheming, $q, $document) {\n\t  return {\n\t    restrict: 'E',\n\t    scope: {\n\t      isOpen: '=?mdIsOpen'\n\t    },\n\t    controller: '$mdSidenavController',\n\t    compile: function(element) {\n\t      element.addClass('md-closed');\n\t      element.attr('tabIndex', '-1');\n\t      return postLink;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Directive Post Link function...\n\t   */\n\t  function postLink(scope, element, attr, sidenavCtrl) {\n\t    var lastParentOverFlow;\n\t    var triggeringElement = null;\n\t    var promise = $q.when(true);\n\t\n\t    var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);\n\t    var isLocked = function() {\n\t      return isLockedOpenParsed(scope.$parent, {\n\t        $media: function(arg) {\n\t          $log.warn(\"$media is deprecated for is-locked-open. Use $mdMedia instead.\");\n\t          return $mdMedia(arg);\n\t        },\n\t        $mdMedia: $mdMedia\n\t      });\n\t    };\n\t    var backdrop = $compile(\n\t      '<md-backdrop class=\"md-sidenav-backdrop md-opaque ng-enter\">'\n\t    )(scope);\n\t\n\t    element.on('$destroy', sidenavCtrl.destroy);\n\t    $mdTheming.inherit(backdrop, element);\n\t\n\t    scope.$watch(isLocked, updateIsLocked);\n\t    scope.$watch('isOpen', updateIsOpen);\n\t\n\t\n\t    // Publish special accessor for the Controller instance\n\t    sidenavCtrl.$toggleOpen = toggleOpen;\n\t    sidenavCtrl.focusElement( sidenavCtrl.focusElement() || element );\n\t\n\t    /**\n\t     * Toggle the DOM classes to indicate `locked`\n\t     * @param isLocked\n\t     */\n\t    function updateIsLocked(isLocked, oldValue) {\n\t      scope.isLockedOpen = isLocked;\n\t      if (isLocked === oldValue) {\n\t        element.toggleClass('md-locked-open', !!isLocked);\n\t      } else {\n\t        $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');\n\t      }\n\t      backdrop.toggleClass('md-locked-open', !!isLocked);\n\t    }\n\t\n\t    /**\n\t     * Toggle the SideNav view and attach/detach listeners\n\t     * @param isOpen\n\t     */\n\t    function updateIsOpen(isOpen) {\n\t      var parent = element.parent();\n\t\n\t      parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);\n\t      backdrop[isOpen ? 'on' : 'off']('click', close);\n\t\n\t      if ( isOpen ) {\n\t        // Capture upon opening..\n\t        triggeringElement = $document[0].activeElement;\n\t      }\n\t      var focusEl = sidenavCtrl.focusElement();\n\t\n\t      disableParentScroll(isOpen);\n\t\n\t      return promise = $q.all([\n\t                isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop),\n\t                $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')\n\t              ])\n\t              .then(function() {\n\t                // Perform focus when animations are ALL done...\n\t                if (scope.isOpen) {\n\t                  focusEl && focusEl.focus();\n\t                }\n\t              });\n\t    }\n\t\n\t    /**\n\t     * Prevent parent scrolling (when the SideNav is open)\n\t     */\n\t    function disableParentScroll(disabled) {\n\t      var parent = element.parent();\n\t      if ( disabled ) {\n\t        lastParentOverFlow = parent.css('overflow');\n\t        parent.css('overflow', 'hidden');\n\t      } else if (angular.isDefined(lastParentOverFlow)) {\n\t        parent.css('overflow', lastParentOverFlow);\n\t        lastParentOverFlow = undefined;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Toggle the sideNav view and publish a promise to be resolved when\n\t     * the view animation finishes.\n\t     *\n\t     * @param isOpen\n\t     * @returns {*}\n\t     */\n\t    function toggleOpen( isOpen ) {\n\t      if (scope.isOpen == isOpen ) {\n\t\n\t        return $q.when(true);\n\t\n\t      } else {\n\t        var deferred = $q.defer();\n\t\n\t        // Toggle value to force an async `updateIsOpen()` to run\n\t        scope.isOpen = isOpen;\n\t\n\t        $timeout(function() {\n\t\n\t          // When the current `updateIsOpen()` animation finishes\n\t          promise.then(function(result) {\n\t\n\t            if ( !scope.isOpen ) {\n\t              // reset focus to originating element (if available) upon close\n\t              triggeringElement && triggeringElement.focus();\n\t              triggeringElement = null;\n\t            }\n\t\n\t            deferred.resolve(result);\n\t          });\n\t\n\t        },0,false);\n\t\n\t        return deferred.promise;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Auto-close sideNav when the `escape` key is pressed.\n\t     * @param evt\n\t     */\n\t    function onKeyDown(ev) {\n\t      var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);\n\t      return isEscape ? close(ev) : $q.when(true);\n\t    }\n\t\n\t    /**\n\t     * With backdrop `clicks` or `escape` key-press, immediately\n\t     * apply the CSS close transition... Then notify the controller\n\t     * to close() and perform its own actions.\n\t     */\n\t    function close(ev) {\n\t      ev.preventDefault();\n\t      ev.stopPropagation();\n\t\n\t      return sidenavCtrl.close();\n\t    }\n\t\n\t  }\n\t}\n\tSidenavDirective.$inject = [\"$timeout\", \"$animate\", \"$parse\", \"$log\", \"$mdMedia\", \"$mdConstant\", \"$compile\", \"$mdTheming\", \"$q\", \"$document\"];\n\t\n\t/*\n\t * @private\n\t * @ngdoc controller\n\t * @name SidenavController\n\t * @module material.components.sidenav\n\t *\n\t */\n\tfunction SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {\n\t\n\t  var self = this,\n\t      focusElement;\n\t\n\t  // Use Default internal method until overridden by directive postLink\n\t\n\t  // Synchronous getters\n\t  self.isOpen = function() { return !!$scope.isOpen; };\n\t  self.isLockedOpen = function() { return !!$scope.isLockedOpen; };\n\t\n\t  // Async actions\n\t  self.open   = function() { return self.$toggleOpen( true );  };\n\t  self.close  = function() { return self.$toggleOpen( false ); };\n\t  self.toggle = function() { return self.$toggleOpen( !$scope.isOpen );  };\n\t  self.focusElement = function(el) {\n\t    if ( angular.isDefined(el) ) {\n\t      focusElement = el;\n\t    }\n\t    return focusElement;\n\t  };\n\t\n\t  self.$toggleOpen = function() { return $q.when($scope.isOpen); };\n\t\n\t  self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);\n\t}\n\tSidenavController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$mdComponentRegistry\", \"$q\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  /**\n\t   * @ngdoc module\n\t   * @name material.components.slider\n\t   */\n\t  angular.module('material.components.slider', [\n\t    'material.core'\n\t  ])\n\t  .directive('mdSlider', SliderDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdSlider\n\t * @module material.components.slider\n\t * @restrict E\n\t * @description\n\t * The `<md-slider>` component allows the user to choose from a range of\n\t * values.\n\t *\n\t * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n\t * the slider is in the accent color by default. The primary color palette may be used with\n\t * the `md-primary` class.\n\t *\n\t * It has two modes: 'normal' mode, where the user slides between a wide range\n\t * of values, and 'discrete' mode, where the user slides between only a few\n\t * select values.\n\t *\n\t * To enable discrete mode, add the `md-discrete` attribute to a slider,\n\t * and use the `step` attribute to change the distance between\n\t * values the user is allowed to pick.\n\t *\n\t * @usage\n\t * <h4>Normal Mode</h4>\n\t * <hljs lang=\"html\">\n\t * <md-slider ng-model=\"myValue\" min=\"5\" max=\"500\">\n\t * </md-slider>\n\t * </hljs>\n\t * <h4>Discrete Mode</h4>\n\t * <hljs lang=\"html\">\n\t * <md-slider md-discrete ng-model=\"myDiscreteValue\" step=\"10\" min=\"10\" max=\"130\">\n\t * </md-slider>\n\t * </hljs>\n\t *\n\t * @param {boolean=} md-discrete Whether to enable discrete mode.\n\t * @param {number=} step The distance between values the user is allowed to pick. Default 1.\n\t * @param {number=} min The minimum value the user is allowed to pick. Default 0.\n\t * @param {number=} max The maximum value the user is allowed to pick. Default 100.\n\t */\n\tfunction SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse) {\n\t  return {\n\t    scope: {},\n\t    require: '?ngModel',\n\t    template:\n\t      '<div class=\"md-slider-wrapper\">\\\n\t        <div class=\"md-track-container\">\\\n\t          <div class=\"md-track\"></div>\\\n\t          <div class=\"md-track md-track-fill\"></div>\\\n\t          <div class=\"md-track-ticks\"></div>\\\n\t        </div>\\\n\t        <div class=\"md-thumb-container\">\\\n\t          <div class=\"md-thumb\"></div>\\\n\t          <div class=\"md-focus-thumb\"></div>\\\n\t          <div class=\"md-focus-ring\"></div>\\\n\t          <div class=\"md-sign\">\\\n\t            <span class=\"md-thumb-text\"></span>\\\n\t          </div>\\\n\t          <div class=\"md-disabled-thumb\"></div>\\\n\t        </div>\\\n\t      </div>',\n\t    compile: compile\n\t  };\n\t\n\t  // **********************************************************\n\t  // Private Methods\n\t  // **********************************************************\n\t\n\t  function compile (tElement, tAttrs) {\n\t    tElement.attr({\n\t      tabIndex: 0,\n\t      role: 'slider'\n\t    });\n\t\n\t    $mdAria.expect(tElement, 'aria-label');\n\t\n\t    return postLink;\n\t  }\n\t\n\t  function postLink(scope, element, attr, ngModelCtrl) {\n\t    $mdTheming(element);\n\t    ngModelCtrl = ngModelCtrl || {\n\t      // Mock ngModelController if it doesn't exist to give us\n\t      // the minimum functionality needed\n\t      $setViewValue: function(val) {\n\t        this.$viewValue = val;\n\t        this.$viewChangeListeners.forEach(function(cb) { cb(); });\n\t      },\n\t      $parsers: [],\n\t      $formatters: [],\n\t      $viewChangeListeners: []\n\t    };\n\t\n\t    var isDisabledParsed = attr.ngDisabled && $parse(attr.ngDisabled);\n\t    var isDisabledGetter = isDisabledParsed ?\n\t      function() { return isDisabledParsed(scope.$parent); } :\n\t      angular.noop;\n\t    var thumb = angular.element(element[0].querySelector('.md-thumb'));\n\t    var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));\n\t    var thumbContainer = thumb.parent();\n\t    var trackContainer = angular.element(element[0].querySelector('.md-track-container'));\n\t    var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));\n\t    var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));\n\t    var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);\n\t\n\t    // Default values, overridable by attrs\n\t    angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);\n\t    angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);\n\t    angular.isDefined(attr.step)? attr.$observe('step', updateStep) : updateStep(1);\n\t\n\t    // We have to manually stop the $watch on ngDisabled because it exists\n\t    // on the parent scope, and won't be automatically destroyed when\n\t    // the component is destroyed.\n\t    var stopDisabledWatch = angular.noop;\n\t    if (attr.ngDisabled) {\n\t      stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);\n\t    }\n\t\n\t    $mdGesture.register(element, 'drag');\n\t\n\t    element\n\t      .on('keydown', keydownListener)\n\t      .on('$md.pressdown', onPressDown)\n\t      .on('$md.pressup', onPressUp)\n\t      .on('$md.dragstart', onDragStart)\n\t      .on('$md.drag', onDrag)\n\t      .on('$md.dragend', onDragEnd);\n\t\n\t    // On resize, recalculate the slider's dimensions and re-render\n\t    function updateAll() {\n\t      refreshSliderDimensions();\n\t      ngModelRender();\n\t      redrawTicks();\n\t    }\n\t    setTimeout(updateAll);\n\t\n\t    var debouncedUpdateAll = $$rAF.throttle(updateAll);\n\t    angular.element($window).on('resize', debouncedUpdateAll);\n\t\n\t    scope.$on('$destroy', function() {\n\t      angular.element($window).off('resize', debouncedUpdateAll);\n\t      stopDisabledWatch();\n\t    });\n\t\n\t    ngModelCtrl.$render = ngModelRender;\n\t    ngModelCtrl.$viewChangeListeners.push(ngModelRender);\n\t    ngModelCtrl.$formatters.push(minMaxValidator);\n\t    ngModelCtrl.$formatters.push(stepValidator);\n\t\n\t    /**\n\t     * Attributes\n\t     */\n\t    var min;\n\t    var max;\n\t    var step;\n\t    function updateMin(value) {\n\t      min = parseFloat(value);\n\t      element.attr('aria-valuemin', value);\n\t      updateAll();\n\t    }\n\t    function updateMax(value) {\n\t      max = parseFloat(value);\n\t      element.attr('aria-valuemax', value);\n\t      updateAll();\n\t    }\n\t    function updateStep(value) {\n\t      step = parseFloat(value);\n\t      redrawTicks();\n\t    }\n\t    function updateAriaDisabled(isDisabled) {\n\t      element.attr('aria-disabled', !!isDisabled);\n\t    }\n\t\n\t    // Draw the ticks with canvas.\n\t    // The alternative to drawing ticks with canvas is to draw one element for each tick,\n\t    // which could quickly become a performance bottleneck.\n\t    var tickCanvas, tickCtx;\n\t    function redrawTicks() {\n\t      if (!angular.isDefined(attr.mdDiscrete)) return;\n\t\n\t      var numSteps = Math.floor( (max - min) / step );\n\t      if (!tickCanvas) {\n\t        var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);\n\t        tickCanvas = angular.element('<canvas style=\"position:absolute;\">');\n\t        tickCtx = tickCanvas[0].getContext('2d');\n\t        tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';\n\t        tickContainer.append(tickCanvas);\n\t      }\n\t      var dimensions = getSliderDimensions();\n\t      tickCanvas[0].width = dimensions.width;\n\t      tickCanvas[0].height = dimensions.height;\n\t\n\t      var distance;\n\t      for (var i = 0; i <= numSteps; i++) {\n\t        distance = Math.floor(dimensions.width * (i / numSteps));\n\t        tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);\n\t      }\n\t    }\n\t\n\t\n\t    /**\n\t     * Refreshing Dimensions\n\t     */\n\t    var sliderDimensions = {};\n\t    refreshSliderDimensions();\n\t    function refreshSliderDimensions() {\n\t      sliderDimensions = trackContainer[0].getBoundingClientRect();\n\t    }\n\t    function getSliderDimensions() {\n\t      throttledRefreshDimensions();\n\t      return sliderDimensions;\n\t    }\n\t\n\t    /**\n\t     * left/right arrow listener\n\t     */\n\t    function keydownListener(ev) {\n\t      if(element[0].hasAttribute('disabled')) {\n\t        return;\n\t      }\n\t\n\t      var changeAmount;\n\t      if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {\n\t        changeAmount = -step;\n\t      } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {\n\t        changeAmount = step;\n\t      }\n\t      if (changeAmount) {\n\t        if (ev.metaKey || ev.ctrlKey || ev.altKey) {\n\t          changeAmount *= 4;\n\t        }\n\t        ev.preventDefault();\n\t        ev.stopPropagation();\n\t        scope.$evalAsync(function() {\n\t          setModelValue(ngModelCtrl.$viewValue + changeAmount);\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\n\t     * ngModel setters and validators\n\t     */\n\t    function setModelValue(value) {\n\t      ngModelCtrl.$setViewValue( minMaxValidator(stepValidator(value)) );\n\t    }\n\t    function ngModelRender() {\n\t      if (isNaN(ngModelCtrl.$viewValue)) {\n\t        ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;\n\t      }\n\t\n\t      var percent = (ngModelCtrl.$viewValue - min) / (max - min);\n\t      scope.modelValue = ngModelCtrl.$viewValue;\n\t      element.attr('aria-valuenow', ngModelCtrl.$viewValue);\n\t      setSliderPercent(percent);\n\t      thumbText.text( ngModelCtrl.$viewValue );\n\t    }\n\t\n\t    function minMaxValidator(value) {\n\t      if (angular.isNumber(value)) {\n\t        return Math.max(min, Math.min(max, value));\n\t      }\n\t    }\n\t    function stepValidator(value) {\n\t      if (angular.isNumber(value)) {\n\t        var formattedValue = (Math.round(value / step) * step);\n\t        // Format to 3 digits after the decimal point - fixes #2015.\n\t        return (Math.round(formattedValue * 1000) / 1000);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * @param percent 0-1\n\t     */\n\t    function setSliderPercent(percent) {\n\t      activeTrack.css('width', (percent * 100) + '%');\n\t      thumbContainer.css(\n\t        'left',\n\t        (percent * 100) + '%'\n\t      );\n\t      element.toggleClass('md-min', percent === 0);\n\t    }\n\t\n\t\n\t    /**\n\t     * Slide listeners\n\t     */\n\t    var isDragging = false;\n\t    var isDiscrete = angular.isDefined(attr.mdDiscrete);\n\t\n\t    function onPressDown(ev) {\n\t      if (isDisabledGetter()) return;\n\t\n\t      element.addClass('active');\n\t      element[0].focus();\n\t      refreshSliderDimensions();\n\t\n\t      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n\t      var closestVal = minMaxValidator( stepValidator(exactVal) );\n\t      scope.$apply(function() {\n\t        setModelValue( closestVal );\n\t        setSliderPercent( valueToPercent(closestVal));\n\t      });\n\t    }\n\t    function onPressUp(ev) {\n\t      if (isDisabledGetter()) return;\n\t\n\t      element.removeClass('dragging active');\n\t\n\t      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n\t      var closestVal = minMaxValidator( stepValidator(exactVal) );\n\t      scope.$apply(function() {\n\t        setModelValue(closestVal);\n\t        ngModelRender();\n\t      });\n\t    }\n\t    function onDragStart(ev) {\n\t      if (isDisabledGetter()) return;\n\t      isDragging = true;\n\t      ev.stopPropagation();\n\t\n\t      element.addClass('dragging');\n\t      setSliderFromEvent(ev);\n\t    }\n\t    function onDrag(ev) {\n\t      if (!isDragging) return;\n\t      ev.stopPropagation();\n\t      setSliderFromEvent(ev);\n\t    }\n\t    function onDragEnd(ev) {\n\t      if (!isDragging) return;\n\t      ev.stopPropagation();\n\t      isDragging = false;\n\t    }\n\t\n\t    function setSliderFromEvent(ev) {\n\t      // While panning discrete, update only the\n\t      // visual positioning but not the model value.\n\t      if ( isDiscrete ) adjustThumbPosition( ev.pointer.x );\n\t      else              doSlide( ev.pointer.x );\n\t    }\n\t\n\t    /**\n\t     * Slide the UI by changing the model value\n\t     * @param x\n\t     */\n\t    function doSlide( x ) {\n\t      scope.$evalAsync( function() {\n\t        setModelValue( percentToValue( positionToPercent(x) ));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Slide the UI without changing the model (while dragging/panning)\n\t     * @param x\n\t     */\n\t    function adjustThumbPosition( x ) {\n\t      var exactVal = percentToValue( positionToPercent( x ));\n\t      var closestVal = minMaxValidator( stepValidator(exactVal) );\n\t      setSliderPercent( positionToPercent(x) );\n\t      thumbText.text( closestVal );\n\t    }\n\t\n\t    /**\n\t     * Convert horizontal position on slider to percentage value of offset from beginning...\n\t     * @param x\n\t     * @returns {number}\n\t     */\n\t    function positionToPercent( x ) {\n\t      return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));\n\t    }\n\t\n\t    /**\n\t     * Convert percentage offset on slide to equivalent model value\n\t     * @param percent\n\t     * @returns {*}\n\t     */\n\t    function percentToValue( percent ) {\n\t      return (min + percent * (max - min));\n\t    }\n\t\n\t    function valueToPercent( val ) {\n\t      return (val - min)/(max - min);\n\t    }\n\t  }\n\t}\n\tSliderDirective.$inject = [\"$$rAF\", \"$window\", \"$mdAria\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdGesture\", \"$parse\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.subheader\n\t * @description\n\t * SubHeader module\n\t *\n\t *  Subheaders are special list tiles that delineate distinct sections of a\n\t *  list or grid list and are typically related to the current filtering or\n\t *  sorting criteria. Subheader tiles are either displayed inline with tiles or\n\t *  can be associated with content, for example, in an adjacent column.\n\t *\n\t *  Upon scrolling, subheaders remain pinned to the top of the screen and remain\n\t *  pinned until pushed on or off screen by the next subheader. @see [Material\n\t *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)\n\t *\n\t *  > To improve the visual grouping of content, use the system color for your subheaders.\n\t *\n\t */\n\tangular.module('material.components.subheader', [\n\t  'material.core',\n\t  'material.components.sticky'\n\t])\n\t  .directive('mdSubheader', MdSubheaderDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdSubheader\n\t * @module material.components.subheader\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-subheader>` directive is a subheader for a section. By default it is sticky.\n\t * You can make it not sticky by applying the `md-no-sticky` class to the subheader.\n\t *\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-subheader>Online Friends</md-subheader>\n\t * </hljs>\n\t */\n\t\n\tfunction MdSubheaderDirective($mdSticky, $compile, $mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    transclude: true,\n\t    template: \n\t      '<h2 class=\"md-subheader\">' +\n\t        '<div class=\"md-subheader-inner\">' +\n\t          '<span class=\"md-subheader-content\"></span>' +\n\t        '</div>' +\n\t      '</h2>',\n\t    compile: function(element, attr, transclude) {\n\t      return function postLink(scope, element, attr) {\n\t        $mdTheming(element);\n\t        var outerHTML = element[0].outerHTML;\n\t\n\t        function getContent(el) {\n\t          return angular.element(el[0].querySelector('.md-subheader-content'));\n\t        }\n\t\n\t        // Transclude the user-given contents of the subheader\n\t        // the conventional way.\n\t        transclude(scope, function(clone) {\n\t          getContent(element).append(clone);\n\t        });\n\t\n\t        // Create another clone, that uses the outer and inner contents\n\t        // of the element, that will be 'stickied' as the user scrolls.\n\t        if (!element.hasClass('md-no-sticky')) {\n\t          transclude(scope, function(clone) {\n\t            var stickyClone = $compile(angular.element(outerHTML))(scope);\n\t            getContent(stickyClone).append(clone);\n\t            $mdSticky(scope, element, stickyClone);\n\t          });\n\t        }\n\t      };\n\t    }\n\t  };\n\t}\n\tMdSubheaderDirective.$inject = [\"$mdSticky\", \"$compile\", \"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/*\n\t * @ngdoc module\n\t * @name material.components.sticky\n\t * @description\n\t *\n\t * Sticky effects for md\n\t */\n\t\n\tangular.module('material.components.sticky', [\n\t  'material.core',\n\t  'material.components.content'\n\t])\n\t  .factory('$mdSticky', MdSticky);\n\t\n\t/*\n\t * @ngdoc service\n\t * @name $mdSticky\n\t * @module material.components.sticky\n\t *\n\t * @description\n\t * The `$mdSticky`service provides a mixin to make elements sticky.\n\t *\n\t * @returns A `$mdSticky` function that takes three arguments:\n\t *   - `scope`\n\t *   - `element`: The element that will be 'sticky'\n\t *   - `elementClone`: A clone of the element, that will be shown\n\t *     when the user starts scrolling past the original element.\n\t *     If not provided, it will use the result of `element.clone()`.\n\t */\n\t\n\tfunction MdSticky($document, $mdConstant, $compile, $$rAF, $mdUtil) {\n\t\n\t  var browserStickySupport = checkStickySupport();\n\t\n\t  /**\n\t   * Registers an element as sticky, used internally by directives to register themselves\n\t   */\n\t  return function registerStickyElement(scope, element, stickyClone) {\n\t    var contentCtrl = element.controller('mdContent');\n\t    if (!contentCtrl) return;\n\t\n\t    if (browserStickySupport) {\n\t      element.css({\n\t        position: browserStickySupport,\n\t        top: 0,\n\t        'z-index': 2\n\t      });\n\t    } else {\n\t      var $$sticky = contentCtrl.$element.data('$$sticky');\n\t      if (!$$sticky) {\n\t        $$sticky = setupSticky(contentCtrl);\n\t        contentCtrl.$element.data('$$sticky', $$sticky);\n\t      }\n\t\n\t      var deregister = $$sticky.add(element, stickyClone || element.clone());\n\t      scope.$on('$destroy', deregister);\n\t    }\n\t  };\n\t\n\t  function setupSticky(contentCtrl) {\n\t    var contentEl = contentCtrl.$element;\n\t\n\t    // Refresh elements is very expensive, so we use the debounced\n\t    // version when possible.\n\t    var debouncedRefreshElements = $$rAF.throttle(refreshElements);\n\t\n\t    // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,\n\t    // more reliable than `scroll` on android.\n\t    setupAugmentedScrollEvents(contentEl);\n\t    contentEl.on('$scrollstart', debouncedRefreshElements);\n\t    contentEl.on('$scroll', onScroll);\n\t\n\t    var self;\n\t    var stickyBaseoffset = contentEl.prop('offsetTop');\n\t    return self = {\n\t      prev: null,\n\t      current: null, //the currently stickied item\n\t      next: null,\n\t      items: [],\n\t      add: add,\n\t      refreshElements: refreshElements\n\t    };\n\t\n\t    /***************\n\t     * Public\n\t     ***************/\n\t    // Add an element and its sticky clone to this content's sticky collection\n\t    function add(element, stickyClone) {\n\t      stickyClone.addClass('md-sticky-clone');\n\t      stickyClone.css('top', stickyBaseoffset + 'px');\n\t\n\t      var item = {\n\t        element: element,\n\t        clone: stickyClone\n\t      };\n\t      self.items.push(item);\n\t\n\t      contentEl.parent().prepend(item.clone);\n\t\n\t      debouncedRefreshElements();\n\t\n\t      return function remove() {\n\t        self.items.forEach(function(item, index) {\n\t          if (item.element[0] === element[0]) {\n\t            self.items.splice(index, 1);\n\t            item.clone.remove();\n\t          }\n\t        });\n\t        debouncedRefreshElements();\n\t      };\n\t    }\n\t\n\t    function refreshElements() {\n\t      // Sort our collection of elements by their current position in the DOM.\n\t      // We need to do this because our elements' order of being added may not\n\t      // be the same as their order of display.\n\t      self.items.forEach(refreshPosition);\n\t      self.items = self.items.sort(function(a, b) {\n\t        return a.top < b.top ? -1 : 1;\n\t      });\n\t\n\t      // Find which item in the list should be active, \n\t      // based upon the content's current scroll position\n\t      var item;\n\t      var currentScrollTop = contentEl.prop('scrollTop');\n\t      for (var i = self.items.length - 1; i >= 0; i--) {\n\t        if (currentScrollTop > self.items[i].top) {\n\t          item = self.items[i];\n\t          break;\n\t        }\n\t      }\n\t      setCurrentItem(item);\n\t    }\n\t\n\t\n\t    /***************\n\t     * Private\n\t     ***************/\n\t\n\t    // Find the `top` of an item relative to the content element,\n\t    // and also the height.\n\t    function refreshPosition(item) {\n\t      // Find the top of an item by adding to the offsetHeight until we reach the \n\t      // content element.\n\t      var current = item.element[0];\n\t      item.top = 0;\n\t      item.left = 0;\n\t      while (current && current !== contentEl[0]) {\n\t        item.top += current.offsetTop;\n\t        item.left += current.offsetLeft;\n\t        current = current.offsetParent;\n\t      }\n\t      item.height = item.element.prop('offsetHeight');\n\t      item.clone.css('margin-left', item.left + 'px');\n\t      if ($mdUtil.floatingScrollbars()) {\n\t        item.clone.css('margin-right', '0');\n\t      }\n\t    }\n\t\n\t\n\t    // As we scroll, push in and select the correct sticky element.\n\t    function onScroll() {\n\t      var scrollTop = contentEl.prop('scrollTop');\n\t      var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);\n\t      onScroll.prevScrollTop = scrollTop;\n\t\n\t      // At the top?\n\t      if (scrollTop === 0) {\n\t        setCurrentItem(null);\n\t\n\t      // Going to next item?\n\t      } else if (isScrollingDown && self.next) {\n\t        if (self.next.top - scrollTop <= 0) {\n\t          // Sticky the next item if we've scrolled past its position.\n\t          setCurrentItem(self.next);\n\t        } else if (self.current) {\n\t          // Push the current item up when we're almost at the next item.\n\t          if (self.next.top - scrollTop <= self.next.height) {\n\t            translate(self.current, self.next.top - self.next.height - scrollTop);\n\t          } else {\n\t            translate(self.current, null);\n\t          }\n\t        }\n\t        \n\t      // Scrolling up with a current sticky item?\n\t      } else if (!isScrollingDown && self.current) {\n\t        if (scrollTop < self.current.top) {\n\t          // Sticky the previous item if we've scrolled up past\n\t          // the original position of the currently stickied item.\n\t          setCurrentItem(self.prev);\n\t        }\n\t        // Scrolling up, and just bumping into the item above (just set to current)?\n\t        // If we have a next item bumping into the current item, translate\n\t        // the current item up from the top as it scrolls into view.\n\t        if (self.current && self.next) {\n\t          if (scrollTop >= self.next.top - self.current.height) {\n\t            translate(self.current, self.next.top - scrollTop - self.current.height);\n\t          } else {\n\t            translate(self.current, null);\n\t          }\n\t        }\n\t      }\n\t    }\n\t     \n\t   function setCurrentItem(item) {\n\t     if (self.current === item) return;\n\t     // Deactivate currently active item\n\t     if (self.current) {\n\t       translate(self.current, null);\n\t       setStickyState(self.current, null);\n\t     }\n\t\n\t     // Activate new item if given\n\t     if (item) {\n\t       setStickyState(item, 'active');\n\t     }\n\t\n\t     self.current = item;\n\t     var index = self.items.indexOf(item);\n\t     // If index === -1, index + 1 = 0. It works out.\n\t     self.next = self.items[index + 1];\n\t     self.prev = self.items[index - 1];\n\t     setStickyState(self.next, 'next');\n\t     setStickyState(self.prev, 'prev');\n\t   }\n\t\n\t   function setStickyState(item, state) {\n\t     if (!item || item.state === state) return;\n\t     if (item.state) {\n\t       item.clone.attr('sticky-prev-state', item.state);\n\t       item.element.attr('sticky-prev-state', item.state);\n\t     }\n\t     item.clone.attr('sticky-state', state);\n\t     item.element.attr('sticky-state', state);\n\t     item.state = state;\n\t   }\n\t\n\t   function translate(item, amount) {\n\t     if (!item) return;\n\t     if (amount === null || amount === undefined) {\n\t       if (item.translateY) {\n\t         item.translateY = null;\n\t         item.clone.css($mdConstant.CSS.TRANSFORM, '');\n\t       }\n\t     } else {\n\t       item.translateY = amount;\n\t       item.clone.css(\n\t         $mdConstant.CSS.TRANSFORM, \n\t         'translate3d(' + item.left + 'px,' + amount + 'px,0)'\n\t       );\n\t     }\n\t   }\n\t  }\n\t\n\t  // Function to check for browser sticky support\n\t  function checkStickySupport($el) {\n\t    var stickyProp;\n\t    var testEl = angular.element('<div>');\n\t    $document[0].body.appendChild(testEl[0]);\n\t\n\t    var stickyProps = ['sticky', '-webkit-sticky'];\n\t    for (var i = 0; i < stickyProps.length; ++i) {\n\t      testEl.css({position: stickyProps[i], top: 0, 'z-index': 2});\n\t      if (testEl.css('position') == stickyProps[i]) {\n\t        stickyProp = stickyProps[i];\n\t        break;\n\t      }\n\t    }\n\t    testEl.remove();\n\t    return stickyProp;\n\t  }\n\t\n\t  // Android 4.4 don't accurately give scroll events.\n\t  // To fix this problem, we setup a fake scroll event. We say:\n\t  // > If a scroll or touchmove event has happened in the last DELAY milliseconds, \n\t  //   then send a `$scroll` event every animationFrame.\n\t  // Additionally, we add $scrollstart and $scrollend events.\n\t  function setupAugmentedScrollEvents(element) {\n\t    var SCROLL_END_DELAY = 200;\n\t    var isScrolling;\n\t    var lastScrollTime;\n\t    element.on('scroll touchmove', function() {\n\t      if (!isScrolling) {\n\t        isScrolling = true;\n\t        $$rAF(loopScrollEvent);\n\t        element.triggerHandler('$scrollstart');\n\t      }\n\t      element.triggerHandler('$scroll');\n\t      lastScrollTime = +$mdUtil.now();\n\t    });\n\t\n\t    function loopScrollEvent() {\n\t      if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {\n\t        isScrolling = false;\n\t        element.triggerHandler('$scrollend');\n\t      } else {\n\t        element.triggerHandler('$scroll');\n\t        $$rAF(loopScrollEvent);\n\t      }\n\t    }\n\t  }\n\t\n\t}\n\tMdSticky.$inject = [\"$document\", \"$mdConstant\", \"$compile\", \"$$rAF\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.swipe\n\t * @description Swipe module!\n\t */\n\t/**\n\t * @ngdoc directive\n\t * @module material.components.swipe\n\t * @name mdSwipeLeft\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The md-swipe-left directives allows you to specify custom behavior when an element is swiped\n\t * left.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div md-swipe-left=\"onSwipeLeft()\">Swipe me left!</div>\n\t * </hljs>\n\t */\n\t/**\n\t * @ngdoc directive\n\t * @module material.components.swipe\n\t * @name mdSwipeRight\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The md-swipe-right directives allows you to specify custom behavior when an element is swiped\n\t * right.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div md-swipe-right=\"onSwipeRight()\">Swipe me right!</div>\n\t * </hljs>\n\t */\n\t\n\tangular.module('material.components.swipe', ['material.core'])\n\t    .directive('mdSwipeLeft', getDirective('SwipeLeft'))\n\t    .directive('mdSwipeRight', getDirective('SwipeRight'));\n\t\n\tfunction getDirective(name) {\n\t  var directiveName = 'md' + name;\n\t  var eventName = '$md.' + name.toLowerCase();\n\t\n\t    DirectiveFactory.$inject = [\"$parse\"];\n\t  return DirectiveFactory;\n\t\n\t  /* @ngInject */\n\t  function DirectiveFactory($parse) {\n\t      return { restrict: 'A', link: postLink };\n\t      function postLink(scope, element, attr) {\n\t        var fn = $parse(attr[directiveName]);\n\t        element.on(eventName, function(ev) {\n\t          scope.$apply(function() { fn(scope, { $event: ev }); });\n\t        });\n\t      }\n\t    }\n\t}\n\t\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @private\n\t * @ngdoc module\n\t * @name material.components.switch\n\t */\n\t\n\tangular.module('material.components.switch', [\n\t  'material.core',\n\t  'material.components.checkbox'\n\t])\n\t  .directive('mdSwitch', MdSwitch);\n\t\n\t/**\n\t * @private\n\t * @ngdoc directive\n\t * @module material.components.switch\n\t * @name mdSwitch\n\t * @restrict E\n\t *\n\t * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n\t *\n\t * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n\t * the switch is in the accent color by default. The primary color palette may be used with\n\t * the `md-primary` class.\n\t *\n\t * @param {string} ng-model Assignable angular expression to data-bind to.\n\t * @param {string=} name Property name of the form under which the control is published.\n\t * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n\t * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n\t * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n\t * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.\n\t * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-switch ng-model=\"isActive\" aria-label=\"Finished?\">\n\t *   Finished ?\n\t * </md-switch>\n\t *\n\t * <md-switch md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n\t *   No Ink Effects\n\t * </md-switch>\n\t *\n\t * <md-switch ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n\t *   Disabled\n\t * </md-switch>\n\t *\n\t * </hljs>\n\t */\n\tfunction MdSwitch(mdCheckboxDirective, $mdTheming, $mdUtil, $document, $mdConstant, $parse, $$rAF, $mdGesture) {\n\t  var checkboxDirective = mdCheckboxDirective[0];\n\t\n\t  return {\n\t    restrict: 'E',\n\t    priority:210, // Run before ngAria\n\t    transclude: true,\n\t    template:\n\t      '<div class=\"md-container\">' +\n\t        '<div class=\"md-bar\"></div>' +\n\t        '<div class=\"md-thumb-container\">' +\n\t          '<div class=\"md-thumb\" md-ink-ripple md-ink-ripple-checkbox></div>' +\n\t        '</div>'+\n\t      '</div>' +\n\t      '<div ng-transclude class=\"md-label\">' +\n\t      '</div>',\n\t    require: '?ngModel',\n\t    compile: compile\n\t  };\n\t\n\t  function compile(element, attr) {\n\t    var checkboxLink = checkboxDirective.compile(element, attr);\n\t    // no transition on initial load\n\t    element.addClass('md-dragging');\n\t\n\t    return function (scope, element, attr, ngModel) {\n\t      ngModel = ngModel || $mdUtil.fakeNgModel();\n\t      var disabledGetter = $parse(attr.ngDisabled);\n\t      var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));\n\t      var switchContainer = angular.element(element[0].querySelector('.md-container'));\n\t\n\t      // no transition on initial load\n\t      $$rAF(function() {\n\t        element.removeClass('md-dragging');\n\t      });\n\t\n\t      checkboxLink(scope, element, attr, ngModel);\n\t\n\t      if (angular.isDefined(attr.ngDisabled)) {\n\t        scope.$watch(disabledGetter, function(isDisabled) {\n\t          element.attr('tabindex', isDisabled ? -1 : 0);\n\t        });\n\t      }\n\t\n\t      // These events are triggered by setup drag\n\t      $mdGesture.register(switchContainer, 'drag');\n\t      switchContainer\n\t        .on('$md.dragstart', onDragStart)\n\t        .on('$md.drag', onDrag)\n\t        .on('$md.dragend', onDragEnd);\n\t\n\t      var drag;\n\t      function onDragStart(ev) {\n\t        // Don't go if ng-disabled===true\n\t        if (disabledGetter(scope)) return;\n\t        ev.stopPropagation();\n\t\n\t        element.addClass('md-dragging');\n\t        drag = {\n\t          width: thumbContainer.prop('offsetWidth')\n\t        };\n\t        element.removeClass('transition');\n\t      }\n\t\n\t      function onDrag(ev) {\n\t        if (!drag) return;\n\t        ev.stopPropagation();\n\t        ev.srcEvent && ev.srcEvent.preventDefault();\n\t\n\t        var percent = ev.pointer.distanceX / drag.width;\n\t\n\t        //if checked, start from right. else, start from left\n\t        var translate = ngModel.$viewValue ?  1 + percent : percent;\n\t        // Make sure the switch stays inside its bounds, 0-1%\n\t        translate = Math.max(0, Math.min(1, translate));\n\t\n\t        thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100*translate) + '%,0,0)');\n\t        drag.translate = translate;\n\t      }\n\t\n\t      function onDragEnd(ev) {\n\t        if (!drag) return;\n\t        ev.stopPropagation();\n\t\n\t        element.removeClass('md-dragging');\n\t        thumbContainer.css($mdConstant.CSS.TRANSFORM, '');\n\t\n\t        // We changed if there is no distance (this is a click a click),\n\t        // or if the drag distance is >50% of the total.\n\t        var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5;\n\t        if (isChanged) {\n\t          applyModelValue(!ngModel.$viewValue);\n\t        }\n\t        drag = null;\n\t      }\n\t\n\t      function applyModelValue(newValue) {\n\t        scope.$apply(function() {\n\t          ngModel.$setViewValue(newValue);\n\t          ngModel.$render();\n\t        });\n\t      }\n\t\n\t    };\n\t  }\n\t\n\t\n\t}\n\tMdSwitch.$inject = [\"mdCheckboxDirective\", \"$mdTheming\", \"$mdUtil\", \"$document\", \"$mdConstant\", \"$parse\", \"$$rAF\", \"$mdGesture\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.tabs\n\t * @description\n\t *\n\t *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.\n\t *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.\n\t *\n\t *  Features include support for:\n\t *\n\t *  - static or dynamic tabs,\n\t *  - responsive designs,\n\t *  - accessibility support (ARIA),\n\t *  - tab pagination,\n\t *  - external or internal tab content,\n\t *  - focus indicators and arrow-key navigations,\n\t *  - programmatic lookup and access to tab controllers, and\n\t *  - dynamic transitions through different tab contents.\n\t *\n\t */\n\t/*\n\t * @see js folder for tabs implementation\n\t */\n\tangular.module('material.components.tabs', [\n\t  'material.core',\n\t  'material.components.icon'\n\t]);\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.toast\n\t * @description\n\t * Toast\n\t */\n\tangular.module('material.components.toast', [\n\t  'material.core',\n\t  'material.components.button'\n\t])\n\t  .directive('mdToast', MdToastDirective)\n\t  .provider('$mdToast', MdToastProvider);\n\t\n\tfunction MdToastDirective() {\n\t  return {\n\t    restrict: 'E'\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $mdToast\n\t * @module material.components.toast\n\t *\n\t * @description\n\t * `$mdToast` is a service to build a toast notification on any position\n\t * on the screen with an optional duration, and provides a simple promise API.\n\t *\n\t *\n\t * ## Restrictions on custom toasts\n\t * - The toast's template must have an outer `<md-toast>` element.\n\t * - For a toast action, use element with class `md-action`.\n\t * - Add the class `md-capsule` for curved corners.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div ng-controller=\"MyController\">\n\t *   <md-button ng-click=\"openToast()\">\n\t *     Open a Toast!\n\t *   </md-button>\n\t * </div>\n\t * </hljs>\n\t *\n\t * <hljs lang=\"js\">\n\t * var app = angular.module('app', ['ngMaterial']);\n\t * app.controller('MyController', function($scope, $mdToast) {\n\t *   $scope.openToast = function($event) {\n\t *     $mdToast.show($mdToast.simple().content('Hello!'));\n\t *     // Could also do $mdToast.showSimple('Hello');\n\t *   };\n\t * });\n\t * </hljs>\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdToast#showSimple\n\t * \n\t * @description\n\t * Convenience method which builds and shows a simple toast.\n\t *\n\t * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n\t * rejected with `$mdToast.cancel()`.\n\t *\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdToast#simple\n\t *\n\t * @description\n\t * Builds a preconfigured toast.\n\t *\n\t * @returns {obj} a `$mdToastPreset` with the chainable configuration methods:\n\t *\n\t * - $mdToastPreset#content(string) - sets toast content to string\n\t * - $mdToastPreset#action(string) - adds an action button, which resolves the promise returned from `show()` if clicked.\n\t * - $mdToastPreset#highlightAction(boolean) - sets action button to be highlighted\n\t * - $mdToastPreset#capsule(boolean) - adds 'md-capsule' class to the toast (curved corners)\n\t * - $mdToastPreset#theme(boolean) - sets the theme on the toast to theme (default is `$mdThemingProvider`'s default theme)\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdToast#updateContent\n\t * \n\t * @description\n\t * Updates the content of an existing toast. Useful for updating things like counts, etc.\n\t *\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdToast#build\n\t *\n\t * @description\n\t * Creates a custom `$mdToastPreset` that you can configure.\n\t *\n\t * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).\n\t */\n\t\n\t /**\n\t * @ngdoc method\n\t * @name $mdToast#show\n\t *\n\t * @description Shows the toast.\n\t *\n\t * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`\n\t * and `build()`, or an options object with the following properties:\n\t *\n\t *   - `templateUrl` - `{string=}`: The url of an html template file that will\n\t *     be used as the content of the toast. Restrictions: the template must\n\t *     have an outer `md-toast` element.\n\t *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n\t *     template string.\n\t *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n\t *     This scope will be destroyed when the toast is removed unless `preserveScope` is set to true.\n\t *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n\t *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay\n\t *     active before automatically closing.  Set to 0 or false to have the toast stay open until\n\t *     closed manually. Default: 3000.\n\t *   - `position` - `{string=}`: Where to place the toast. Available: any combination\n\t *     of 'bottom', 'left', 'top', 'right', 'fit'. Default: 'bottom left'.\n\t *   - `controller` - `{string=}`: The controller to associate with this toast.\n\t *     The controller will be injected the local `$hideToast`, which is a function\n\t *     used to hide the toast.\n\t *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n\t *     be used as names of values to inject into the controller. For example,\n\t *     `locals: {three: 3}` would inject `three` into the controller with the value\n\t *     of 3.\n\t *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in. These values will not be available until after initialization.\n\t *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n\t *     and the toast will not open until the promises resolve.\n\t *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n\t *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending\n\t *     to the root element of the application.\n\t *\n\t * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n\t * rejected with `$mdToast.cancel()`.\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdToast#hide\n\t *\n\t * @description\n\t * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.\n\t *\n\t * @param {*=} response An argument for the resolved promise.\n\t *\n\t * @returns {promise} a promise that is called when the existing element is removed from the DOM\n\t *\n\t */\n\t\n\t/**\n\t * @ngdoc method\n\t * @name $mdToast#cancel\n\t *\n\t * @description\n\t * Hide the existing toast and reject the promise returned from\n\t * `$mdToast.show()`.\n\t *\n\t * @param {*=} response An argument for the rejected promise.\n\t *\n\t * @returns {promise} a promise that is called when the existing element is removed from the DOM\n\t *\n\t */\n\t\n\tfunction MdToastProvider($$interimElementProvider) {\n\t  var activeToastContent;\n\t  var $mdToast = $$interimElementProvider('$mdToast')\n\t    .setDefaults({\n\t      methods: ['position', 'hideDelay', 'capsule' ],\n\t      options: toastDefaultOptions\n\t    })\n\t    .addPreset('simple', {\n\t      argOption: 'content',\n\t      methods: ['content', 'action', 'highlightAction', 'theme', 'parent'],\n\t      options: /* @ngInject */ [\"$mdToast\", \"$mdTheming\", function($mdToast, $mdTheming) {\n\t        var opts = {\n\t          template: [\n\t            '<md-toast md-theme=\"{{ toast.theme }}\" ng-class=\"{\\'md-capsule\\': toast.capsule}\">',\n\t              '<span flex>{{ toast.content }}</span>',\n\t              '<md-button class=\"md-action\" ng-if=\"toast.action\" ng-click=\"toast.resolve()\" ng-class=\"{\\'md-highlight\\': toast.highlightAction}\">',\n\t                '{{ toast.action }}',\n\t              '</md-button>',\n\t            '</md-toast>'\n\t          ].join(''),\n\t          controller: /* @ngInject */ [\"$scope\", function mdToastCtrl($scope) {\n\t            var self = this;\n\t            $scope.$watch(function() { return activeToastContent; }, function() {\n\t              self.content = activeToastContent;\n\t            });\n\t            this.resolve = function() {\n\t              $mdToast.hide();\n\t            };\n\t          }],\n\t          theme: $mdTheming.defaultTheme(),\n\t          controllerAs: 'toast',\n\t          bindToController: true\n\t        };\n\t        return opts;\n\t      }]\n\t    })\n\t    .addMethod('updateContent', function(newContent) {\n\t      activeToastContent = newContent;\n\t    });\n\t\n\t  toastDefaultOptions.$inject = [\"$timeout\", \"$animate\", \"$mdToast\", \"$mdUtil\"];\n\t    return $mdToast;\n\t\n\t  /* @ngInject */\n\t  function toastDefaultOptions($timeout, $animate, $mdToast, $mdUtil) {\n\t    return {\n\t      onShow: onShow,\n\t      onRemove: onRemove,\n\t      position: 'bottom left',\n\t      themable: true,\n\t      hideDelay: 3000\n\t    };\n\t\n\t    function onShow(scope, element, options) {\n\t      element = $mdUtil.extractElementByName(element, 'md-toast');\n\t\n\t      // 'top left' -> 'md-top md-left'\n\t      activeToastContent = options.content;\n\t      element.addClass(options.position.split(' ').map(function(pos) {\n\t        return 'md-' + pos;\n\t      }).join(' '));\n\t      options.parent.addClass(toastOpenClass(options.position));\n\t\n\t      options.onSwipe = function(ev, gesture) {\n\t        //Add swipeleft/swiperight class to element so it can animate correctly\n\t        element.addClass('md-' + ev.type.replace('$md.',''));\n\t        $timeout($mdToast.cancel);\n\t      };\n\t      element.on('$md.swipeleft $md.swiperight', options.onSwipe);\n\t      return $animate.enter(element, options.parent);\n\t    }\n\t\n\t    function onRemove(scope, element, options) {\n\t      element.off('$md.swipeleft $md.swiperight', options.onSwipe);\n\t      options.parent.removeClass(toastOpenClass(options.position));\n\t      return $animate.leave(element);\n\t    }\n\t\n\t    function toastOpenClass(position) {\n\t      return 'md-toast-open-' +\n\t        (position.indexOf('top') > -1 ? 'top' : 'bottom');\n\t    }\n\t  }\n\t\n\t}\n\tMdToastProvider.$inject = [\"$$interimElementProvider\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.toolbar\n\t */\n\tangular.module('material.components.toolbar', [\n\t  'material.core',\n\t  'material.components.content'\n\t])\n\t  .directive('mdToolbar', mdToolbarDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdToolbar\n\t * @module material.components.toolbar\n\t * @restrict E\n\t * @description\n\t * `md-toolbar` is used to place a toolbar in your app.\n\t *\n\t * Toolbars are usually used above a content area to display the title of the\n\t * current page, and show relevant action buttons for that page.\n\t *\n\t * You can change the height of the toolbar by adding either the\n\t * `md-medium-tall` or `md-tall` class to the toolbar.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <div layout=\"column\" layout-fill>\n\t *   <md-toolbar>\n\t *\n\t *     <div class=\"md-toolbar-tools\">\n\t *       <span>My App's Title</span>\n\t *\n\t *       <!-- fill up the space between left and right area -->\n\t *       <span flex></span>\n\t *\n\t *       <md-button>\n\t *         Right Bar Button\n\t *       </md-button>\n\t *     </div>\n\t *\n\t *   </md-toolbar>\n\t *   <md-content>\n\t *     Hello!\n\t *   </md-content>\n\t * </div>\n\t * </hljs>\n\t *\n\t * @param {boolean=} md-scroll-shrink Whether the header should shrink away as\n\t * the user scrolls down, and reveal itself as the user scrolls up.\n\t * Note: for scrollShrink to work, the toolbar must be a sibling of a\n\t * `md-content` element, placed before it. See the scroll shrink demo.\n\t *\n\t *\n\t * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's\n\t * shrinking by. For example, if 0.25 is given then the toolbar will shrink\n\t * at one fourth the rate at which the user scrolls down. Default 0.5.\n\t */\n\tfunction mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate, $timeout) {\n\t\n\t  return {\n\t    restrict: 'E',\n\t    controller: angular.noop,\n\t    link: function(scope, element, attr) {\n\t      $mdTheming(element);\n\t\n\t      if (angular.isDefined(attr.mdScrollShrink)) {\n\t        setupScrollShrink();\n\t      }\n\t\n\t      function setupScrollShrink() {\n\t        // Current \"y\" position of scroll\n\t        var y = 0;\n\t        // Store the last scroll top position\n\t        var prevScrollTop = 0;\n\t\n\t        var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;\n\t\n\t        var toolbarHeight;\n\t        var contentElement;\n\t\n\t        var debouncedContentScroll = $$rAF.throttle(onContentScroll);\n\t        var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);\n\t\n\t        // Wait for $mdContentLoaded event from mdContent directive.\n\t        // If the mdContent element is a sibling of our toolbar, hook it up\n\t        // to scroll events.\n\t        scope.$on('$mdContentLoaded', onMdContentLoad);\n\t\n\t        function onMdContentLoad($event, newContentEl) {\n\t          // Toolbar and content must be siblings\n\t          if (element.parent()[0] === newContentEl.parent()[0]) {\n\t            // unhook old content event listener if exists\n\t            if (contentElement) {\n\t              contentElement.off('scroll', debouncedContentScroll);\n\t            }\n\t\n\t            newContentEl.on('scroll', debouncedContentScroll);\n\t            newContentEl.attr('scroll-shrink', 'true');\n\t\n\t            contentElement = newContentEl;\n\t            $$rAF(updateToolbarHeight);\n\t          }\n\t        }\n\t\n\t        function updateToolbarHeight() {\n\t          toolbarHeight = element.prop('offsetHeight');\n\t          // Add a negative margin-top the size of the toolbar to the content el.\n\t          // The content will start transformed down the toolbarHeight amount,\n\t          // so everything looks normal.\n\t          //\n\t          // As the user scrolls down, the content will be transformed up slowly\n\t          // to put the content underneath where the toolbar was.\n\t          var margin =  (-toolbarHeight * shrinkSpeedFactor) + 'px';\n\t          contentElement.css('margin-top', margin);\n\t          contentElement.css('margin-bottom', margin);\n\t\n\t          onContentScroll();\n\t        }\n\t\n\t        function onContentScroll(e) {\n\t          var scrollTop = e ? e.target.scrollTop : prevScrollTop;\n\t\n\t          debouncedUpdateHeight();\n\t\n\t          y = Math.min(\n\t            toolbarHeight / shrinkSpeedFactor,\n\t            Math.max(0, y + scrollTop - prevScrollTop)\n\t          );\n\t\n\t          element.css(\n\t            $mdConstant.CSS.TRANSFORM,\n\t            'translate3d(0,' + (-y * shrinkSpeedFactor) + 'px,0)'\n\t          );\n\t          contentElement.css(\n\t            $mdConstant.CSS.TRANSFORM,\n\t            'translate3d(0,' + ((toolbarHeight - y) * shrinkSpeedFactor) + 'px,0)'\n\t          );\n\t\n\t          prevScrollTop = scrollTop;\n\t\n\t            if (element.hasClass('md-whiteframe-z1')) {\n\t              if (!y) {\n\t                $timeout(function () { $animate.removeClass(element, 'md-whiteframe-z1'); });\n\t              }\n\t            } else {\n\t              if (y) {\n\t                $timeout(function () { $animate.addClass(element, 'md-whiteframe-z1'); });\n\t              }\n\t            }\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t  };\n\t\n\t}\n\tmdToolbarDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdUtil\", \"$mdTheming\", \"$animate\", \"$timeout\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.tooltip\n\t */\n\tangular\n\t    .module('material.components.tooltip', [ 'material.core' ])\n\t    .directive('mdTooltip', MdTooltipDirective);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdTooltip\n\t * @module material.components.tooltip\n\t * @description\n\t * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).\n\t *\n\t * Place a `<md-tooltip>` as a child of the element it describes.\n\t *\n\t * A tooltip will activate when the user focuses, hovers over, or touches the parent.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-button class=\"md-fab md-accent\" aria-label=\"Play\">\n\t *   <md-tooltip>\n\t *     Play Music\n\t *   </md-tooltip>\n\t *   <md-icon icon=\"img/icons/ic_play_arrow_24px.svg\"></md-icon>\n\t * </md-button>\n\t * </hljs>\n\t *\n\t * @param {expression=} md-visible Boolean bound to whether the tooltip is\n\t * currently visible.\n\t * @param {number=} md-delay How many milliseconds to wait to show the tooltip after the user focuses, hovers, or touches the parent. Defaults to 400ms.\n\t * @param {string=} md-direction Which direction would you like the tooltip to go?  Supports left, right, top, and bottom.  Defaults to bottom.\n\t * @param {boolean=} md-autohide If present or provided with a boolean value, the tooltip will hide on mouse leave, regardless of focus\n\t */\n\tfunction MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement,\n\t                            $animate, $q) {\n\t\n\t  var TOOLTIP_SHOW_DELAY = 300;\n\t  var TOOLTIP_WINDOW_EDGE_SPACE = 8;\n\t\n\t  return {\n\t    restrict: 'E',\n\t    transclude: true,\n\t    priority:210, // Before ngAria\n\t    template: '\\\n\t        <div class=\"md-background\"></div>\\\n\t        <div class=\"md-content\" ng-transclude></div>',\n\t    scope: {\n\t      visible: '=?mdVisible',\n\t      delay: '=?mdDelay',\n\t      autohide: '=?mdAutohide'\n\t    },\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr) {\n\t\n\t    $mdTheming(element);\n\t\n\t    var parent        = getParentWithPointerEvents(),\n\t        background    = angular.element(element[0].getElementsByClassName('md-background')[0]),\n\t        content       = angular.element(element[0].getElementsByClassName('md-content')[0]),\n\t        direction     = attr.mdDirection,\n\t        current       = getNearestContentElement(),\n\t        tooltipParent = angular.element(current || document.body),\n\t        debouncedOnResize = $$rAF.throttle(function () { if (scope.visible) positionTooltip(); });\n\t\n\t    return init();\n\t\n\t    function init () {\n\t      setDefaults();\n\t      manipulateElement();\n\t      bindEvents();\n\t      configureWatchers();\n\t      addAriaLabel();\n\t    }\n\t\n\t    function setDefaults () {\n\t      if (!angular.isDefined(attr.mdDelay)) scope.delay = TOOLTIP_SHOW_DELAY;\n\t    }\n\t\n\t    function configureWatchers () {\n\t      scope.$on('$destroy', function() {\n\t        scope.visible = false;\n\t        element.remove();\n\t        angular.element($window).off('resize', debouncedOnResize);\n\t      });\n\t      scope.$watch('visible', function (isVisible) {\n\t        if (isVisible) showTooltip();\n\t        else hideTooltip();\n\t      });\n\t    }\n\t\n\t    function addAriaLabel () {\n\t      if (!parent.attr('aria-label') && !parent.text().trim()) {\n\t        parent.attr('aria-label', element.text().trim());\n\t      }\n\t    }\n\t\n\t    function manipulateElement () {\n\t      element.detach();\n\t      element.attr('role', 'tooltip');\n\t    }\n\t\n\t    function getParentWithPointerEvents () {\n\t      var parent = element.parent();\n\t      while (parent && $window.getComputedStyle(parent[0])['pointer-events'] == 'none') {\n\t        parent = parent.parent();\n\t      }\n\t      return parent;\n\t    }\n\t\n\t     function getNearestContentElement () {\n\t       var current = element.parent()[0];\n\t       // Look for the nearest parent md-content, stopping at the rootElement.\n\t       while (current && current !== $rootElement[0] && current !== document.body) {\n\t         current = current.parentNode;\n\t       }\n\t       return current;\n\t     }\n\t\n\t    function hasComputedStyleValue(key, value) {\n\t        // Check if we should show it or not...\n\t        var computedStyles = $window.getComputedStyle(element[0]);\n\t        return angular.isDefined(computedStyles[key]) && (computedStyles[key] == value);\n\t    }\n\t\n\t    function bindEvents () {\n\t      var mouseActive = false;\n\t      var enterHandler = function() {\n\t        if (!hasComputedStyleValue('pointer-events','none')) {\n\t          setVisible(true);\n\t        }\n\t      };\n\t      var leaveHandler = function () {\n\t        var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');\n\t        if (autohide || mouseActive || ($document[0].activeElement !== parent[0]) ) {\n\t          setVisible(false);\n\t        }\n\t        mouseActive = false;\n\t      };\n\t\n\t      // to avoid `synthetic clicks` we listen to mousedown instead of `click`\n\t      parent.on('mousedown', function() { mouseActive = true; });\n\t      parent.on('focus mouseenter touchstart', enterHandler );\n\t      parent.on('blur mouseleave touchend touchcancel', leaveHandler );\n\t\n\t\n\t      angular.element($window).on('resize', debouncedOnResize);\n\t    }\n\t\n\t    function setVisible (value) {\n\t      setVisible.value = !!value;\n\t      if (!setVisible.queued) {\n\t        if (value) {\n\t          setVisible.queued = true;\n\t          $timeout(function() {\n\t            scope.visible = setVisible.value;\n\t            setVisible.queued = false;\n\t          }, scope.delay);\n\t        } else {\n\t          $timeout(function() { scope.visible = false; });\n\t        }\n\t      }\n\t    }\n\t\n\t    function showTooltip() {\n\t      // Insert the element before positioning it, so we can get the position\n\t      // and check if we should display it\n\t      tooltipParent.append(element);\n\t\n\t      // Check if we should display it or not.\n\t      // This handles hide-* and show-* along with any user defined css\n\t      if ( hasComputedStyleValue('display','none') ) {\n\t        scope.visible = false;\n\t        element.detach();\n\t        return;\n\t      }\n\t\n\t      positionTooltip();\n\t      angular.forEach([element, background, content], function (element) {\n\t        $animate.addClass(element, 'md-show');\n\t      });\n\t    }\n\t\n\t    function hideTooltip() {\n\t      $q.all([\n\t        $animate.removeClass(content, 'md-show'),\n\t        $animate.removeClass(background, 'md-show'),\n\t        $animate.removeClass(element, 'md-show')\n\t      ]).then(function () {\n\t        if (!scope.visible) element.detach();\n\t      });\n\t    }\n\t\n\t    function positionTooltip() {\n\t      var tipRect = $mdUtil.offsetRect(element, tooltipParent);\n\t      var parentRect = $mdUtil.offsetRect(parent, tooltipParent);\n\t      var newPosition = getPosition(direction);\n\t\n\t      // If the user provided a direction, just nudge the tooltip onto the screen\n\t      // Otherwise, recalculate based on 'top' since default is 'bottom'\n\t      if (direction) {\n\t        newPosition = fitInParent(newPosition);\n\t      } else if (newPosition.top > element.prop('offsetParent').scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {\n\t        newPosition = fitInParent(getPosition('top'));\n\t      }\n\t\n\t      element.css({top: newPosition.top + 'px', left: newPosition.left + 'px'});\n\t\n\t      positionBackground();\n\t\n\t      function positionBackground () {\n\t        var size = direction === 'left' || direction === 'right'\n\t              ? Math.sqrt(Math.pow(tipRect.width, 2) + Math.pow(tipRect.height / 2, 2)) * 2\n\t              : Math.sqrt(Math.pow(tipRect.width / 2, 2) + Math.pow(tipRect.height, 2)) * 2,\n\t            position = direction === 'left' ? { left: 100, top: 50 }\n\t              : direction === 'right' ? { left: 0, top: 50 }\n\t              : direction === 'top' ? { left: 50, top: 100 }\n\t              : { left: 50, top: 0 };\n\t        background.css({\n\t          width: size + 'px',\n\t          height: size + 'px',\n\t          left: position.left + '%',\n\t          top: position.top + '%'\n\t        });\n\t      }\n\t\n\t      function fitInParent (pos) {\n\t        var newPosition = { left: pos.left, top: pos.top };\n\t        newPosition.left = Math.min( newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE );\n\t        newPosition.left = Math.max( newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE );\n\t        newPosition.top  = Math.min( newPosition.top,  tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE );\n\t        newPosition.top  = Math.max( newPosition.top,  TOOLTIP_WINDOW_EDGE_SPACE );\n\t        return newPosition;\n\t      }\n\t\n\t      function getPosition (dir) {\n\t        return dir === 'left'\n\t          ? { left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,\n\t              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n\t          : dir === 'right'\n\t          ? { left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,\n\t              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n\t          : dir === 'top'\n\t          ? { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n\t              top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE }\n\t          : { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n\t              top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE };\n\t      }\n\t    }\n\t\n\t  }\n\t\n\t}\n\tMdTooltipDirective.$inject = [\"$timeout\", \"$window\", \"$$rAF\", \"$document\", \"$mdUtil\", \"$mdTheming\", \"$rootElement\", \"$animate\", \"$q\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc module\n\t * @name material.components.whiteframe\n\t */\n\tangular.module('material.components.whiteframe', []);\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .controller('MdAutocompleteCtrl', MdAutocompleteCtrl);\n\t\n\tvar ITEM_HEIGHT = 41,\n\t    MAX_HEIGHT = 5.5 * ITEM_HEIGHT,\n\t    MENU_PADDING = 8;\n\t\n\tfunction MdAutocompleteCtrl ($scope, $element, $mdUtil, $mdConstant, $timeout, $mdTheming, $window,\n\t                             $animate, $rootElement, $attrs) {\n\t  //-- private variables\n\t  var ctrl      = this,\n\t      itemParts = $scope.itemsExpr.split(/ in /i),\n\t      itemExpr  = itemParts[1],\n\t      elements  = null,\n\t      promise   = null,\n\t      cache     = {},\n\t      noBlur    = false,\n\t      selectedItemWatchers = [],\n\t      hasFocus  = false,\n\t      lastCount = 0;\n\t\n\t  //-- public variables with handlers\n\t  defineProperty('hidden', handleHiddenChange, true);\n\t\n\t  //-- public variables\n\t  ctrl.scope      = $scope;\n\t  ctrl.parent     = $scope.$parent;\n\t  ctrl.itemName   = itemParts[0];\n\t  ctrl.matches    = [];\n\t  ctrl.loading    = false;\n\t  ctrl.hidden     = true;\n\t  ctrl.index      = null;\n\t  ctrl.messages   = [];\n\t  ctrl.id         = $mdUtil.nextUid();\n\t  ctrl.isDisabled = null;\n\t  ctrl.isRequired = null;\n\t\n\t  //-- public methods\n\t  ctrl.keydown    = keydown;\n\t  ctrl.blur       = blur;\n\t  ctrl.focus      = focus;\n\t  ctrl.clear      = clearValue;\n\t  ctrl.select     = select;\n\t  ctrl.listEnter  = onListEnter;\n\t  ctrl.listLeave  = onListLeave;\n\t  ctrl.mouseUp    = onMouseup;\n\t  ctrl.getCurrentDisplayValue         = getCurrentDisplayValue;\n\t  ctrl.registerSelectedItemWatcher    = registerSelectedItemWatcher;\n\t  ctrl.unregisterSelectedItemWatcher  = unregisterSelectedItemWatcher;\n\t\n\t  return init();\n\t\n\t  //-- initialization methods\n\t\n\t  /**\n\t   * Initialize the controller, setup watchers, gather elements\n\t   */\n\t  function init () {\n\t    $mdUtil.initOptionalProperties($scope, $attrs, { searchText: null, selectedItem: null } );\n\t    $mdTheming($element);\n\t    configureWatchers();\n\t    $timeout(function () {\n\t      gatherElements();\n\t      focusElement();\n\t      moveDropdown();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Calculates the dropdown's position and applies the new styles to the menu element\n\t   * @returns {*}\n\t   */\n\t  function positionDropdown () {\n\t    if (!elements) return $timeout(positionDropdown, 0, false);\n\t    var hrect  = elements.wrap.getBoundingClientRect(),\n\t        vrect  = elements.snap.getBoundingClientRect(),\n\t        root   = elements.root.getBoundingClientRect(),\n\t        top    = vrect.bottom - root.top,\n\t        bot    = root.bottom - vrect.top,\n\t        left   = hrect.left - root.left,\n\t        width  = hrect.width,\n\t        styles = {\n\t          left:     left + 'px',\n\t          minWidth: width + 'px',\n\t          maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'\n\t        };\n\t    if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {\n\t      styles.top = 'auto';\n\t      styles.bottom = bot + 'px';\n\t      styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';\n\t    } else {\n\t      styles.top = top + 'px';\n\t      styles.bottom = 'auto';\n\t      styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom - hrect.bottom - MENU_PADDING) + 'px';\n\t    }\n\t    elements.$.ul.css(styles);\n\t    $timeout(correctHorizontalAlignment, 0, false);\n\t\n\t    /**\n\t     * Makes sure that the menu doesn't go off of the screen on either side.\n\t     */\n\t    function correctHorizontalAlignment () {\n\t      var dropdown = elements.ul.getBoundingClientRect(),\n\t          styles   = {};\n\t      if (dropdown.right > root.right - MENU_PADDING) {\n\t        styles.left = (hrect.right - dropdown.width) + 'px';\n\t      }\n\t      elements.$.ul.css(styles);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.\n\t   */\n\t  function moveDropdown () {\n\t    if (!elements.$.root.length) return;\n\t    $mdTheming(elements.$.ul);\n\t    elements.$.ul.detach();\n\t    elements.$.root.append(elements.$.ul);\n\t    if ($animate.pin) $animate.pin(elements.$.ul, $rootElement);\n\t  }\n\t\n\t  /**\n\t   * Sends focus to the input element.\n\t   */\n\t  function focusElement () {\n\t    if ($scope.autofocus) elements.input.focus();\n\t  }\n\t\n\t  /**\n\t   * Sets up any watchers used by autocomplete\n\t   */\n\t  function configureWatchers () {\n\t    var wait = parseInt($scope.delay, 10) || 0;\n\t    $attrs.$observe('disabled', function (value) { ctrl.isDisabled = value; });\n\t    $attrs.$observe('required', function (value) { ctrl.isRequired = value !== null; });\n\t    $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);\n\t    registerSelectedItemWatcher(selectedItemChange);\n\t    $scope.$watch('selectedItem', handleSelectedItemChange);\n\t    angular.element($window).on('resize', positionDropdown);\n\t    $scope.$on('$destroy', cleanup);\n\t  }\n\t\n\t  /**\n\t   * Removes any events or leftover elements created by this controller\n\t   */\n\t  function cleanup () {\n\t    angular.element($window).off('resize', positionDropdown);\n\t    elements.$.ul.remove();\n\t  }\n\t\n\t  /**\n\t   * Gathers all of the elements needed for this controller\n\t   */\n\t  function gatherElements () {\n\t    elements = {\n\t      main:  $element[0],\n\t      ul:    $element.find('ul')[0],\n\t      input: $element.find('input')[0],\n\t      wrap:  $element.find('md-autocomplete-wrap')[0],\n\t      root:  document.body\n\t    };\n\t    elements.li = elements.ul.getElementsByTagName('li');\n\t    elements.snap = getSnapTarget();\n\t    elements.$ = getAngularElements(elements);\n\t  }\n\t\n\t  /**\n\t   * Finds the element that the menu will base its position on\n\t   * @returns {*}\n\t   */\n\t  function getSnapTarget () {\n\t    for (var element = $element; element.length; element = element.parent()) {\n\t      if (angular.isDefined(element.attr('md-autocomplete-snap'))) return element[0];\n\t    }\n\t    return elements.wrap;\n\t  }\n\t\n\t  /**\n\t   * Gathers angular-wrapped versions of each element\n\t   * @param elements\n\t   * @returns {{}}\n\t   */\n\t  function getAngularElements (elements) {\n\t    var obj = {};\n\t    for (var key in elements) {\n\t      obj[key] = angular.element(elements[key]);\n\t    }\n\t    return obj;\n\t  }\n\t\n\t  //-- event/change handlers\n\t\n\t  /**\n\t   * Handles changes to the `hidden` property.\n\t   * @param hidden\n\t   * @param oldHidden\n\t   */\n\t  function handleHiddenChange (hidden, oldHidden) {\n\t    if (!hidden && oldHidden) positionDropdown();\n\t    if (!hidden) {\n\t      if (elements) $timeout(function () { $mdUtil.disableScrollAround(elements.ul); }, 0, false);\n\t    } else {\n\t      $mdUtil.enableScrolling();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * When the user mouses over the dropdown menu, ignore blur events.\n\t   */\n\t  function onListEnter () {\n\t    noBlur = true;\n\t  }\n\t\n\t  /**\n\t   * When the user's mouse leaves the menu, blur events may hide the menu again.\n\t   */\n\t  function onListLeave () {\n\t    noBlur = false;\n\t    if (!hasFocus) ctrl.hidden = true;\n\t  }\n\t\n\t  /**\n\t   * When the mouse button is released, send focus back to the input field.\n\t   */\n\t  function onMouseup () {\n\t    elements.input.focus();\n\t  }\n\t\n\t  /**\n\t   * Handles changes to the selected item.\n\t   * @param selectedItem\n\t   * @param previousSelectedItem\n\t   */\n\t  function selectedItemChange (selectedItem, previousSelectedItem) {\n\t    if (selectedItem) {\n\t      $scope.searchText = getDisplayValue(selectedItem);\n\t    }\n\t    if ($scope.itemChange && selectedItem !== previousSelectedItem)\n\t      $scope.itemChange(getItemScope(selectedItem));\n\t  }\n\t\n\t  /**\n\t   * Calls any external watchers listening for the selected item.  Used in conjunction with\n\t   * `registerSelectedItemWatcher`.\n\t   * @param selectedItem\n\t   * @param previousSelectedItem\n\t   */\n\t  function handleSelectedItemChange(selectedItem, previousSelectedItem) {\n\t    for (var i = 0; i < selectedItemWatchers.length; ++i) {\n\t      selectedItemWatchers[i](selectedItem, previousSelectedItem);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Register a function to be called when the selected item changes.\n\t   * @param cb\n\t   */\n\t  function registerSelectedItemWatcher(cb) {\n\t    if (selectedItemWatchers.indexOf(cb) == -1) {\n\t      selectedItemWatchers.push(cb);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Unregister a function previously registered for selected item changes.\n\t   * @param cb\n\t   */\n\t  function unregisterSelectedItemWatcher(cb) {\n\t    var i = selectedItemWatchers.indexOf(cb);\n\t    if (i != -1) {\n\t      selectedItemWatchers.splice(i, 1);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Handles changes to the searchText property.\n\t   * @param searchText\n\t   * @param previousSearchText\n\t   */\n\t  function handleSearchText (searchText, previousSearchText) {\n\t    ctrl.index = getDefaultIndex();\n\t    //-- do nothing on init\n\t    if (searchText === previousSearchText) return;\n\t    //-- clear selected item if search text no longer matches it\n\t    if (searchText !== getDisplayValue($scope.selectedItem)) $scope.selectedItem = null;\n\t    else return;\n\t    //-- trigger change event if available\n\t    if ($scope.textChange && searchText !== previousSearchText)\n\t      $scope.textChange(getItemScope($scope.selectedItem));\n\t    //-- cancel results if search text is not long enough\n\t    if (!isMinLengthMet()) {\n\t      ctrl.loading = false;\n\t      ctrl.matches = [];\n\t      ctrl.hidden = shouldHide();\n\t      updateMessages();\n\t    } else {\n\t      handleQuery();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Handles input blur event, determines if the dropdown should hide.\n\t   */\n\t  function blur () {\n\t    hasFocus = false;\n\t    if (!noBlur) ctrl.hidden = true;\n\t  }\n\t\n\t  /**\n\t   * Handles input focus event, determines if the dropdown should show.\n\t   */\n\t  function focus () {\n\t    hasFocus = true;\n\t    //-- if searchText is null, let's force it to be a string\n\t    if (!angular.isString($scope.searchText)) $scope.searchText = '';\n\t    if ($scope.minLength > 0) return;\n\t    ctrl.hidden = shouldHide();\n\t    if (!ctrl.hidden) handleQuery();\n\t  }\n\t\n\t  /**\n\t   * Handles keyboard input.\n\t   * @param event\n\t   */\n\t  function keydown (event) {\n\t    switch (event.keyCode) {\n\t      case $mdConstant.KEY_CODE.DOWN_ARROW:\n\t        if (ctrl.loading) return;\n\t        event.preventDefault();\n\t        ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);\n\t        updateScroll();\n\t        updateMessages();\n\t        break;\n\t      case $mdConstant.KEY_CODE.UP_ARROW:\n\t        if (ctrl.loading) return;\n\t        event.preventDefault();\n\t        ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);\n\t        updateScroll();\n\t        updateMessages();\n\t        break;\n\t      case $mdConstant.KEY_CODE.TAB:\n\t      case $mdConstant.KEY_CODE.ENTER:\n\t        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;\n\t        event.preventDefault();\n\t        select(ctrl.index);\n\t        break;\n\t      case $mdConstant.KEY_CODE.ESCAPE:\n\t        ctrl.matches = [];\n\t        ctrl.hidden = true;\n\t        ctrl.index = getDefaultIndex();\n\t        break;\n\t      default:\n\t    }\n\t  }\n\t\n\t  //-- getters\n\t\n\t  /**\n\t   * Returns the minimum length needed to display the dropdown.\n\t   * @returns {*}\n\t   */\n\t  function getMinLength () {\n\t    return angular.isNumber($scope.minLength) ? $scope.minLength : 1;\n\t  }\n\t\n\t  /**\n\t   * Returns the display value for an item.\n\t   * @param item\n\t   * @returns {*}\n\t   */\n\t  function getDisplayValue (item) {\n\t    return (item && $scope.itemText) ? $scope.itemText(getItemScope(item)) : item;\n\t  }\n\t\n\t  /**\n\t   * Returns the locals object for compiling item templates.\n\t   * @param item\n\t   * @returns {{}}\n\t   */\n\t  function getItemScope (item) {\n\t    if (!item) return;\n\t    var locals = {};\n\t    if (ctrl.itemName) locals[ctrl.itemName] = item;\n\t    return locals;\n\t  }\n\t\n\t  /**\n\t   * Returns the default index based on whether or not autoselect is enabled.\n\t   * @returns {number}\n\t   */\n\t  function getDefaultIndex () {\n\t    return $scope.autoselect ? 0 : -1;\n\t  }\n\t\n\t  /**\n\t   * Determines if the menu should be hidden.\n\t   * @returns {boolean}\n\t   */\n\t  function shouldHide () {\n\t    if (!isMinLengthMet()) return true;\n\t  }\n\t\n\t  /**\n\t   * Returns the display value of the current item.\n\t   * @returns {*}\n\t   */\n\t  function getCurrentDisplayValue () {\n\t    return getDisplayValue(ctrl.matches[ctrl.index]);\n\t  }\n\t\n\t  /**\n\t   * Determines if the minimum length is met by the search text.\n\t   * @returns {*}\n\t   */\n\t  function isMinLengthMet () {\n\t    return angular.isDefined($scope.searchText) && $scope.searchText.length >= getMinLength();\n\t  }\n\t\n\t  //-- actions\n\t\n\t  /**\n\t   * Defines a public property with a handler and a default value.\n\t   * @param key\n\t   * @param handler\n\t   * @param value\n\t   */\n\t  function defineProperty (key, handler, value) {\n\t    Object.defineProperty(ctrl, key, {\n\t      get: function () { return value; },\n\t      set: function (newValue) {\n\t        var oldValue = value;\n\t        value = newValue;\n\t        handler(newValue, oldValue);\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Selects the item at the given index.\n\t   * @param index\n\t   */\n\t  function select (index) {\n\t    $scope.selectedItem = ctrl.matches[index];\n\t    ctrl.hidden = true;\n\t    ctrl.index = 0;\n\t    ctrl.matches = [];\n\t    //-- force form to update state for validation\n\t    $timeout(function () {\n\t      elements.$.input.controller('ngModel').$setViewValue(getDisplayValue($scope.selectedItem) ||\n\t          $scope.searchText);\n\t      ctrl.hidden = true;\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Clears the searchText value and selected item.\n\t   */\n\t  function clearValue () {\n\t    $scope.searchText = '';\n\t    select(-1);\n\t\n\t    // Per http://www.w3schools.com/jsref/event_oninput.asp\n\t    var eventObj = document.createEvent('CustomEvent');\n\t    eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});\n\t    elements.input.dispatchEvent(eventObj);\n\t\n\t    elements.input.focus();\n\t  }\n\t\n\t  /**\n\t   * Fetches the results for the provided search text.\n\t   * @param searchText\n\t   */\n\t  function fetchResults (searchText) {\n\t    var items = $scope.$parent.$eval(itemExpr),\n\t        term = searchText.toLowerCase();\n\t    if (angular.isArray(items)) {\n\t      handleResults(items);\n\t    } else if (items) {\n\t      ctrl.loading = true;\n\t      if (items.success) items.success(handleResults);\n\t      if (items.then)    items.then(handleResults);\n\t      if (items.error)   items.error(function () { ctrl.loading = false; });\n\t    }\n\t    function handleResults (matches) {\n\t      cache[term] = matches;\n\t      if (searchText !== $scope.searchText) return; //-- just cache the results if old request\n\t      ctrl.loading = false;\n\t      promise = null;\n\t      ctrl.matches = matches;\n\t      ctrl.hidden = shouldHide();\n\t      updateMessages();\n\t      positionDropdown();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Updates the ARIA messages\n\t   */\n\t  function updateMessages () {\n\t    ctrl.messages = [ getCountMessage(), getCurrentDisplayValue() ];\n\t  }\n\t\n\t  /**\n\t   * Returns the ARIA message for how many results match the current query.\n\t   * @returns {*}\n\t   */\n\t  function getCountMessage () {\n\t    if (lastCount === ctrl.matches.length) return '';\n\t    lastCount = ctrl.matches.length;\n\t    switch (ctrl.matches.length) {\n\t      case 0:  return 'There are no matches available.';\n\t      case 1:  return 'There is 1 match available.';\n\t      default: return 'There are ' + ctrl.matches.length + ' matches available.';\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Makes sure that the focused element is within view.\n\t   */\n\t  function updateScroll () {\n\t    if (!elements.li[ctrl.index]) return;\n\t    var li  = elements.li[ctrl.index],\n\t        top = li.offsetTop,\n\t        bot = top + li.offsetHeight,\n\t        hgt = elements.ul.clientHeight;\n\t    if (top < elements.ul.scrollTop) {\n\t      elements.ul.scrollTop = top;\n\t    } else if (bot > elements.ul.scrollTop + hgt) {\n\t      elements.ul.scrollTop = bot - hgt;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Starts the query to gather the results for the current searchText.  Attempts to return cached\n\t   * results first, then forwards the process to `fetchResults` if necessary.\n\t   */\n\t  function handleQuery () {\n\t    var searchText = $scope.searchText,\n\t        term = searchText.toLowerCase();\n\t    //-- cancel promise if a promise is in progress\n\t    if (promise && promise.cancel) {\n\t      promise.cancel();\n\t      promise = null;\n\t    }\n\t    //-- if results are cached, pull in cached results\n\t    if (!$scope.noCache && cache[term]) {\n\t      ctrl.matches = cache[term];\n\t      updateMessages();\n\t    } else {\n\t      fetchResults(searchText);\n\t    }\n\t    if (hasFocus) ctrl.hidden = shouldHide();\n\t  }\n\t\n\t}\n\tMdAutocompleteCtrl.$inject = [\"$scope\", \"$element\", \"$mdUtil\", \"$mdConstant\", \"$timeout\", \"$mdTheming\", \"$window\", \"$animate\", \"$rootElement\", \"$attrs\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .directive('mdAutocomplete', MdAutocomplete);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdAutocomplete\n\t * @module material.components.autocomplete\n\t *\n\t * @description\n\t * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a custom query.\n\t * This component allows you to provide real-time suggestions as the user types in the input area.\n\t *\n\t * To start, you will need to specify the required parameters and provide a template for your results.\n\t * The content inside `md-autocomplete` will be treated as a template.\n\t *\n\t * In more complex cases, you may want to include other content such as a message to display when\n\t * no matches were found.  You can do this by wrapping your template in `md-item-template` and adding\n\t * a tag for `md-not-found`.  An example of this is shown below.\n\t * ### Validation\n\t *\n\t * You can use `ng-messages` to include validation the same way that you would normally validate;\n\t * however, if you want to replicate a standard input with a floating label, you will have to do the\n\t * following:\n\t *\n\t * - Make sure that your template is wrapped in `md-item-template`\n\t * - Add your `ng-messages` code inside of `md-autocomplete`\n\t * - Add your validation properties to `md-autocomplete` (ie. `required`)\n\t * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)\n\t *\n\t * There is an example below of how this should look.\n\t *\n\t *\n\t * @param {expression} md-items An expression in the format of `item in items` to iterate over matches for your search.\n\t * @param {expression=} md-selected-item-change An expression to be run each time a new item is selected\n\t * @param {expression=} md-search-text-change An expression to be run each time the search text updates\n\t * @param {string=} md-search-text A model to bind the search query text to\n\t * @param {object=} md-selected-item A model to bind the selected item to\n\t * @param {string=} md-item-text An expression that will convert your object to a single string.\n\t * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n\t * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete\n\t * @param {boolean=} ng-disabled Determines whether or not to disable the input field\n\t * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will make suggestions\n\t * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking for results\n\t * @param {boolean=} md-autofocus If true, will immediately focus the input element\n\t * @param {boolean=} md-autoselect If true, the first item will be selected by default\n\t * @param {string=} md-menu-class This will be applied to the dropdown menu for styling\n\t * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in `md-input-container`\n\t *\n\t * @usage\n\t * ###Basic Example\n\t * <hljs lang=\"html\">\n\t *   <md-autocomplete\n\t *       md-selected-item=\"selectedItem\"\n\t *       md-search-text=\"searchText\"\n\t *       md-items=\"item in getMatches(searchText)\"\n\t *       md-item-text=\"item.display\">\n\t *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n\t *   </md-autocomplete>\n\t * </hljs>\n\t *\n\t * ###Example with \"not found\" message\n\t * <hljs lang=\"html\">\n\t * <md-autocomplete\n\t *     md-selected-item=\"selectedItem\"\n\t *     md-search-text=\"searchText\"\n\t *     md-items=\"item in getMatches(searchText)\"\n\t *     md-item-text=\"item.display\">\n\t *   <md-item-template>\n\t *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n\t *   </md-item-template>\n\t *   <md-not-found>\n\t *     No matches found.\n\t *   </md-not-found>\n\t * </md-autocomplete>\n\t * </hljs>\n\t *\n\t * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n\t * parts that make up our component.\n\t *\n\t * ### Example with validation\n\t * <hljs lang=\"html\">\n\t * <form name=\"autocompleteForm\">\n\t *   <md-autocomplete\n\t *       required\n\t *       input-name=\"autocomplete\"\n\t *       md-selected-item=\"selectedItem\"\n\t *       md-search-text=\"searchText\"\n\t *       md-items=\"item in getMatches(searchText)\"\n\t *       md-item-text=\"item.display\">\n\t *     <md-item-template>\n\t *       <span md-highlight-text=\"searchText\">{{item.display}}</span>\n\t *     </md-item-template>\n\t *     <div ng-messages=\"autocompleteForm.autocomplete.$error\">\n\t *       <div ng-message=\"required\">This field is required</div>\n\t *     </div>\n\t *   </md-autocomplete>\n\t * </form>\n\t * </hljs>\n\t *\n\t * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n\t * parts that make up our component.\n\t */\n\t\n\tfunction MdAutocomplete ($mdTheming, $mdUtil) {\n\t  return {\n\t    controller:   'MdAutocompleteCtrl',\n\t    controllerAs: '$mdAutocompleteCtrl',\n\t    scope:        {\n\t      inputName:      '@mdInputName',\n\t      inputMinlength: '@mdInputMinlength',\n\t      inputMaxlength: '@mdInputMaxlength',\n\t      searchText:     '=?mdSearchText',\n\t      selectedItem:   '=?mdSelectedItem',\n\t      itemsExpr:      '@mdItems',\n\t      itemText:       '&mdItemText',\n\t      placeholder:    '@placeholder',\n\t      noCache:        '=?mdNoCache',\n\t      itemChange:     '&?mdSelectedItemChange',\n\t      textChange:     '&?mdSearchTextChange',\n\t      minLength:      '=?mdMinLength',\n\t      delay:          '=?mdDelay',\n\t      autofocus:      '=?mdAutofocus',\n\t      floatingLabel:  '@?mdFloatingLabel',\n\t      autoselect:     '=?mdAutoselect',\n\t      menuClass:      '@?mdMenuClass'\n\t    },\n\t    template: function (element, attr) {\n\t      var noItemsTemplate = getNoItemsTemplate(),\n\t          itemTemplate = getItemTemplate(),\n\t          leftover = element.html();\n\t      return '\\\n\t        <md-autocomplete-wrap\\\n\t            layout=\"row\"\\\n\t            ng-class=\"{ \\'md-whiteframe-z1\\': !floatingLabel }\"\\\n\t            role=\"listbox\">\\\n\t          ' + getInputElement() + '\\\n\t          <md-progress-linear\\\n\t              ng-if=\"$mdAutocompleteCtrl.loading\"\\\n\t              md-mode=\"indeterminate\"></md-progress-linear>\\\n\t          <ul role=\"presentation\"\\\n\t              class=\"md-autocomplete-suggestions md-whiteframe-z1 {{menuClass || \\'\\'}}\"\\\n\t              id=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n\t              ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n\t              ng-mouseenter=\"$mdAutocompleteCtrl.listEnter()\"\\\n\t              ng-mouseleave=\"$mdAutocompleteCtrl.listLeave()\"\\\n\t              ng-mouseup=\"$mdAutocompleteCtrl.mouseUp()\">\\\n\t            <li ng-repeat=\"(index, item) in $mdAutocompleteCtrl.matches\"\\\n\t                ng-class=\"{ selected: index === $mdAutocompleteCtrl.index }\"\\\n\t                ng-click=\"$mdAutocompleteCtrl.select(index)\"\\\n\t                md-autocomplete-list-item=\"$mdAutocompleteCtrl.itemName\">\\\n\t                ' + itemTemplate + '\\\n\t            </li>\\\n\t            ' + noItemsTemplate + '\\\n\t          </ul>\\\n\t        </md-autocomplete-wrap>\\\n\t        <aria-status\\\n\t            class=\"md-visually-hidden\"\\\n\t            role=\"status\"\\\n\t            aria-live=\"assertive\">\\\n\t          <p ng-repeat=\"message in $mdAutocompleteCtrl.messages\" ng-if=\"message\">{{message}}</p>\\\n\t        </aria-status>';\n\t\n\t      function getItemTemplate() {\n\t        var templateTag = element.find('md-item-template').remove(),\n\t            html = templateTag.length ? templateTag.html() : element.html();\n\t        if (!templateTag.length) element.empty();\n\t        return html;\n\t      }\n\t\n\t      function getNoItemsTemplate() {\n\t        var templateTag = element.find('md-not-found').remove(),\n\t            template = templateTag.length ? templateTag.html() : '';\n\t        return template\n\t            ? '<li ng-if=\"!$mdAutocompleteCtrl.matches.length && !$mdAutocompleteCtrl.loading\\\n\t                         && !$mdAutocompleteCtrl.hidden\"\\\n\t                         ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n\t                         md-autocomplete-parent-scope>' + template + '</li>'\n\t            : '';\n\t\n\t      }\n\t\n\t      function getInputElement() {\n\t        if (attr.mdFloatingLabel) {\n\t          return '\\\n\t            <md-input-container flex ng-if=\"floatingLabel\">\\\n\t              <label>{{floatingLabel}}</label>\\\n\t              <input type=\"search\"\\\n\t                  id=\"fl-input-{{$mdAutocompleteCtrl.id}}\"\\\n\t                  name=\"{{inputName}}\"\\\n\t                  autocomplete=\"off\"\\\n\t                  ng-required=\"isRequired\"\\\n\t                  ng-minlength=\"inputMinlength\"\\\n\t                  ng-maxlength=\"inputMaxlength\"\\\n\t                  ng-disabled=\"$mdAutocompleteCtrl.isDisabled\"\\\n\t                  ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n\t                  ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n\t                  ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n\t                  ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n\t                  aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n\t                  aria-label=\"{{floatingLabel}}\"\\\n\t                  aria-autocomplete=\"list\"\\\n\t                  aria-haspopup=\"true\"\\\n\t                  aria-activedescendant=\"\"\\\n\t                  aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>\\\n\t              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\\\n\t            </md-input-container>';\n\t        } else {\n\t          return '\\\n\t            <input flex type=\"search\"\\\n\t                id=\"input-{{$mdAutocompleteCtrl.id}}\"\\\n\t                name=\"{{inputName}}\"\\\n\t                ng-if=\"!floatingLabel\"\\\n\t                autocomplete=\"off\"\\\n\t                ng-required=\"isRequired\"\\\n\t                ng-disabled=\"$mdAutocompleteCtrl.isDisabled\"\\\n\t                ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n\t                ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n\t                ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n\t                ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n\t                placeholder=\"{{placeholder}}\"\\\n\t                aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n\t                aria-label=\"{{placeholder}}\"\\\n\t                aria-autocomplete=\"list\"\\\n\t                aria-haspopup=\"true\"\\\n\t                aria-activedescendant=\"\"\\\n\t                aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>\\\n\t            <button\\\n\t                type=\"button\"\\\n\t                tabindex=\"-1\"\\\n\t                ng-if=\"$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled\"\\\n\t                ng-click=\"$mdAutocompleteCtrl.clear()\">\\\n\t              <md-icon md-svg-icon=\"md-close\"></md-icon>\\\n\t              <span class=\"md-visually-hidden\">Clear</span>\\\n\t            </button>\\\n\t                ';\n\t        }\n\t      }\n\t    }\n\t  };\n\t}\n\tMdAutocomplete.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .controller('MdHighlightCtrl', MdHighlightCtrl);\n\t\n\tfunction MdHighlightCtrl ($scope, $element, $interpolate) {\n\t  this.init = init;\n\t\n\t  return init();\n\t\n\t  function init (term) {\n\t    var unsafeText = $interpolate($element.html())($scope),\n\t        text = angular.element('<div>').text(unsafeText).html(),\n\t        flags = $element.attr('md-highlight-flags') || '',\n\t        watcher = $scope.$watch(term, function (term) {\n\t          var regex = getRegExp(term, flags),\n\t              html = text.replace(regex, '<span class=\"highlight\">$&</span>');\n\t          $element.html(html);\n\t        });\n\t    $element.on('$destroy', function () { watcher(); });\n\t  }\n\t\n\t  function sanitize (term) {\n\t    if (!term) return term;\n\t    return term.replace(/[\\\\\\^\\$\\*\\+\\?\\.\\(\\)\\|\\{\\}\\[\\]]/g, '\\\\$&');\n\t  }\n\t\n\t  function getRegExp (text, flags) {\n\t    var str = '';\n\t    if (flags.indexOf('^') >= 1) str += '^';\n\t    str += text;\n\t    if (flags.indexOf('$') >= 1) str += '$';\n\t    return new RegExp(sanitize(str), flags.replace(/[\\$\\^]/g, ''));\n\t  }\n\t}\n\tMdHighlightCtrl.$inject = [\"$scope\", \"$element\", \"$interpolate\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .directive('mdHighlightText', MdHighlight);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdHighlightText\n\t * @module material.components.autocomplete\n\t *\n\t * @description\n\t * The `md-highlight-text` directive allows you to specify text that should be highlighted within\n\t * an element.  Highlighted text will be wrapped in `<span class=\"highlight\"></span>` which can\n\t * be styled through CSS.  Please note that child elements may not be used with this directive.\n\t *\n\t * @param {string} md-highlight-text A model to be searched for\n\t * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).\n\t *    #### **Supported flags**:\n\t *    - `g`: Find all matches within the provided text\n\t *    - `i`: Ignore case when searching for matches\n\t *    - `$`: Only match if the text ends with the search term\n\t *    - `^`: Only match if the text begins with the search term\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <input placeholder=\"Enter a search term...\" ng-model=\"searchTerm\" type=\"text\" />\n\t * <ul>\n\t *   <li ng-repeat=\"result in results\" md-highlight-text=\"searchTerm\">\n\t *     {{result.text}}\n\t *   </li>\n\t * </ul>\n\t * </hljs>\n\t */\n\t\n\tfunction MdHighlight () {\n\t  return {\n\t    terminal: true,\n\t    scope: false,\n\t    controller: 'MdHighlightCtrl',\n\t    link: function (scope, element, attr, ctrl) {\n\t      ctrl.init(attr.mdHighlightText);\n\t    }\n\t  };\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .directive('mdAutocompleteListItem', MdAutocompleteListItem);\n\t\n\tfunction MdAutocompleteListItem ($compile, $mdUtil) {\n\t  return {\n\t    terminal: true,\n\t    link: postLink,\n\t    scope: false\n\t  };\n\t  function postLink (scope, element, attr) {\n\t    var ctrl     = scope.$parent.$mdAutocompleteCtrl,\n\t        newScope = ctrl.parent.$new(false, ctrl.parent),\n\t        itemName = ctrl.scope.$eval(attr.mdAutocompleteListItem);\n\t    newScope[itemName] = scope.item;\n\t    $compile(element.contents())(newScope);\n\t    element.attr({\n\t      role: 'option',\n\t      id: 'item_' + $mdUtil.nextUid()\n\t    });\n\t  }\n\t}\n\tMdAutocompleteListItem.$inject = [\"$compile\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.autocomplete')\n\t    .directive('mdAutocompleteParentScope', MdAutocompleteParentScope);\n\t\n\tfunction MdAutocompleteParentScope ($compile, $mdUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    terminal: true,\n\t    link: postLink,\n\t    scope: false\n\t  };\n\t  function postLink (scope, element, attr) {\n\t    var ctrl     = scope.$parent.$mdAutocompleteCtrl;\n\t    $compile(element.contents())(ctrl.parent);\n\t    if (attr.hasOwnProperty('mdAutocompleteReplace')) {\n\t      element.after(element.contents());\n\t      element.remove();\n\t    }\n\t  }\n\t}\n\tMdAutocompleteParentScope.$inject = [\"$compile\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.chips')\n\t    .directive('mdChip', MdChip);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdChip\n\t * @module material.components.chips\n\t *\n\t * @description\n\t * `<md-chip>` is a component used within `<md-chips>` and is responsible for rendering individual\n\t * chips.\n\t *\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t *   <md-chip>{{$chip}}</md-chip>\n\t * </hljs>\n\t *\n\t */\n\t\n\t// This hint text is hidden within a chip but used by screen readers to\n\t// inform the user how they can interact with a chip.\n\tvar DELETE_HINT_TEMPLATE = '\\\n\t    <span ng-if=\"!$mdChipsCtrl.readonly\" class=\"md-visually-hidden\">\\\n\t      {{$mdChipsCtrl.deleteHint}}\\\n\t    </span>';\n\t\n\t/**\n\t * MDChip Directive Definition\n\t *\n\t * @param $mdTheming\n\t * @param $mdInkRipple\n\t * @ngInject\n\t */\n\tfunction MdChip($mdTheming) {\n\t  return {\n\t    restrict: 'E',\n\t    require: '^?mdChips',\n\t    compile:  compile\n\t  };\n\t\n\t  function compile(element, attr) {\n\t    element.append(DELETE_HINT_TEMPLATE);\n\t    return function postLink(scope, element, attr, ctrl) {\n\t      element.addClass('md-chip');\n\t      $mdTheming(element);\n\t\n\t      if (ctrl) angular.element(element[0].querySelector('.md-chip-content'))\n\t          .on('blur', function () {\n\t            ctrl.selectedChip = -1;\n\t          });\n\t    };\n\t  }\n\t}\n\tMdChip.$inject = [\"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.chips')\n\t    .directive('mdChipRemove', MdChipRemove);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdChipRemove\n\t * @module material.components.chips\n\t *\n\t * @description\n\t * `<md-chip-remove>`\n\t * Designates an element to be used as the delete button for a chip. This\n\t * element is passed as a child of the `md-chips` element.\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t *   <md-chips><button md-chip-remove>DEL</button></md-chips>\n\t * </hljs>\n\t */\n\t\n\t\n\t/**\n\t * MdChipRemove Directive Definition.\n\t * \n\t * @param $compile\n\t * @param $timeout\n\t * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}\n\t * @constructor\n\t */\n\tfunction MdChipRemove ($timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^mdChips',\n\t    scope: false,\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr, ctrl) {\n\t    element.on('click', function(event) {\n\t      scope.$apply(function() {\n\t        ctrl.removeChip(scope.$$replacedScope.$index);\n\t      });\n\t    });\n\t\n\t    // Child elements aren't available until after a $timeout tick as they are hidden by an\n\t    // `ng-if`. see http://goo.gl/zIWfuw\n\t    $timeout(function() {\n\t      element.attr({ tabindex: -1, ariaHidden: true });\n\t      element.find('button').attr('tabindex', '-1');\n\t    });\n\t  }\n\t}\n\tMdChipRemove.$inject = [\"$timeout\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.chips')\n\t    .directive('mdChipTransclude', MdChipTransclude);\n\t\n\tfunction MdChipTransclude ($compile, $mdUtil) {\n\t  return {\n\t    restrict: 'EA',\n\t    terminal: true,\n\t    link: link,\n\t    scope: false\n\t  };\n\t  function link (scope, element, attr) {\n\t    var ctrl = scope.$parent.$mdChipsCtrl,\n\t        newScope = ctrl.parent.$new(false, ctrl.parent);\n\t    newScope.$$replacedScope = scope;\n\t    newScope.$chip = scope.$chip;\n\t    newScope.$mdChipsCtrl = ctrl;\n\t    element.html(ctrl.$scope.$eval(attr.mdChipTransclude));\n\t    $compile(element.contents())(newScope);\n\t  }\n\t}\n\tMdChipTransclude.$inject = [\"$compile\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.chips')\n\t    .controller('MdChipsCtrl', MdChipsCtrl);\n\t\n\t/**\n\t * Controller for the MdChips component. Responsible for adding to and\n\t * removing from the list of chips, marking chips as selected, and binding to\n\t * the models of various input components.\n\t *\n\t * @param $scope\n\t * @param $mdConstant\n\t * @param $log\n\t * @param $element\n\t * @constructor\n\t */\n\tfunction MdChipsCtrl ($scope, $mdConstant, $log, $element, $timeout) {\n\t  /** @type {$timeout} **/\n\t  this.$timeout = $timeout;\n\t\n\t  /** @type {Object} */\n\t  this.$mdConstant = $mdConstant;\n\t\n\t  /** @type {angular.$scope} */\n\t  this.$scope = $scope;\n\t\n\t  /** @type {angular.$scope} */\n\t  this.parent = $scope.$parent;\n\t\n\t  /** @type {$log} */\n\t  this.$log = $log;\n\t\n\t  /** @type {$element} */\n\t  this.$element = $element;\n\t\n\t  /** @type {angular.NgModelController} */\n\t  this.ngModelCtrl = null;\n\t\n\t  /** @type {angular.NgModelController} */\n\t  this.userInputNgModelCtrl = null;\n\t\n\t  /** @type {Element} */\n\t  this.userInputElement = null;\n\t\n\t  /** @type {Array.<Object>} */\n\t  this.items = [];\n\t\n\t  /** @type {number} */\n\t  this.selectedChip = -1;\n\t\n\t\n\t  /**\n\t   * Hidden hint text for how to delete a chip. Used to give context to screen readers.\n\t   * @type {string}\n\t   */\n\t  this.deleteHint = 'Press delete to remove this chip.';\n\t\n\t  /**\n\t   * Hidden label for the delete button. Used to give context to screen readers.\n\t   * @type {string}\n\t   */\n\t  this.deleteButtonLabel = 'Remove';\n\t\n\t  /**\n\t   * Model used by the input element.\n\t   * @type {string}\n\t   */\n\t  this.chipBuffer = '';\n\t\n\t  /**\n\t   * Whether to use the mdOnAppend expression to transform the chip buffer\n\t   * before appending it to the list.\n\t   * @type {boolean}\n\t   */\n\t  this.useMdOnAppend = false;\n\t}\n\tMdChipsCtrl.$inject = [\"$scope\", \"$mdConstant\", \"$log\", \"$element\", \"$timeout\"];\n\t\n\t/**\n\t * Handles the keydown event on the input element: <enter> appends the\n\t * buffer to the chip list, while backspace removes the last chip in the list\n\t * if the current buffer is empty.\n\t * @param event\n\t */\n\tMdChipsCtrl.prototype.inputKeydown = function(event) {\n\t  var chipBuffer = this.getChipBuffer();\n\t  switch (event.keyCode) {\n\t    case this.$mdConstant.KEY_CODE.ENTER:\n\t      if (this.$scope.requireMatch || !chipBuffer) break;\n\t      event.preventDefault();\n\t      this.appendChip(chipBuffer);\n\t      this.resetChipBuffer();\n\t      break;\n\t    case this.$mdConstant.KEY_CODE.BACKSPACE:\n\t      if (chipBuffer) break;\n\t      event.stopPropagation();\n\t      if (this.items.length) this.selectAndFocusChipSafe(this.items.length - 1);\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow\n\t * keys switch which chips is active\n\t * @param event\n\t */\n\tMdChipsCtrl.prototype.chipKeydown = function (event) {\n\t  if (this.getChipBuffer()) return;\n\t  switch (event.keyCode) {\n\t    case this.$mdConstant.KEY_CODE.BACKSPACE:\n\t    case this.$mdConstant.KEY_CODE.DELETE:\n\t      if (this.selectedChip < 0) return;\n\t      event.preventDefault();\n\t      this.removeAndSelectAdjacentChip(this.selectedChip);\n\t      break;\n\t    case this.$mdConstant.KEY_CODE.LEFT_ARROW:\n\t      event.preventDefault();\n\t      if (this.selectedChip < 0) this.selectedChip = this.items.length;\n\t      if (this.items.length) this.selectAndFocusChipSafe(this.selectedChip - 1);\n\t      break;\n\t    case this.$mdConstant.KEY_CODE.RIGHT_ARROW:\n\t      event.preventDefault();\n\t      this.selectAndFocusChipSafe(this.selectedChip + 1);\n\t      break;\n\t    case this.$mdConstant.KEY_CODE.ESCAPE:\n\t    case this.$mdConstant.KEY_CODE.TAB:\n\t      if (this.selectedChip < 0) return;\n\t      event.preventDefault();\n\t      this.onFocus();\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`\n\t * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used\n\t * always.\n\t */\n\tMdChipsCtrl.prototype.getPlaceholder = function() {\n\t  // Allow `secondary-placeholder` to be blank.\n\t  var useSecondary = (this.items.length &&\n\t      (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));\n\t  return useSecondary ? this.placeholder : this.secondaryPlaceholder;\n\t};\n\t\n\t/**\n\t * Removes chip at {@code index} and selects the adjacent chip.\n\t * @param index\n\t */\n\tMdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {\n\t  var selIndex = this.getAdjacentChipIndex(index);\n\t  this.removeChip(index);\n\t  this.$timeout(angular.bind(this, function () {\n\t      this.selectAndFocusChipSafe(selIndex);\n\t  }));\n\t};\n\t\n\t/**\n\t * Sets the selected chip index to -1.\n\t */\n\tMdChipsCtrl.prototype.resetSelectedChip = function() {\n\t  this.selectedChip = -1;\n\t};\n\t\n\t/**\n\t * Gets the index of an adjacent chip to select after deletion. Adjacency is\n\t * determined as the next chip in the list, unless the target chip is the\n\t * last in the list, then it is the chip immediately preceding the target. If\n\t * there is only one item in the list, -1 is returned (select none).\n\t * The number returned is the index to select AFTER the target has been\n\t * removed.\n\t * If the current chip is not selected, then -1 is returned to select none.\n\t */\n\tMdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {\n\t  var len = this.items.length - 1;\n\t  return (len == 0) ? -1 :\n\t      (index == len) ? index -1 : index;\n\t};\n\t\n\t/**\n\t * Append the contents of the buffer to the chip list. This method will first\n\t * call out to the md-on-append method, if provided\n\t * @param newChip\n\t */\n\tMdChipsCtrl.prototype.appendChip = function(newChip) {\n\t  if (this.items.indexOf(newChip) + 1) return;\n\t  if (this.useMdOnAppend && this.mdOnAppend) {\n\t    newChip = this.mdOnAppend({'$chip': newChip});\n\t  }\n\t  this.items.push(newChip);\n\t};\n\t\n\t/**\n\t * Sets whether to use the md-on-append expression. This expression is\n\t * bound to scope and controller in {@code MdChipsDirective} as\n\t * {@code mdOnAppend}. Due to the nature of directive scope bindings, the\n\t * controller cannot know on its own/from the scope whether an expression was\n\t * actually provided.\n\t */\n\tMdChipsCtrl.prototype.useMdOnAppendExpression = function() {\n\t  this.useMdOnAppend = true;\n\t};\n\t\n\t/**\n\t * Gets the input buffer. The input buffer can be the model bound to the\n\t * default input item {@code this.chipBuffer}, the {@code selectedItem}\n\t * model of an {@code md-autocomplete}, or, through some magic, the model\n\t * bound to any inpput or text area element found within a\n\t * {@code md-input-container} element.\n\t * @return {Object|string}\n\t */\n\tMdChipsCtrl.prototype.getChipBuffer = function() {\n\t  return !this.userInputElement ? this.chipBuffer :\n\t      this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue :\n\t          this.userInputElement[0].value;\n\t};\n\t\n\t/**\n\t * Resets the input buffer for either the internal input or user provided input element.\n\t */\n\tMdChipsCtrl.prototype.resetChipBuffer = function() {\n\t  if (this.userInputElement) {\n\t    if (this.userInputNgModelCtrl) {\n\t      this.userInputNgModelCtrl.$setViewValue('');\n\t      this.userInputNgModelCtrl.$render();\n\t    } else {\n\t      this.userInputElement[0].value = '';\n\t    }\n\t  } else {\n\t    this.chipBuffer = '';\n\t  }\n\t};\n\t\n\t/**\n\t * Removes the chip at the given index.\n\t * @param index\n\t */\n\tMdChipsCtrl.prototype.removeChip = function(index) {\n\t  this.items.splice(index, 1);\n\t};\n\t\n\tMdChipsCtrl.prototype.removeChipAndFocusInput = function (index) {\n\t  this.removeChip(index);\n\t  this.onFocus();\n\t};\n\t/**\n\t * Selects the chip at `index`,\n\t * @param index\n\t */\n\tMdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {\n\t  if (!this.items.length) {\n\t    this.selectChip(-1);\n\t    this.onFocus();\n\t    return;\n\t  }\n\t  if (index === this.items.length) return this.onFocus();\n\t  index = Math.max(index, 0);\n\t  index = Math.min(index, this.items.length - 1);\n\t  this.selectChip(index);\n\t  this.focusChip(index);\n\t};\n\t\n\t/**\n\t * Marks the chip at the given index as selected.\n\t * @param index\n\t */\n\tMdChipsCtrl.prototype.selectChip = function(index) {\n\t  if (index >= -1 && index <= this.items.length) {\n\t    this.selectedChip = index;\n\t  } else {\n\t    this.$log.warn('Selected Chip index out of bounds; ignoring.');\n\t  }\n\t};\n\t\n\t/**\n\t * Selects the chip at `index` and gives it focus.\n\t * @param index\n\t */\n\tMdChipsCtrl.prototype.selectAndFocusChip = function(index) {\n\t  this.selectChip(index);\n\t  if (index != -1) {\n\t    this.focusChip(index);\n\t  }\n\t};\n\t\n\t/**\n\t * Call `focus()` on the chip at `index`\n\t */\n\tMdChipsCtrl.prototype.focusChip = function(index) {\n\t  this.$element[0].querySelector('md-chip[index=\"' + index + '\"] .md-chip-content').focus();\n\t};\n\t\n\t/**\n\t * Configures the required interactions with the ngModel Controller.\n\t * Specifically, set {@code this.items} to the {@code NgModelCtrl#$viewVale}.\n\t * @param ngModelCtrl\n\t */\n\tMdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {\n\t  this.ngModelCtrl = ngModelCtrl;\n\t\n\t  var self = this;\n\t  ngModelCtrl.$render = function() {\n\t    // model is updated. do something.\n\t    self.items = self.ngModelCtrl.$viewValue;\n\t  };\n\t};\n\t\n\tMdChipsCtrl.prototype.onFocus = function () {\n\t  var input = this.$element[0].querySelector('input');\n\t  input && input.focus();\n\t  this.resetSelectedChip();\n\t};\n\t\n\tMdChipsCtrl.prototype.onInputFocus = function () {\n\t  this.inputHasFocus = true;\n\t  this.resetSelectedChip();\n\t};\n\t\n\tMdChipsCtrl.prototype.onInputBlur = function () {\n\t  this.inputHasFocus = false;\n\t};\n\t\n\t/**\n\t * Configure event bindings on a user-provided input element.\n\t * @param inputElement\n\t */\n\tMdChipsCtrl.prototype.configureUserInput = function(inputElement) {\n\t  this.userInputElement = inputElement;\n\t\n\t  // Find the NgModelCtrl for the input element\n\t  var ngModelCtrl = inputElement.controller('ngModel');\n\t  // `.controller` will look in the parent as well.\n\t  if (ngModelCtrl != this.ngModelCtrl) {\n\t    this.userInputNgModelCtrl = ngModelCtrl;\n\t  }\n\t\n\t  // Bind to keydown and focus events of input\n\t  var scope = this.$scope;\n\t  var ctrl = this;\n\t  inputElement\n\t      .attr({ tabindex: 0 })\n\t      .on('keydown', function(event) { scope.$apply( angular.bind(ctrl, function() { ctrl.inputKeydown(event); })) })\n\t      .on('focus', angular.bind(ctrl, ctrl.onInputFocus))\n\t      .on('blur', angular.bind(ctrl, ctrl.onInputBlur));\n\t};\n\t\n\tMdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {\n\t\n\t  ctrl.registerSelectedItemWatcher(angular.bind(this, function (item) {\n\t    if (item) {\n\t      this.appendChip(item);\n\t      this.resetChipBuffer();\n\t    }\n\t  }));\n\t\n\t  this.$element.find('input')\n\t      .on('focus',angular.bind(this, this.onInputFocus) )\n\t      .on('blur', angular.bind(this, this.onInputBlur) );\n\t};\n\t\n\tMdChipsCtrl.prototype.hasFocus = function () {\n\t  return this.inputHasFocus || this.selectedChip >= 0;\n\t};\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  angular\n\t      .module('material.components.chips')\n\t      .directive('mdChips', MdChips);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdChips\n\t   * @module material.components.chips\n\t   *\n\t   * @description\n\t   * `<md-chips>` is an input component for building lists of strings or objects. The list items are\n\t   * displayed as 'chips'. This component can make use of an `<input>` element or an\n\t   * `<md-autocomplete>` element.\n\t   *\n\t   * <strong>Custom `<md-chip-template>` template</strong>\n\t   * A custom template may be provided to render the content of each chip. This is achieved by\n\t   * specifying an `<md-chip-template>` element as a child of `<md-chips>`. Note: Any attributes on\n\t   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The\n\t   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing\n\t   * the chip object and its index in the list of chips, respectively.\n\t   * To override the chip delete control, include an element (ideally a button) with the attribute\n\t   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element\n\t   * is also placed as a sibling to the chip content (on which there are also click listeners) to\n\t   * avoid a nested ng-click situation.\n\t   *\n\t   * <h3> Pending Features </h3>\n\t   * <ul style=\"padding-left:20px;\">\n\t   *\n\t   *   <ul>Style\n\t   *     <li>Colours for hover, press states (ripple?).</li>\n\t   *   </ul>\n\t   *\n\t   *   <ul>List Manipulation\n\t   *     <li>delete item via DEL or backspace keys when selected</li>\n\t   *   </ul>\n\t   *\n\t   *   <ul>Validation\n\t   *     <li>de-dupe values (or support duplicates, but fix the ng-repeat duplicate key issue)</li>\n\t   *     <li>allow a validation callback</li>\n\t   *     <li>hilighting style for invalid chips</li>\n\t   *   </ul>\n\t   *\n\t   *   <ul>Item mutation\n\t   *     <li>Support `\n\t   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double\n\t   *       click?\n\t   *     </li>\n\t   *   </ul>\n\t   *\n\t   *   <ul>Truncation and Disambiguation (?)\n\t   *     <li>Truncate chip text where possible, but do not truncate entries such that two are\n\t   *     indistinguishable.</li>\n\t   *   </ul>\n\t   *\n\t   *   <ul>Drag and Drop\n\t   *     <li>Drag and drop chips between related `<md-chips>` elements.\n\t   *     </li>\n\t   *   </ul>\n\t   * </ul>\n\t   *\n\t   *  <span style=\"font-size:.8em;text-align:center\">\n\t   *    Warning: This component is a WORK IN PROGRESS. If you use it now,\n\t   *    it will probably break on you in the future.\n\t   *  </span>\n\t   *\n\t   * @param {string=|object=} ng-model A model to bind the list of items to\n\t   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n\t   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n\t   *    displayed when there is at least on item in the list\n\t   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding\n\t   *    the input and delete buttons\n\t   * @param {expression} md-on-append An expression expected to convert the input string into an\n\t   *    object when adding a chip.\n\t   * @param {string=} delete-hint A string read by screen readers instructing users that pressing\n\t   *    the delete key will remove the chip.\n\t   * @param {string=} delete-button-label A label for the delete button. Also hidden and read by\n\t   *    screen readers.\n\t   *\n\t   * @usage\n\t   * <hljs lang=\"html\">\n\t   *   <md-chips\n\t   *       ng-model=\"myItems\"\n\t   *       placeholder=\"Add an item\"\n\t   *       readonly=\"isReadOnly\">\n\t   *   </md-chips>\n\t   * </hljs>\n\t   *\n\t   */\n\t\n\t\n\t  var MD_CHIPS_TEMPLATE = '\\\n\t      <md-chips-wrap\\\n\t          ng-if=\"!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0\"\\\n\t          ng-keydown=\"$mdChipsCtrl.chipKeydown($event)\"\\\n\t          ng-class=\"{ \\'md-focused\\': $mdChipsCtrl.hasFocus() }\"\\\n\t          class=\"md-chips\">\\\n\t        <md-chip ng-repeat=\"$chip in $mdChipsCtrl.items\"\\\n\t            index=\"{{$index}}\"\\\n\t            ng-class=\"{\\'md-focused\\': $mdChipsCtrl.selectedChip == $index}\">\\\n\t          <div class=\"md-chip-content\"\\\n\t              tabindex=\"-1\"\\\n\t              aria-hidden=\"true\"\\\n\t              ng-focus=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)\"\\\n\t              md-chip-transclude=\"$mdChipsCtrl.chipContentsTemplate\"></div>\\\n\t          <div class=\"md-chip-remove-container\"\\\n\t              md-chip-transclude=\"$mdChipsCtrl.chipRemoveTemplate\"></div>\\\n\t        </md-chip>\\\n\t        <div ng-if=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl\"\\\n\t            class=\"md-chip-input-container\"\\\n\t            md-chip-transclude=\"$mdChipsCtrl.chipInputTemplate\"></div>\\\n\t        </div>\\\n\t      </md-chips-wrap>';\n\t\n\t  var CHIP_INPUT_TEMPLATE = '\\\n\t        <input\\\n\t            tabindex=\"0\"\\\n\t            placeholder=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n\t            aria-label=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n\t            ng-model=\"$mdChipsCtrl.chipBuffer\"\\\n\t            ng-focus=\"$mdChipsCtrl.onInputFocus()\"\\\n\t            ng-blur=\"$mdChipsCtrl.onInputBlur()\"\\\n\t            ng-keydown=\"$mdChipsCtrl.inputKeydown($event)\">';\n\t\n\t  var CHIP_DEFAULT_TEMPLATE = '\\\n\t      <span>{{$chip}}</span>';\n\t\n\t  var CHIP_REMOVE_TEMPLATE = '\\\n\t      <button\\\n\t          class=\"md-chip-remove\"\\\n\t          ng-if=\"!$mdChipsCtrl.readonly\"\\\n\t          ng-click=\"$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)\"\\\n\t          type=\"button\"\\\n\t          aria-hidden=\"true\"\\\n\t          tabindex=\"-1\">\\\n\t        <md-icon md-svg-icon=\"md-close\"></md-icon>\\\n\t        <span class=\"md-visually-hidden\">\\\n\t          {{$mdChipsCtrl.deleteButtonLabel}}\\\n\t        </span>\\\n\t      </button>';\n\t\n\t  /**\n\t   * MDChips Directive Definition\n\t   */\n\t  function MdChips ($mdTheming, $mdUtil, $compile, $log, $timeout) {\n\t    return {\n\t      template: function(element, attrs) {\n\t        // Clone the element into an attribute. By prepending the attribute\n\t        // name with '$', Angular won't write it into the DOM. The cloned\n\t        // element propagates to the link function via the attrs argument,\n\t        // where various contained-elements can be consumed.\n\t        var content = attrs['$mdUserTemplate'] = element.clone();\n\t        return MD_CHIPS_TEMPLATE;\n\t      },\n\t      require: ['mdChips'],\n\t      restrict: 'E',\n\t      controller: 'MdChipsCtrl',\n\t      controllerAs: '$mdChipsCtrl',\n\t      bindToController: true,\n\t      compile: compile,\n\t      scope: {\n\t        readonly: '=readonly',\n\t        placeholder: '@',\n\t        secondaryPlaceholder: '@',\n\t        mdOnAppend: '&',\n\t        deleteHint: '@',\n\t        deleteButtonLabel: '@',\n\t        requireMatch: '=?mdRequireMatch'\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Builds the final template for `md-chips` and returns the postLink function.\n\t     *\n\t     * Building the template involves 3 key components:\n\t     * static chips\n\t     * chip template\n\t     * input control\n\t     *\n\t     * If no `ng-model` is provided, only the static chip work needs to be done.\n\t     *\n\t     * If no user-passed `md-chip-template` exists, the default template is used. This resulting\n\t     * template is appended to the chip content element.\n\t     *\n\t     * The remove button may be overridden by passing an element with an md-chip-remove attribute.\n\t     *\n\t     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for\n\t     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.\n\t     * If no user input is provided, a default one is appended to the input container node in the\n\t     * template.\n\t     *\n\t     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for\n\t     * transclusion in the `postLink` function.\n\t     *\n\t     *\n\t     * @param element\n\t     * @param attr\n\t     * @returns {Function}\n\t     */\n\t    function compile(element, attr) {\n\t      // Grab the user template from attr and reset the attribute to null.\n\t      var userTemplate = attr['$mdUserTemplate'];\n\t      attr['$mdUserTemplate'] = null;\n\t\n\t      // Set the chip remove, chip contents and chip input templates. The link function will put\n\t      // them on the scope for transclusion later.\n\t      var chipRemoveTemplate   = getTemplateByQuery('md-chips>*[md-chip-remove]') || CHIP_REMOVE_TEMPLATE,\n\t          chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || CHIP_DEFAULT_TEMPLATE,\n\t          chipInputTemplate    = getTemplateByQuery('md-chips>md-autocomplete')\n\t              || getTemplateByQuery('md-chips>input')\n\t              || CHIP_INPUT_TEMPLATE,\n\t          staticChips = userTemplate.find('md-chip');\n\t\n\t      // Warn of malformed template. See #2545\n\t      if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {\n\t        $log.warn('invalid placement of md-chip-remove within md-chip-template.');\n\t      }\n\t\n\t      function getTemplateByQuery (query) {\n\t        if (!attr.ngModel) return;\n\t        var element = userTemplate[0].querySelector(query);\n\t        return element && element.outerHTML;\n\t      }\n\t\n\t      /**\n\t       * Configures controller and transcludes.\n\t       */\n\t      return function postLink(scope, element, attrs, controllers) {\n\t\n\t        $mdUtil.initOptionalProperties(scope, attr);\n\t\n\t        $mdTheming(element);\n\t        var mdChipsCtrl = controllers[0];\n\t        mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;\n\t        mdChipsCtrl.chipRemoveTemplate   = chipRemoveTemplate;\n\t        mdChipsCtrl.chipInputTemplate    = chipInputTemplate;\n\t\n\t        element\n\t            .attr({ ariaHidden: true, tabindex: -1 })\n\t            .on('focus', function () { mdChipsCtrl.onFocus(); });\n\t\n\t        if (attr.ngModel) {\n\t          mdChipsCtrl.configureNgModel(element.controller('ngModel'));\n\t\n\t          // If an `md-on-append` attribute was set, tell the controller to use the expression\n\t          // when appending chips.\n\t          if (attrs.mdOnAppend) mdChipsCtrl.useMdOnAppendExpression();\n\t\n\t          // The md-autocomplete and input elements won't be compiled until after this directive\n\t          // is complete (due to their nested nature). Wait a tick before looking for them to\n\t          // configure the controller.\n\t          if (chipInputTemplate != CHIP_INPUT_TEMPLATE) {\n\t            $timeout(function() {\n\t              if (chipInputTemplate.indexOf('<md-autocomplete') === 0)\n\t                mdChipsCtrl\n\t                    .configureAutocomplete(element.find('md-autocomplete')\n\t                        .controller('mdAutocomplete'));\n\t              mdChipsCtrl.configureUserInput(element.find('input'));\n\t            });\n\t          }\n\t        }\n\t\n\t        // Compile with the parent's scope and prepend any static chips to the wrapper.\n\t        if (staticChips.length > 0) {\n\t          var compiledStaticChips = $compile(staticChips)(scope.$parent);\n\t          $timeout(function() { element.find('md-chips-wrap').prepend(compiledStaticChips); });\n\t        }\n\t      };\n\t    }\n\t  }\n\t  MdChips.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\", \"$log\", \"$timeout\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.chips')\n\t    .controller('MdContactChipsCtrl', MdContactChipsCtrl);\n\t\n\t\n\t\n\t/**\n\t * Controller for the MdContactChips component\n\t * @constructor\n\t */\n\tfunction MdContactChipsCtrl () {\n\t  /** @type {Object} */\n\t  this.selectedItem = null;\n\t\n\t  /** @type {string} */\n\t  this.searchText = '';\n\t}\n\t\n\t\n\tMdContactChipsCtrl.prototype.queryContact = function(searchText) {\n\t  var results = this.contactQuery({'$query': searchText});\n\t  return this.filterSelected ?\n\t      results.filter(angular.bind(this, this.filterSelectedContacts)) : results;\n\t};\n\t\n\t\n\tMdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {\n\t  return this.contacts.indexOf(contact) == -1;\n\t};\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t  angular\n\t      .module('material.components.chips')\n\t      .directive('mdContactChips', MdContactChips);\n\t\n\t  /**\n\t   * @ngdoc directive\n\t   * @name mdContactChips\n\t   * @module material.components.chips\n\t   *\n\t   * @description\n\t   * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an\n\t   *    `md-autocomplete` element. The component allows the caller to supply a query expression\n\t   *    which returns  a list of possible contacts. The user can select one of these and add it to\n\t   *    the list of chips.\n\t   *\n\t   * @param {string=|object=} ng-model A model to bind the list of items to\n\t   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n\t   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n\t   *    displayed when there is at least on item in the list\n\t   * @param {expression} md-contacts An expression expected to return contacts matching the search\n\t   *    test, `$query`.\n\t   * @param {string} md-contact-name The field name of the contact object representing the\n\t   *    contact's name.\n\t   * @param {string} md-contact-email The field name of the contact object representing the\n\t   *    contact's email address.\n\t   * @param {string} md-contact-image The field name of the contact object representing the\n\t   *    contact's image.\n\t   *\n\t   *\n\t   * // The following attribute has been removed but may come back.\n\t   * @param {expression=} filter-selected Whether to filter selected contacts from the list of\n\t   *    suggestions shown in the autocomplete.\n\t   *\n\t   *\n\t   *\n\t   * @usage\n\t   * <hljs lang=\"html\">\n\t   *   <md-contact-chips\n\t   *       ng-model=\"ctrl.contacts\"\n\t   *       md-contacts=\"ctrl.querySearch($query)\"\n\t   *       md-contact-name=\"name\"\n\t   *       md-contact-image=\"image\"\n\t   *       md-contact-email=\"email\"\n\t   *       placeholder=\"To\">\n\t   *   </md-contact-chips>\n\t   * </hljs>\n\t   *\n\t   */\n\t\n\t\n\t  var MD_CONTACT_CHIPS_TEMPLATE = '\\\n\t      <md-chips class=\"md-contact-chips\"\\\n\t          ng-model=\"$mdContactChipsCtrl.contacts\"\\\n\t          md-require-match=\"$mdContactChipsCtrl.requireMatch\"\\\n\t          md-autocomplete-snap>\\\n\t          <md-autocomplete\\\n\t              md-menu-class=\"md-contact-chips-suggestions\"\\\n\t              md-selected-item=\"$mdContactChipsCtrl.selectedItem\"\\\n\t              md-search-text=\"$mdContactChipsCtrl.searchText\"\\\n\t              md-items=\"item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)\"\\\n\t              md-item-text=\"$mdContactChipsCtrl.mdContactName\"\\\n\t              md-no-cache=\"true\"\\\n\t              md-autoselect\\\n\t              placeholder=\"{{$mdContactChipsCtrl.contacts.length == 0 ?\\\n\t                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}\">\\\n\t            <div class=\"md-contact-suggestion\">\\\n\t              <img \\\n\t                  ng-src=\"{{item[$mdContactChipsCtrl.contactImage]}}\"\\\n\t                  alt=\"{{item[$mdContactChipsCtrl.contactName]}}\" />\\\n\t              <span class=\"md-contact-name\" md-highlight-text=\"$mdContactChipsCtrl.searchText\">\\\n\t                {{item[$mdContactChipsCtrl.contactName]}}\\\n\t              </span>\\\n\t              <span class=\"md-contact-email\" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\\\n\t            </div>\\\n\t          </md-autocomplete>\\\n\t          <md-chip-template>\\\n\t            <div class=\"md-contact-avatar\">\\\n\t              <img \\\n\t                  ng-src=\"{{$chip[$mdContactChipsCtrl.contactImage]}}\"\\\n\t                  alt=\"{{$chip[$mdContactChipsCtrl.contactName]}}\" />\\\n\t            </div>\\\n\t            <div class=\"md-contact-name\">\\\n\t              {{$chip[$mdContactChipsCtrl.contactName]}}\\\n\t            </div>\\\n\t          </md-chip-template>\\\n\t      </md-chips>';\n\t\n\t\n\t  /**\n\t   * MDContactChips Directive Definition\n\t   *\n\t   * @param $mdTheming\n\t   * @returns {*}\n\t   * @ngInject\n\t   */\n\t  function MdContactChips ($mdTheming, $mdUtil) {\n\t    return {\n\t      template: function(element, attrs) {\n\t        return MD_CONTACT_CHIPS_TEMPLATE;\n\t      },\n\t      restrict: 'E',\n\t      controller: 'MdContactChipsCtrl',\n\t      controllerAs: '$mdContactChipsCtrl',\n\t      bindToController: true,\n\t      compile: compile,\n\t      scope: {\n\t        contactQuery: '&mdContacts',\n\t        placeholder: '@',\n\t        secondaryPlaceholder: '@',\n\t        contactName: '@mdContactName',\n\t        contactImage: '@mdContactImage',\n\t        contactEmail: '@mdContactEmail',\n\t        contacts: '=ngModel',\n\t        requireMatch: '=?mdRequireMatch'\n\t      }\n\t    };\n\t\n\t    function compile(element, attr) {\n\t      return function postLink(scope, element, attrs, controllers) {\n\t\n\t        $mdUtil.initOptionalProperties(scope, attr);\n\t        $mdTheming(element);\n\t\n\t        element.attr('tabindex', '-1');\n\t      };\n\t    }\n\t  }\n\t  MdContactChips.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdTab\n\t * @module material.components.tabs\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * Use the `<md-tab>` a nested directive used within `<md-tabs>` to specify a tab with a **label** and optional *view content*.\n\t *\n\t * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specify more\n\t * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested\n\t * markup of the `<md-tab>` is used as the tab header markup.\n\t *\n\t * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the `<md-tab-body>` tag.  This\n\t * is to define a clear separation between the tab content and the tab label.\n\t *\n\t * If a tab **label** has been identified, then any **non-**`<md-tab-label>` markup\n\t * will be considered tab content and will be transcluded to the internal `<div class=\"md-tabs-content\">` container.\n\t *\n\t * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is\n\t * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can\n\t * be initiated via data binding changes, programmatic invocation, or user gestures.\n\t *\n\t * @param {string=} label Optional attribute to specify a simple string as the tab label\n\t * @param {boolean=} disabled If present, disabled tab selection.\n\t * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.\n\t * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.\n\t *\n\t *\n\t * @usage\n\t *\n\t * <hljs lang=\"html\">\n\t * <md-tab label=\"\" disabled=\"\" md-on-select=\"\" md-on-deselect=\"\" >\n\t *   <h3>My Tab content</h3>\n\t * </md-tab>\n\t *\n\t * <md-tab >\n\t *   <md-tab-label>\n\t *     <h3>My Tab content</h3>\n\t *   </md-tab-label>\n\t *   <md-tab-body>\n\t *     <p>\n\t *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,\n\t *       totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae\n\t *       dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,\n\t *       sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.\n\t *     </p>\n\t *   </md-tab-body>\n\t * </md-tab>\n\t * </hljs>\n\t *\n\t */\n\tangular\n\t    .module('material.components.tabs')\n\t    .directive('mdTab', MdTab);\n\t\n\tfunction MdTab () {\n\t  return {\n\t    require: '^?mdTabs',\n\t    terminal: true,\n\t    template: function (element, attr) {\n\t      var label = getLabel(),\n\t          body  = getTemplate();\n\t      return '' +\n\t          '<md-tab-label>' + label + '</md-tab-label>' +\n\t          '<md-tab-body>' + body + '</md-tab-body>';\n\t      function getLabel () {\n\t        return getLabelElement() || getLabelAttribute() || getElementContents();\n\t        function getLabelAttribute () { return attr.label; }\n\t        function getLabelElement () {\n\t          var label = element.find('md-tab-label').eq(0);\n\t          if (label.length) return label.remove().html();\n\t        }\n\t        function getElementContents () {\n\t          var html = element.html();\n\t          element.empty();\n\t          return html;\n\t        }\n\t      }\n\t      function getTemplate () {\n\t        var content = element.find('md-tab-body').eq(0),\n\t            template = content.length ? content.html() : attr.label ? element.html() : '';\n\t        if (content.length) content.remove();\n\t        else if (attr.label) element.empty();\n\t        return template;\n\t      }\n\t    },\n\t    scope: {\n\t      active:   '=?mdActive',\n\t      disabled: '=?ngDisabled',\n\t      select:   '&?mdOnSelect',\n\t      deselect: '&?mdOnDeselect'\n\t    },\n\t    link: postLink\n\t  };\n\t\n\t  function postLink (scope, element, attr, ctrl) {\n\t    if (!ctrl) return;\n\t    var tabs = element.parent()[0].getElementsByTagName('md-tab'),\n\t        index = Array.prototype.indexOf.call(tabs, element[0]),\n\t        body = element.find('md-tab-body').eq(0).remove(),\n\t        label = element.find('md-tab-label').eq(0).remove(),\n\t        data = ctrl.insertTab({\n\t          scope:    scope,\n\t          parent:   scope.$parent,\n\t          index:    index,\n\t          element:  element,\n\t          template: body.html(),\n\t          label:    label.html()\n\t        }, index);\n\t\n\t    scope.select   = scope.select   || angular.noop;\n\t    scope.deselect = scope.deselect || angular.noop;\n\t\n\t    scope.$watch('active', function (active) { if (active) ctrl.select(data.getIndex()); });\n\t    scope.$watch('disabled', function () { ctrl.refreshIndex(); });\n\t    scope.$watch(\n\t        function () {\n\t          return Array.prototype.indexOf.call(tabs, element[0]);\n\t        },\n\t        function (newIndex) {\n\t          data.index = newIndex;\n\t          ctrl.updateTabOrder();\n\t        }\n\t    );\n\t    scope.$on('$destroy', function () { ctrl.removeTab(data); });\n\t\n\t  }\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.tabs')\n\t    .directive('mdTabItem', MdTabItem);\n\t\n\tfunction MdTabItem () {\n\t  return {\n\t    require: '^?mdTabs',\n\t    link: function link (scope, element, attr, ctrl) {\n\t      if (!ctrl) return;\n\t      ctrl.attachRipple(scope, element);\n\t    }\n\t  };\n\t}\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.tabs')\n\t    .directive('mdTabLabel', MdTabLabel);\n\t\n\tfunction MdTabLabel () {\n\t  return { terminal: true };\n\t}\n\t\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular.module('material.components.tabs')\n\t    .directive('mdTabScroll', MdTabScroll);\n\t\n\tfunction MdTabScroll ($parse) {\n\t  return {\n\t    restrict: 'A',\n\t    compile: function ($element, attr) {\n\t      var fn = $parse(attr.mdTabScroll, null, true);\n\t      return function ngEventHandler (scope, element) {\n\t        element.on('mousewheel', function (event) {\n\t          scope.$apply(function () { fn(scope, { $event: event }); });\n\t        });\n\t      };\n\t    }\n\t  }\n\t}\n\tMdTabScroll.$inject = [\"$parse\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.tabs')\n\t    .controller('MdTabsController', MdTabsController);\n\t\n\t/**\n\t * @ngInject\n\t */\n\tfunction MdTabsController ($scope, $element, $window, $timeout, $mdConstant, $mdTabInkRipple,\n\t                           $mdUtil, $animate, $attrs, $compile, $mdTheming) {\n\t  //-- define private properties\n\t  var ctrl       = this,\n\t      locked     = false,\n\t      elements   = getElements(),\n\t      queue      = [],\n\t      destroyed  = false,\n\t      loaded     = false;\n\t\n\t  //-- define public properties with change handlers\n\t  defineProperty('focusIndex', handleFocusIndexChange, $scope.selectedIndex || 0);\n\t  defineProperty('offsetLeft', handleOffsetChange, 0);\n\t  defineProperty('hasContent', handleHasContent, false);\n\t\n\t  //-- define public properties\n\t  ctrl.scope = $scope;\n\t  ctrl.parent = $scope.$parent;\n\t  ctrl.tabs = [];\n\t  ctrl.lastSelectedIndex = null;\n\t  ctrl.hasFocus = false;\n\t  ctrl.lastClick = true;\n\t  ctrl.shouldPaginate = false;\n\t  ctrl.shouldCenterTabs = shouldCenterTabs();\n\t\n\t  //-- define public methods\n\t  ctrl.redirectFocus = redirectFocus;\n\t  ctrl.attachRipple = attachRipple;\n\t  ctrl.shouldStretchTabs = shouldStretchTabs;\n\t  ctrl.insertTab = insertTab;\n\t  ctrl.removeTab = removeTab;\n\t  ctrl.select = select;\n\t  ctrl.scroll = scroll;\n\t  ctrl.nextPage = nextPage;\n\t  ctrl.previousPage = previousPage;\n\t  ctrl.keydown = keydown;\n\t  ctrl.canPageForward = canPageForward;\n\t  ctrl.canPageBack = canPageBack;\n\t  ctrl.refreshIndex = refreshIndex;\n\t  ctrl.incrementSelectedIndex = incrementSelectedIndex;\n\t  ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);\n\t  ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);\n\t\n\t  init();\n\t\n\t  /**\n\t   * Perform initialization for the controller, setup events and watcher(s)\n\t   */\n\t  function init () {\n\t    $scope.selectedIndex = $scope.selectedIndex || 0;\n\t    compileTemplate();\n\t    configureWatchers();\n\t    bindEvents();\n\t    $mdTheming($element);\n\t    $timeout(function () {\n\t      updateHeightFromContent();\n\t      adjustOffset();\n\t      updatePagination();\n\t      ctrl.tabs[$scope.selectedIndex] && ctrl.tabs[$scope.selectedIndex].scope.select();\n\t      loaded = true;\n\t    });\n\t  }\n\t\n\t  function compileTemplate () {\n\t    var template = $attrs.$mdTabsTemplate,\n\t        element  = angular.element(elements.data);\n\t    element.html(template);\n\t    $compile(element.contents())(ctrl.parent);\n\t    delete $attrs.$mdTabsTemplate;\n\t  }\n\t\n\t  function bindEvents () {\n\t    angular.element($window).on('resize', handleWindowResize);\n\t    angular.element(elements.paging).on('DOMSubtreeModified', ctrl.updateInkBarStyles);\n\t    angular.element(elements.paging).on('DOMSubtreeModified', updatePagination);\n\t  }\n\t\n\t  function configureWatchers () {\n\t    $mdUtil.initOptionalProperties($scope, $attrs);\n\t    $attrs.$observe('mdNoBar', function (value) { $scope.noInkBar = angular.isDefined(value); });\n\t    $scope.$watch('selectedIndex', handleSelectedIndexChange);\n\t    $scope.$watch('dynamicHeight', function (value) {\n\t      if (value) $element.addClass('md-dynamic-height');\n\t      else $element.removeClass('md-dynamic-height');\n\t    });\n\t    $scope.$on('$destroy', cleanup);\n\t  }\n\t\n\t  /**\n\t   * Remove any events defined by this controller\n\t   */\n\t  function cleanup () {\n\t    destroyed = true;\n\t    angular.element($window).off('resize', handleWindowResize);\n\t    angular.element(elements.paging).off('DOMSubtreeModified', ctrl.updateInkBarStyles);\n\t    angular.element(elements.paging).off('DOMSubtreeModified', updatePagination);\n\t  }\n\t\n\t  //-- Change handlers\n\t\n\t  /**\n\t   * Add/remove the `md-no-tab-content` class depending on `ctrl.hasContent`\n\t   * @param hasContent\n\t   */\n\t  function handleHasContent (hasContent) {\n\t    $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');\n\t  }\n\t\n\t  /**\n\t   * Apply ctrl.offsetLeft to the paging element when it changes\n\t   * @param left\n\t   */\n\t  function handleOffsetChange (left) {\n\t    var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';\n\t    angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');\n\t    $scope.$broadcast('$mdTabsPaginationChanged');\n\t  }\n\t\n\t  /**\n\t   * Update the UI whenever `ctrl.focusIndex` is updated\n\t   * @param newIndex\n\t   * @param oldIndex\n\t   */\n\t  function handleFocusIndexChange (newIndex, oldIndex) {\n\t    if (newIndex === oldIndex) return;\n\t    if (!elements.tabs[newIndex]) return;\n\t    adjustOffset();\n\t    redirectFocus();\n\t  }\n\t\n\t  /**\n\t   * Update the UI whenever the selected index changes. Calls user-defined select/deselect methods.\n\t   * @param newValue\n\t   * @param oldValue\n\t   */\n\t  function handleSelectedIndexChange (newValue, oldValue) {\n\t    if (newValue === oldValue) return;\n\t\n\t    $scope.selectedIndex = getNearestSafeIndex(newValue);\n\t    ctrl.lastSelectedIndex = oldValue;\n\t    ctrl.updateInkBarStyles();\n\t    updateHeightFromContent();\n\t    adjustOffset(newValue);\n\t    $scope.$broadcast('$mdTabsChanged');\n\t    ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();\n\t    ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();\n\t  }\n\t\n\t  /**\n\t   * Queues up a call to `handleWindowResize` when a resize occurs while the tabs component is\n\t   * hidden.\n\t   */\n\t  function handleResizeWhenVisible () {\n\t    //-- if there is already a watcher waiting for resize, do nothing\n\t    if (handleResizeWhenVisible.watcher) return;\n\t    //-- otherwise, we will abuse the $watch function to check for visible\n\t    handleResizeWhenVisible.watcher = $scope.$watch(function () {\n\t      //-- since we are checking for DOM size, we use $timeout to wait for after the DOM updates\n\t      $timeout(function () {\n\t        //-- if the watcher has already run (ie. multiple digests in one cycle), do nothing\n\t        if (!handleResizeWhenVisible.watcher) return;\n\t\n\t        if ($element.prop('offsetParent')) {\n\t          handleResizeWhenVisible.watcher();\n\t          handleResizeWhenVisible.watcher = null;\n\t\n\t          //-- we have to trigger our own $apply so that the DOM bindings will update\n\t          handleWindowResize();\n\t        }\n\t      }, 0, false);\n\t    });\n\t  }\n\t\n\t  //-- Event handlers / actions\n\t\n\t  /**\n\t   * Handle user keyboard interactions\n\t   * @param event\n\t   */\n\t  function keydown (event) {\n\t    switch (event.keyCode) {\n\t      case $mdConstant.KEY_CODE.LEFT_ARROW:\n\t        event.preventDefault();\n\t        incrementSelectedIndex(-1, true);\n\t        break;\n\t      case $mdConstant.KEY_CODE.RIGHT_ARROW:\n\t        event.preventDefault();\n\t        incrementSelectedIndex(1, true);\n\t        break;\n\t      case $mdConstant.KEY_CODE.SPACE:\n\t      case $mdConstant.KEY_CODE.ENTER:\n\t        event.preventDefault();\n\t        if (!locked) $scope.selectedIndex = ctrl.focusIndex;\n\t        break;\n\t    }\n\t    ctrl.lastClick = false;\n\t  }\n\t\n\t  /**\n\t   * Update the selected index and trigger a click event on the original `md-tab` element in order\n\t   * to fire user-added click events.\n\t   * @param index\n\t   */\n\t  function select (index) {\n\t    if (!locked) ctrl.focusIndex = $scope.selectedIndex = index;\n\t    ctrl.lastClick = true;\n\t    ctrl.tabs[index].element.triggerHandler('click');\n\t  }\n\t\n\t  /**\n\t   * When pagination is on, this makes sure the selected index is in view.\n\t   * @param event\n\t   */\n\t  function scroll (event) {\n\t    if (!ctrl.shouldPaginate) return;\n\t    event.preventDefault();\n\t    ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);\n\t  }\n\t\n\t  /**\n\t   * Slides the tabs over approximately one page forward.\n\t   */\n\t  function nextPage () {\n\t    var viewportWidth = elements.canvas.clientWidth,\n\t        totalWidth = viewportWidth + ctrl.offsetLeft,\n\t        i, tab;\n\t    for (i = 0; i < elements.tabs.length; i++) {\n\t      tab = elements.tabs[i];\n\t      if (tab.offsetLeft + tab.offsetWidth > totalWidth) break;\n\t    }\n\t    ctrl.offsetLeft = fixOffset(tab.offsetLeft);\n\t  }\n\t\n\t  /**\n\t   * Slides the tabs over approximately one page backward.\n\t   */\n\t  function previousPage () {\n\t    var i, tab;\n\t    for (i = 0; i < elements.tabs.length; i++) {\n\t      tab = elements.tabs[i];\n\t      if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft) break;\n\t    }\n\t    ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);\n\t  }\n\t\n\t  /**\n\t   * Update size calculations when the window is resized.\n\t   */\n\t  function handleWindowResize () {\n\t    $scope.$apply(function () {\n\t      ctrl.lastSelectedIndex = $scope.selectedIndex;\n\t      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n\t      $timeout(ctrl.updateInkBarStyles, 0, false);\n\t      $timeout(updatePagination);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Remove a tab from the data and select the nearest valid tab.\n\t   * @param tabData\n\t   */\n\t  function removeTab (tabData) {\n\t    var selectedIndex = $scope.selectedIndex,\n\t        tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];\n\t    refreshIndex();\n\t    //-- when removing a tab, if the selected index did not change, we have to manually trigger the\n\t    //   tab select/deselect events\n\t    if ($scope.selectedIndex === selectedIndex && !destroyed) {\n\t      tab.scope.deselect();\n\t      ctrl.tabs[$scope.selectedIndex] && ctrl.tabs[$scope.selectedIndex].scope.select();\n\t    }\n\t    $timeout(function () {\n\t      updatePagination();\n\t      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Create an entry in the tabs array for a new tab at the specified index.\n\t   * @param tabData\n\t   * @param index\n\t   * @returns {*}\n\t   */\n\t  function insertTab (tabData, index) {\n\t    var proto = {\n\t          getIndex: function () { return ctrl.tabs.indexOf(tab); },\n\t          isActive: function () { return this.getIndex() === $scope.selectedIndex; },\n\t          isLeft:   function () { return this.getIndex() < $scope.selectedIndex; },\n\t          isRight:  function () { return this.getIndex() > $scope.selectedIndex; },\n\t          shouldRender: function () { return !$scope.noDisconnect || this.isActive(); },\n\t          hasFocus: function () { return !ctrl.lastClick\n\t              && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex; },\n\t          id:       $mdUtil.nextUid()\n\t        },\n\t        tab = angular.extend(proto, tabData);\n\t    if (angular.isDefined(index)) {\n\t      ctrl.tabs.splice(index, 0, tab);\n\t    } else {\n\t      ctrl.tabs.push(tab);\n\t    }\n\t    processQueue();\n\t    updateHasContent();\n\t    //-- if autoselect is enabled, select the newly added tab\n\t    if (loaded && $scope.autoselect) $timeout(function () { select(ctrl.tabs.indexOf(tab)); });\n\t    $timeout(updatePagination);\n\t    return tab;\n\t  }\n\t\n\t  //-- Getter methods\n\t\n\t  /**\n\t   * Gathers references to all of the DOM elements used by this controller.\n\t   * @returns {{}}\n\t   */\n\t  function getElements () {\n\t    var elements      = {};\n\t\n\t    //-- gather tab bar elements\n\t    elements.wrapper  = $element[0].getElementsByTagName('md-tabs-wrapper')[0];\n\t    elements.data     = $element[0].getElementsByTagName('md-tab-data')[0];\n\t    elements.canvas   = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];\n\t    elements.paging   = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];\n\t    elements.tabs     = elements.paging.getElementsByTagName('md-tab-item');\n\t    elements.dummies  = elements.canvas.getElementsByTagName('md-dummy-tab');\n\t    elements.inkBar   = elements.paging.getElementsByTagName('md-ink-bar')[0];\n\t\n\t    //-- gather tab content elements\n\t    elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];\n\t    elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');\n\t\n\t    return elements;\n\t  }\n\t\n\t  /**\n\t   * Determines whether or not the left pagination arrow should be enabled.\n\t   * @returns {boolean}\n\t   */\n\t  function canPageBack () {\n\t    return ctrl.offsetLeft > 0;\n\t  }\n\t\n\t  /**\n\t   * Determines whether or not the right pagination arrow should be enabled.\n\t   * @returns {*|boolean}\n\t   */\n\t  function canPageForward () {\n\t    var lastTab = elements.tabs[elements.tabs.length - 1];\n\t    return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth +\n\t        ctrl.offsetLeft;\n\t  }\n\t\n\t  /**\n\t   * Determines if the UI should stretch the tabs to fill the available space.\n\t   * @returns {*}\n\t   */\n\t  function shouldStretchTabs () {\n\t    switch ($scope.stretchTabs) {\n\t      case 'always': return true;\n\t      case 'never':  return false;\n\t      default:       return !ctrl.shouldPaginate\n\t          && $window.matchMedia('(max-width: 600px)').matches;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Determines if the tabs should appear centered.\n\t   * @returns {string|boolean}\n\t   */\n\t  function shouldCenterTabs () {\n\t    return $scope.centerTabs && !ctrl.shouldPaginate;\n\t  }\n\t\n\t  /**\n\t   * Determines if pagination is necessary to display the tabs within the available space.\n\t   * @returns {boolean}\n\t   */\n\t  function shouldPaginate () {\n\t    if ($scope.noPagination || !loaded) return false;\n\t    var canvasWidth = $element.prop('clientWidth');\n\t    angular.forEach(elements.dummies, function (tab) { canvasWidth -= tab.offsetWidth; });\n\t    return canvasWidth < 0;\n\t  }\n\t\n\t  /**\n\t   * Finds the nearest tab index that is available.  This is primarily used for when the active\n\t   * tab is removed.\n\t   * @param newIndex\n\t   * @returns {*}\n\t   */\n\t  function getNearestSafeIndex(newIndex) {\n\t    var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),\n\t        i, tab;\n\t    for (i = 0; i <= maxOffset; i++) {\n\t      tab = ctrl.tabs[newIndex + i];\n\t      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n\t      tab = ctrl.tabs[newIndex - i];\n\t      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n\t    }\n\t    return newIndex;\n\t  }\n\t\n\t  //-- Utility methods\n\t\n\t  /**\n\t   * Defines a property using a getter and setter in order to trigger a change handler without\n\t   * using `$watch` to observe changes.\n\t   * @param key\n\t   * @param handler\n\t   * @param value\n\t   */\n\t  function defineProperty (key, handler, value) {\n\t    Object.defineProperty(ctrl, key, {\n\t      get: function () { return value; },\n\t      set: function (newValue) {\n\t        var oldValue = value;\n\t        value = newValue;\n\t        handler(newValue, oldValue);\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Updates whether or not pagination should be displayed.\n\t   */\n\t  function updatePagination () {\n\t    ctrl.shouldPaginate = shouldPaginate();\n\t    ctrl.shouldCenterTabs = shouldCenterTabs();\n\t    $timeout(function () {\n\t      adjustOffset($scope.selectedIndex);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Re-orders the tabs and updates the selected and focus indexes to their new positions.\n\t   * This is triggered by `tabDirective.js` when the user's tabs have been re-ordered.\n\t   */\n\t  function updateTabOrder () {\n\t    var selectedItem = ctrl.tabs[$scope.selectedIndex],\n\t        focusItem = ctrl.tabs[ctrl.focusIndex];\n\t    ctrl.tabs = ctrl.tabs.sort(function (a, b) {\n\t      return a.index - b.index;\n\t    });\n\t    $scope.selectedIndex = ctrl.tabs.indexOf(selectedItem);\n\t    ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);\n\t  }\n\t\n\t  /**\n\t   * This moves the selected or focus index left or right.  This is used by the keydown handler.\n\t   * @param inc\n\t   */\n\t  function incrementSelectedIndex (inc) {\n\t    var newIndex,\n\t        index = ctrl.focusIndex;\n\t    for (newIndex = index + inc;\n\t         ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled;\n\t         newIndex += inc) {}\n\t    if (ctrl.tabs[newIndex]) {\n\t      ctrl.focusIndex = newIndex;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * This is used to forward focus to dummy elements.  This method is necessary to avoid aniation\n\t   * issues when attempting to focus an item that is out of view.\n\t   */\n\t  function redirectFocus () {\n\t    elements.dummies[ctrl.focusIndex].focus();\n\t  }\n\t\n\t  /**\n\t   * Forces the pagination to move the focused tab into view.\n\t   */\n\t  function adjustOffset (index) {\n\t    if (ctrl.shouldCenterTabs) return;\n\t    if (index == null) index = ctrl.focusIndex;\n\t    var tab = elements.tabs[index],\n\t        left = tab.offsetLeft,\n\t        right = tab.offsetWidth + left;\n\t    ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth));\n\t    ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));\n\t  }\n\t\n\t  /**\n\t   * Iterates through all queued functions and clears the queue.  This is used for functions that\n\t   * are called before the UI is ready, such as size calculations.\n\t   */\n\t  function processQueue () {\n\t    queue.forEach(function (func) { $timeout(func); });\n\t    queue = [];\n\t  }\n\t\n\t  /**\n\t   * Determines if the tab content area is needed.\n\t   */\n\t  function updateHasContent () {\n\t    var hasContent = false;\n\t    angular.forEach(ctrl.tabs, function (tab) {\n\t      if (tab.template) hasContent = true;\n\t    });\n\t    ctrl.hasContent = hasContent;\n\t  }\n\t\n\t  /**\n\t   * Moves the indexes to their nearest valid values.\n\t   */\n\t  function refreshIndex () {\n\t    $scope.selectedIndex = getNearestSafeIndex($scope.selectedIndex);\n\t    ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);\n\t  }\n\t\n\t  /**\n\t   * Calculates the content height of the current tab.\n\t   * @returns {*}\n\t   */\n\t  function updateHeightFromContent () {\n\t    if (!$scope.dynamicHeight) return $element.css('height', '');\n\t    if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);\n\t    var tabContent    = elements.contents[$scope.selectedIndex],\n\t        contentHeight = tabContent ? tabContent.offsetHeight : 0,\n\t        tabsHeight    = elements.wrapper.offsetHeight,\n\t        newHeight     = contentHeight + tabsHeight,\n\t        currentHeight = $element.prop('clientHeight');\n\t    if (currentHeight === newHeight) return;\n\t    locked = true;\n\t    $animate\n\t        .animate(\n\t          $element,\n\t          { height: currentHeight + 'px' },\n\t          { height: newHeight + 'px'}\n\t        )\n\t        .then(function () {\n\t          $element.css('height', '');\n\t          locked = false;\n\t        });\n\t  }\n\t\n\t  /**\n\t   * Repositions the ink bar to the selected tab.\n\t   * @returns {*}\n\t   */\n\t  function updateInkBarStyles () {\n\t    if (!elements.tabs[$scope.selectedIndex]) return;\n\t    if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);\n\t    //-- if the element is not visible, we will not be able to calculate sizes until it is\n\t    //-- we should treat that as a resize event rather than just updating the ink bar\n\t    if (!$element.prop('offsetParent')) return handleResizeWhenVisible();\n\t    var index = $scope.selectedIndex,\n\t        totalWidth = elements.paging.offsetWidth,\n\t        tab = elements.tabs[index],\n\t        left = tab.offsetLeft,\n\t        right = totalWidth - left - tab.offsetWidth;\n\t    updateInkBarClassName();\n\t    angular.element(elements.inkBar).css({ left: left + 'px', right: right + 'px' });\n\t  }\n\t\n\t  /**\n\t   * Adds left/right classes so that the ink bar will animate properly.\n\t   */\n\t  function updateInkBarClassName () {\n\t    var newIndex = $scope.selectedIndex,\n\t        oldIndex = ctrl.lastSelectedIndex,\n\t        ink = angular.element(elements.inkBar);\n\t    if (!angular.isNumber(oldIndex)) return;\n\t    if (newIndex < oldIndex) {\n\t      ink.addClass('md-left').removeClass('md-right');\n\t    } else if (newIndex > oldIndex) {\n\t      ink.addClass('md-right').removeClass('md-left');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Takes an offset value and makes sure that it is within the min/max allowed values.\n\t   * @param value\n\t   * @returns {*}\n\t   */\n\t  function fixOffset (value) {\n\t    if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;\n\t    var lastTab = elements.tabs[elements.tabs.length - 1],\n\t        totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;\n\t    value = Math.max(0, value);\n\t    value = Math.min(totalWidth - elements.canvas.clientWidth, value);\n\t    return value;\n\t  }\n\t\n\t  /**\n\t   * Attaches a ripple to the tab item element.\n\t   * @param scope\n\t   * @param element\n\t   */\n\t  function attachRipple (scope, element) {\n\t    var options = { colorElement: angular.element(elements.inkBar) };\n\t    $mdTabInkRipple.attach(scope, element, options);\n\t  }\n\t}\n\tMdTabsController.$inject = [\"$scope\", \"$element\", \"$window\", \"$timeout\", \"$mdConstant\", \"$mdTabInkRipple\", \"$mdUtil\", \"$animate\", \"$attrs\", \"$compile\", \"$mdTheming\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name mdTabs\n\t * @module material.components.tabs\n\t *\n\t * @restrict E\n\t *\n\t * @description\n\t * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.\n\t * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view\n\t * content that will be associated with each tab button.\n\t *\n\t * Below is the markup for its simplest usage:\n\t *\n\t *  <hljs lang=\"html\">\n\t *  <md-tabs>\n\t *    <md-tab label=\"Tab #1\"></md-tab>\n\t *    <md-tab label=\"Tab #2\"></md-tab>\n\t *    <md-tab label=\"Tab #3\"></md-tab>\n\t *  </md-tabs>\n\t *  </hljs>\n\t *\n\t * Tabs supports three (3) usage scenarios:\n\t *\n\t *  1. Tabs (buttons only)\n\t *  2. Tabs with internal view content\n\t *  3. Tabs with external view content\n\t *\n\t * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.\n\t * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.\n\t * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.\n\t *\n\t * Additional features also include:\n\t *\n\t * *  Content can include any markup.\n\t * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.\n\t *\n\t * ### Explanation of tab stretching\n\t *\n\t * Initially, tabs will have an inherent size.  This size will either be defined by how much space is needed to accommodate their text or set by the user through CSS.  Calculations will be based on this size.\n\t *\n\t * On mobile devices, tabs will be expanded to fill the available horizontal space.  When this happens, all tabs will become the same size.\n\t *\n\t * On desktops, by default, stretching will never occur.\n\t *\n\t * This default behavior can be overridden through the `md-stretch-tabs` attribute.  Here is a table showing when stretching will occur:\n\t *\n\t * `md-stretch-tabs` | mobile    | desktop\n\t * ------------------|-----------|--------\n\t * `auto`            | stretched | ---\n\t * `always`          | stretched | stretched\n\t * `never`           | ---       | ---\n\t *\n\t * @param {integer=} md-selected Index of the active/selected tab\n\t * @param {boolean=} md-no-ink If present, disables ink ripple effects.\n\t * @param {boolean=} md-no-bar If present, disables the selection ink bar.\n\t * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`; default is `top`\n\t * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`, `always`, or `never`; default is `auto`\n\t * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the contents of the selected tab\n\t * @param {boolean=} md-center-tabs When enabled, tabs will be centered provided there is no need for pagination\n\t * @param {boolean=} md-no-pagination When enabled, pagination will remain off\n\t * @param {boolean=} md-swipe-content When enabled, swipe gestures will be enabled for the content area to jump between tabs\n\t * @param {boolean=} md-no-disconnect If your tab content has background tasks (ie. event listeners), you will want to include this to prevent the scope from being disconnected\n\t * @param {boolean=} md-autoselect When present, any tabs added after the initial load will be automatically selected\n\t *\n\t * @usage\n\t * <hljs lang=\"html\">\n\t * <md-tabs md-selected=\"selectedIndex\" >\n\t *   <img ng-src=\"img/angular.png\" class=\"centered\">\n\t *   <md-tab\n\t *       ng-repeat=\"tab in tabs | orderBy:predicate:reversed\"\n\t *       md-on-select=\"onTabSelected(tab)\"\n\t *       md-on-deselect=\"announceDeselected(tab)\"\n\t *       ng-disabled=\"tab.disabled\">\n\t *     <md-tab-label>\n\t *       {{tab.title}}\n\t *       <img src=\"img/removeTab.png\" ng-click=\"removeTab(tab)\" class=\"delete\">\n\t *     </md-tab-label>\n\t *     <md-tab-body>\n\t *       {{tab.content}}\n\t *     </md-tab-body>\n\t *   </md-tab>\n\t * </md-tabs>\n\t * </hljs>\n\t *\n\t */\n\tangular\n\t    .module('material.components.tabs')\n\t    .directive('mdTabs', MdTabs);\n\t\n\tfunction MdTabs ($mdTheming, $mdUtil, $compile) {\n\t  return {\n\t    scope: {\n\t      noPagination:  '=?mdNoPagination',\n\t      dynamicHeight: '=?mdDynamicHeight',\n\t      centerTabs:    '=?mdCenterTabs',\n\t      selectedIndex: '=?mdSelected',\n\t      stretchTabs:   '@?mdStretchTabs',\n\t      swipeContent:  '=?mdSwipeContent',\n\t      noDisconnect:  '=?mdNoDisconnect',\n\t      autoselect:    '=?mdAutoselect'\n\t    },\n\t    template: function (element, attr) {\n\t      attr[\"$mdTabsTemplate\"] = element.html();\n\t      return '\\\n\t        <md-tabs-wrapper ng-class=\"{ \\'md-stretch-tabs\\': $mdTabsCtrl.shouldStretchTabs() }\">\\\n\t          <md-tab-data></md-tab-data>\\\n\t          <md-prev-button\\\n\t              tabindex=\"-1\"\\\n\t              role=\"button\"\\\n\t              aria-label=\"Previous Page\"\\\n\t              aria-disabled=\"{{!$mdTabsCtrl.canPageBack()}}\"\\\n\t              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageBack() }\"\\\n\t              ng-if=\"$mdTabsCtrl.shouldPaginate\"\\\n\t              ng-click=\"$mdTabsCtrl.previousPage()\">\\\n\t            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n\t          </md-prev-button>\\\n\t          <md-next-button\\\n\t              tabindex=\"-1\"\\\n\t              role=\"button\"\\\n\t              aria-label=\"Next Page\"\\\n\t              aria-disabled=\"{{!$mdTabsCtrl.canPageForward()}}\"\\\n\t              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageForward() }\"\\\n\t              ng-if=\"$mdTabsCtrl.shouldPaginate\"\\\n\t              ng-click=\"$mdTabsCtrl.nextPage()\">\\\n\t            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n\t          </md-next-button>\\\n\t          <md-tabs-canvas\\\n\t              tabindex=\"0\"\\\n\t              aria-activedescendant=\"tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}\"\\\n\t              ng-focus=\"$mdTabsCtrl.redirectFocus()\"\\\n\t              ng-class=\"{\\\n\t                  \\'md-paginated\\': $mdTabsCtrl.shouldPaginate,\\\n\t                  \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs\\\n\t              }\"\\\n\t              ng-keydown=\"$mdTabsCtrl.keydown($event)\"\\\n\t              role=\"tablist\">\\\n\t            <md-pagination-wrapper\\\n\t                ng-class=\"{ \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs }\"\\\n\t                md-tab-scroll=\"$mdTabsCtrl.scroll($event)\">\\\n\t              <md-tab-item\\\n\t                  tabindex=\"-1\"\\\n\t                  class=\"md-tab\"\\\n\t                  style=\"max-width: {{ tabWidth ? tabWidth + \\'px\\' : \\'none\\' }}\"\\\n\t                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n\t                  role=\"tab\"\\\n\t                  aria-controls=\"tab-content-{{tab.id}}\"\\\n\t                  aria-selected=\"{{tab.isActive()}}\"\\\n\t                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n\t                  ng-click=\"$mdTabsCtrl.select(tab.getIndex())\"\\\n\t                  ng-class=\"{\\\n\t                      \\'md-active\\':    tab.isActive(),\\\n\t                      \\'md-focused\\':   tab.hasFocus(),\\\n\t                      \\'md-disabled\\':  tab.scope.disabled\\\n\t                  }\"\\\n\t                  ng-disabled=\"tab.scope.disabled\"\\\n\t                  md-swipe-left=\"$mdTabsCtrl.nextPage()\"\\\n\t                  md-swipe-right=\"$mdTabsCtrl.previousPage()\"\\\n\t                  md-template=\"tab.label\"\\\n\t                  md-scope=\"tab.parent\"></md-tab-item>\\\n\t              <md-ink-bar ng-hide=\"noInkBar\"></md-ink-bar>\\\n\t            </md-pagination-wrapper>\\\n\t            <div class=\"md-visually-hidden md-dummy-wrapper\">\\\n\t              <md-dummy-tab\\\n\t                  class=\"md-tab\"\\\n\t                  tabindex=\"-1\"\\\n\t                  id=\"tab-item-{{tab.id}}\"\\\n\t                  role=\"tab\"\\\n\t                  aria-controls=\"tab-content-{{tab.id}}\"\\\n\t                  aria-selected=\"{{tab.isActive()}}\"\\\n\t                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n\t                  ng-focus=\"$mdTabsCtrl.hasFocus = true\"\\\n\t                  ng-blur=\"$mdTabsCtrl.hasFocus = false\"\\\n\t                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n\t                  md-template=\"tab.label\"\\\n\t                  md-scope=\"tab.parent\"></md-dummy-tab>\\\n\t            </div>\\\n\t          </md-tabs-canvas>\\\n\t        </md-tabs-wrapper>\\\n\t        <md-tabs-content-wrapper ng-show=\"$mdTabsCtrl.hasContent\">\\\n\t          <md-tab-content\\\n\t              id=\"tab-content-{{tab.id}}\"\\\n\t              role=\"tabpanel\"\\\n\t              aria-labelledby=\"tab-item-{{tab.id}}\"\\\n\t              md-swipe-left=\"swipeContent && $mdTabsCtrl.incrementSelectedIndex(1)\"\\\n\t              md-swipe-right=\"swipeContent && $mdTabsCtrl.incrementSelectedIndex(-1)\"\\\n\t              ng-if=\"$mdTabsCtrl.hasContent\"\\\n\t              ng-repeat=\"(index, tab) in $mdTabsCtrl.tabs\"\\\n\t              md-connected-if=\"tab.isActive()\"\\\n\t              ng-class=\"{\\\n\t                \\'md-no-transition\\': $mdTabsCtrl.lastSelectedIndex == null,\\\n\t                \\'md-active\\':        tab.isActive(),\\\n\t                \\'md-left\\':          tab.isLeft(),\\\n\t                \\'md-right\\':         tab.isRight(),\\\n\t                \\'md-no-scroll\\':     dynamicHeight\\\n\t              }\">\\\n\t            <div\\\n\t                md-template=\"tab.template\"\\\n\t                md-scope=\"tab.parent\"\\\n\t                ng-if=\"tab.shouldRender()\"></div>\\\n\t          </md-tab-content>\\\n\t        </md-tabs-content-wrapper>\\\n\t      ';\n\t    },\n\t    controller: 'MdTabsController',\n\t    controllerAs: '$mdTabsCtrl'\n\t  };\n\t}\n\tMdTabs.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\"];\n\t\n\t})();\n\t(function(){\n\t\"use strict\";\n\t\n\tangular\n\t    .module('material.components.tabs')\n\t    .directive('mdTemplate', MdTemplate);\n\t\n\tfunction MdTemplate ($compile, $mdUtil, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    link: link,\n\t    scope: {\n\t      template: '=mdTemplate',\n\t      compileScope: '=mdScope',\n\t      connected: '=?mdConnectedIf'\n\t    },\n\t    require: '^?mdTabs'\n\t  };\n\t  function link (scope, element, attr, ctrl) {\n\t    if (!ctrl) return;\n\t    var compileScope = scope.compileScope.$new();\n\t    element.html(scope.template);\n\t    $compile(element.contents())(compileScope);\n\t    return $timeout(handleScope);\n\t    function handleScope () {\n\t      scope.$watch('connected', function (value) { value === false ? disconnect() : reconnect(); });\n\t      scope.$on('$destroy', reconnect);\n\t    }\n\t    function disconnect () {\n\t      if (ctrl.scope.noDisconnect) return;\n\t      $mdUtil.disconnectScope(compileScope);\n\t    }\n\t    function reconnect () {\n\t      if (ctrl.scope.noDisconnect) return;\n\t      $mdUtil.reconnectScope(compileScope);\n\t    }\n\t  }\n\t}\n\tMdTemplate.$inject = [\"$compile\", \"$mdUtil\", \"$timeout\"];\n\t\n\t})();\n\t(function(){ \n\tangular.module(\"material.core\").constant(\"$MD_THEME_CSS\", \"/* mixin definition ; sets LTR and RTL within the same style call */md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop.md-opaque.md-THEME_NAME-theme {  background-color: '{{foreground-4-0.5}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }a.md-button.md-THEME_NAME-theme, .md-button.md-THEME_NAME-theme {  border-radius: 3px; }  a.md-button.md-THEME_NAME-theme:not([disabled]):hover, .md-button.md-THEME_NAME-theme:not([disabled]):hover {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme:not([disabled]).md-focused {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover, .md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {    background-color: transparent; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab md-icon, .md-button.md-THEME_NAME-theme.md-fab md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-icon-button, .md-button.md-THEME_NAME-theme.md-icon-button {    border-radius: 50%; }  a.md-button.md-THEME_NAME-theme.md-primary, .md-button.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab, .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {      color: '{{primary-contrast}}';      background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {        color: '{{primary-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {        background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {        background-color: '{{primary-600}}'; }    a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {      color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-raised, .md-button.md-THEME_NAME-theme.md-raised {    color: '{{background-contrast}}';    background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon {      color: '{{background-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {      background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {      background-color: '{{background-200}}'; }  a.md-button.md-THEME_NAME-theme.md-warn, .md-button.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab, .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {      color: '{{warn-contrast}}';      background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {        color: '{{warn-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {        background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {        background-color: '{{warn-700}}'; }    a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {      color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent, .md-button.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab, .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {      color: '{{accent-contrast}}';      background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {        color: '{{accent-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {        background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {        background-color: '{{accent-700}}'; }    a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {      color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled], .md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-accent[disabled], .md-button.md-THEME_NAME-theme.md-warn[disabled] {    color: '{{foreground-3}}';    cursor: not-allowed; }    a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon, .md-button.md-THEME_NAME-theme[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {      color: '{{foreground-3}}'; }  a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {    background-color: '{{foreground-4}}'; }  a.md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme[disabled] {    background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label, md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages, md-input-container.md-THEME_NAME-theme [ng-message], md-input-container.md-THEME_NAME-theme [data-ng-message], md-input-container.md-THEME_NAME-theme [x-ng-message] {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled], [disabled] md-input-container.md-THEME_NAME-theme .md-input {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, '{{foreground-3}}' 0%, '{{foreground-3}}' 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, '{{foreground-3}}' 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-list.md-THEME_NAME-theme md-list-item button {  background-color: '{{background-color}}'; }  md-list.md-THEME_NAME-theme md-list-item button.md-button:not([disabled]):hover {    background-color: '{{background-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient('{{warn-100}}' 0%, '{{warn-100}}' 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient('{{accent-100}}' 0%, '{{accent-100}}' 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled], md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked:not([disabled]).md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-label {  color: '{{warn-500}}' !important;  border-bottom-color: '{{warn-500}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label.md-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-label {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-label {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-label {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-label.md-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme .md-select-label {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-label.md-placeholder {    color: '{{foreground-2}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  border-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled] {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme .md-button {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-background {    background-color: '{{foreground-2}}'; }\"); \n\t})();\n\t\n\t\n\t})(window, window.angular);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Should already be required, here for clarity\n\t__webpack_require__(1);\n\t\n\t// Load Angular and dependent libs\n\t__webpack_require__(3);\n\t__webpack_require__(5);\n\t\n\t// Now load Angular Material\n\t__webpack_require__(6);\n\t\n\t// Export namespace\n\tmodule.exports = 'ngMaterial';\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\t\n\tvar angular = __webpack_require__(1);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _angularFix = __webpack_require__(8);\n\t\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\tvar _angularFormly = __webpack_require__(25);\n\t\n\tvar _angularFormly2 = _interopRequireDefault(_angularFormly);\n\t\n\tvar _angularMaterial = __webpack_require__(7);\n\t\n\tvar _angularMaterial2 = _interopRequireDefault(_angularMaterial);\n\t\n\t// manipulators\n\t\n\tvar _runMdInputContainerFlexManipulator = __webpack_require__(10);\n\t\n\tvar _runMdInputContainerFlexManipulator2 = _interopRequireDefault(_runMdInputContainerFlexManipulator);\n\t\n\t// types\n\t\n\tvar _typesCheckbox = __webpack_require__(11);\n\t\n\tvar _typesCheckbox2 = _interopRequireDefault(_typesCheckbox);\n\t\n\tvar _typesInput = __webpack_require__(12);\n\t\n\tvar _typesInput2 = _interopRequireDefault(_typesInput);\n\t\n\tvar _typesMultiCheckbox = __webpack_require__(13);\n\t\n\tvar _typesMultiCheckbox2 = _interopRequireDefault(_typesMultiCheckbox);\n\t\n\tvar _typesRadio = __webpack_require__(14);\n\t\n\tvar _typesRadio2 = _interopRequireDefault(_typesRadio);\n\t\n\tvar _typesSelect = __webpack_require__(15);\n\t\n\tvar _typesSelect2 = _interopRequireDefault(_typesSelect);\n\t\n\tvar _typesTextarea = __webpack_require__(16);\n\t\n\tvar _typesTextarea2 = _interopRequireDefault(_typesTextarea);\n\t\n\t// wrappers\n\t\n\tvar _wrappersMdLabel = __webpack_require__(18);\n\t\n\tvar _wrappersMdLabel2 = _interopRequireDefault(_wrappersMdLabel);\n\t\n\tvar _wrappersMdInputContainer = __webpack_require__(17);\n\t\n\tvar _wrappersMdInputContainer2 = _interopRequireDefault(_wrappersMdInputContainer);\n\t\n\tvar ngModuleName = 'formlyMaterial';\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, [_angularFormly2['default'], _angularMaterial2['default']]);\n\tngModule.constant('formlyMaterialApiCheck', __webpack_require__(24)({\n\t  output: {\n\t    prefix: 'angular-formly-material'\n\t  }\n\t}));\n\tngModule.constant('formlyMaterialVersion', (\"1.0.0-beta.0\"));\n\t\n\texports['default'] = ngModuleName;\n\t\n\tvar configFns = [_typesCheckbox2['default'], _typesInput2['default'], _typesMultiCheckbox2['default'], _typesRadio2['default'], _typesSelect2['default'], _typesTextarea2['default'], _wrappersMdLabel2['default'], _wrappersMdInputContainer2['default']];\n\t\n\t_angularFix2['default'].forEach(configFns, function (configFn) {\n\t  return _angularFix2['default'].config(configFn);\n\t});\n\t\n\tvar runFns = [_runMdInputContainerFlexManipulator2['default']];\n\t\n\t_angularFix2['default'].forEach(runFns, function (runFn) {\n\t  return _angularFix2['default'].run(runFn);\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addMdInputContainerFlexManipulator;\n\t\n\t// @ngInject\n\tfunction addMdInputContainerFlexManipulator(formlyConfig) {\n\t  formlyConfig.templateManipulators.postWrapper.push(function mdInputContainerFlex(template, options, scope) {\n\t    if (angular.isDefined(options.templateOptions.flex)) {\n\t      var el = angular.element('<div>' + template + '</div>');\n\t      var mdInputContainer = el[0].querySelector('md-input-container');\n\t      if (mdInputContainer) {\n\t        mdInputContainer.setAttribute('flex', options.templateOptions.flex);\n\t        return el;\n\t      } else {\n\t        return template;\n\t      }\n\t    } else {\n\t      return template;\n\t    }\n\t  });\n\t}\n\taddMdInputContainerFlexManipulator.$inject = [\"formlyConfig\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addCheckboxType;\n\t\n\t// @ngInject\n\tfunction addCheckboxType(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setType({\n\t    name: 'checkbox',\n\t    template: __webpack_require__(19),\n\t    wrapper: ['bootstrapHasError'],\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        label: c.string\n\t      })\n\t    },\n\t    apiCheckInstance: c\n\t  });\n\t}\n\taddCheckboxType.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addInputType;\n\t\n\t// @ngInject\n\tfunction addInputType(formlyConfigProvider) {\n\t  formlyConfigProvider.setType({\n\t    name: 'input',\n\t    template: '<input ng-model=\"model[options.key]\">',\n\t    wrapper: ['materialLabel', 'mdInputContainer'],\n\t    defaultOptions: {\n\t      ngModelAttrs: {\n\t        mdMaxlength: {\n\t          bound: 'md-maxlength'\n\t        }\n\t      }\n\t    }\n\t  });\n\t}\n\taddInputType.$inject = [\"formlyConfigProvider\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addCheckboxType;\n\t\n\t// @ngInject\n\tfunction addCheckboxType(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setType({\n\t    name: 'multiCheckbox',\n\t    template: __webpack_require__(20),\n\t    wrapper: ['materialLabel', 'bootstrapHasError'],\n\t    defaultOptions: {\n\t      noFormControl: false\n\t    },\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        options: c.arrayOf(c.object),\n\t        labelProp: c.string.optional,\n\t        valueProp: c.string.optional\n\t      })\n\t    },\n\t    apiCheckInstance: c,\n\t    controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t      var to = $scope.to;\n\t      var opts = $scope.options;\n\t      $scope.multiCheckbox = {\n\t        checked: [],\n\t        change: setModel\n\t      };\n\t\n\t      // initialize the checkboxes check property\n\t      var modelValue = $scope.model[opts.key];\n\t      if (angular.isArray(modelValue)) {\n\t        (function () {\n\t          var valueProp = to.valueProp || 'value';\n\t          angular.forEach(to.options, function (v, index) {\n\t            $scope.multiCheckbox.checked[index] = modelValue.indexOf(v[valueProp]) !== -1;\n\t          });\n\t        })();\n\t      }\n\t\n\t      function setModel() {\n\t        $scope.model[opts.key] = [];\n\t        angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t          if (checkbox) {\n\t            $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t          }\n\t        });\n\t      }\n\t    }]\n\t  });\n\t}\n\taddCheckboxType.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addRadioType;\n\t\n\t// @ngInject\n\tfunction addRadioType(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setType({\n\t    name: 'radio',\n\t    template: __webpack_require__(21),\n\t    wrapper: ['materialLabel', 'bootstrapHasError'],\n\t    defaultOptions: {\n\t      noFormControl: false\n\t    },\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        options: c.arrayOf(c.object),\n\t        labelProp: c.string.optional,\n\t        valueProp: c.string.optional\n\t      })\n\t    },\n\t    apiCheckInstance: c\n\t  });\n\t}\n\taddRadioType.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addSelectType;\n\t\n\t// @ngInject\n\tfunction addSelectType(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setType({\n\t    name: 'select',\n\t    template: __webpack_require__(22),\n\t    wrapper: ['materialLabel', 'bootstrapHasError'],\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        options: c.arrayOf(c.object),\n\t        labelProp: c.string.optional,\n\t        valueProp: c.string.optional,\n\t        groupProp: c.string.optional\n\t      })\n\t    },\n\t    apiCheckInstance: c\n\t  });\n\t}\n\taddSelectType.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addTextareaType;\n\t\n\t// @ngInject\n\tfunction addTextareaType(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setType({\n\t    name: 'textarea',\n\t    template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t    wrapper: ['materialLabel', 'bootstrapHasError'],\n\t    defaultOptions: {\n\t      ngModelAttrs: {\n\t        rows: { attribute: 'rows' },\n\t        cols: { attribute: 'cols' }\n\t      }\n\t    },\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        rows: c.number.optional,\n\t        cols: c.number.optional\n\t      })\n\t    },\n\t    apiCheckInstance: c\n\t  });\n\t}\n\taddTextareaType.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addMdInputContainerWrapper;\n\t\n\t// @ngInject\n\tfunction addMdInputContainerWrapper(formlyConfigProvider) {\n\t  formlyConfigProvider.setWrapper({\n\t    name: 'mdInputContainer',\n\t    template: '<md-input-container><formly-transclude></formly-transclude></md-input-container>'\n\t  });\n\t}\n\taddMdInputContainerWrapper.$inject = [\"formlyConfigProvider\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = addMdLabelWrapper;\n\t\n\t// @ngInject\n\tfunction addMdLabelWrapper(formlyConfigProvider, formlyMaterialApiCheck) {\n\t  var c = formlyMaterialApiCheck;\n\t  formlyConfigProvider.setWrapper({\n\t    name: 'mdLabel',\n\t    template: __webpack_require__(23),\n\t    apiCheck: {\n\t      templateOptions: c.shape({\n\t        label: c.string,\n\t        required: c.bool.optional\n\t      })\n\t    },\n\t    apiCheckInstance: c\n\t  });\n\t}\n\taddMdLabelWrapper.$inject = [\"formlyConfigProvider\", \"formlyMaterialApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<select class=\\\"form-control\\\"\\n        ng-model=\\\"model[options.key]\\\"\\n        ng-options=\\\"option[to.valueProp || 'value'] as option[to.labelProp || 'name'] group by option[to.groupProp || 'group'] for option in to.options\\\">\\n</select>\\n\"\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<label for=\\\"{{id}}\\\" class=\\\"control-label\\\">\\n  {{to.label}}\\n  {{to.required ? '*' : ''}}\\n</label>\\n<formly-transclude></formly-transclude>\\n\"\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_25__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-formly-templates-material.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bf319401c7087a02f574\n **/","import index from './index.common';\nexport default index;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * @license AngularJS v1.3.15\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint maxlen: false */\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n *\n * To see animations in action, all that is required is to define the appropriate CSS classes\n * or to register a JavaScript animation via the `myModule.animation()` function. The directives that support animation automatically are:\n * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation\n * by using the `$animate` service.\n *\n * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * You can find out more information about animations upon visiting each directive page.\n *\n * Below is an example of how to apply animations to a directive that supports animation hooks:\n *\n * ```html\n * <style type=\"text/css\">\n * .slide.ng-enter, .slide.ng-leave {\n *   -webkit-transition:0.5s linear all;\n *   transition:0.5s linear all;\n * }\n *\n * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/\n * .slide.ng-enter.ng-enter-active { } /&#42; terminal animations for enter &#42;/\n * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/\n * .slide.ng-leave.ng-leave-active { } /&#42; terminal animations for leave &#42;/\n * </style>\n *\n * <!--\n * the animate service will automatically add .ng-enter and .ng-leave to the element\n * to trigger the CSS transition/animations\n * -->\n * <ANY class=\"slide\" ng-include=\"...\"></ANY>\n * ```\n *\n * Keep in mind that, by default, if an animation is running, any child elements cannot be animated\n * until the parent element's animation has completed. This blocking feature can be overridden by\n * placing the `ng-animate-children` attribute on a parent container tag.\n *\n * ```html\n * <div class=\"slide-animation\" ng-if=\"on\" ng-animate-children>\n *   <div class=\"fade-animation\" ng-if=\"on\">\n *     <div class=\"explode-animation\" ng-if=\"on\">\n *        ...\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * When the `on` expression value changes and an animation is triggered then each of the elements within\n * will all animate without the block being applied to child elements.\n *\n * ## Are animations run when the application starts?\n * No they are not. When an application is bootstrapped Angular will disable animations from running to avoid\n * a frenzy of animations from being triggered as soon as the browser has rendered the screen. For this to work,\n * Angular will wait for two digest cycles until enabling animations. From there on, any animation-triggering\n * layout changes in the application will trigger animations as normal.\n *\n * In addition, upon bootstrap, if the routing system or any directives or load remote data (via $http) then Angular\n * will automatically extend the wait time to enable animations once **all** of the outbound HTTP requests\n * are complete.\n *\n * ## CSS-defined Animations\n * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes\n * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported\n * and can be used to play along with this naming structure.\n *\n * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:\n *\n * ```html\n * <style type=\"text/css\">\n * /&#42;\n *  The animate class is apart of the element and the ng-enter class\n *  is attached to the element once the enter animation event is triggered\n * &#42;/\n * .reveal-animation.ng-enter {\n *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/\n *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/\n *\n *  /&#42; The animation preparation code &#42;/\n *  opacity: 0;\n * }\n *\n * /&#42;\n *  Keep in mind that you want to combine both CSS\n *  classes together to avoid any CSS-specificity\n *  conflicts\n * &#42;/\n * .reveal-animation.ng-enter.ng-enter-active {\n *  /&#42; The animation code itself &#42;/\n *  opacity: 1;\n * }\n * </style>\n *\n * <div class=\"view-container\">\n *   <div ng-view class=\"reveal-animation\"></div>\n * </div>\n * ```\n *\n * The following code below demonstrates how to perform animations using **CSS animations** with Angular:\n *\n * ```html\n * <style type=\"text/css\">\n * .reveal-animation.ng-enter {\n *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/\n *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/\n * }\n * @-webkit-keyframes enter_sequence {\n *   from { opacity:0; }\n *   to { opacity:1; }\n * }\n * @keyframes enter_sequence {\n *   from { opacity:0; }\n *   to { opacity:1; }\n * }\n * </style>\n *\n * <div class=\"view-container\">\n *   <div ng-view class=\"reveal-animation\"></div>\n * </div>\n * ```\n *\n * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.\n *\n * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add\n * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically\n * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be\n * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end\n * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element\n * has no CSS transition/animation classes applied to it.\n *\n * ### Structural transition animations\n *\n * Structural transitions (such as enter, leave and move) will always apply a `0s none` transition\n * value to force the browser into rendering the styles defined in the setup (`.ng-enter`, `.ng-leave`\n * or `.ng-move`) class. This means that any active transition animations operating on the element\n * will be cut off to make way for the enter, leave or move animation.\n *\n * ### Class-based transition animations\n *\n * Class-based transitions refer to transition animations that are triggered when a CSS class is\n * added to or removed from the element (via `$animate.addClass`, `$animate.removeClass`,\n * `$animate.setClass`, or by directives such as `ngClass`, `ngModel` and `form`).\n * They are different when compared to structural animations since they **do not cancel existing\n * animations** nor do they **block successive transitions** from rendering on the same element.\n * This distinction allows for **multiple class-based transitions** to be performed on the same element.\n *\n * In addition to ngAnimate supporting the default (natural) functionality of class-based transition\n * animations, ngAnimate also decorates the element with starting and ending CSS classes to aid the\n * developer in further styling the element throughout the transition animation. Earlier versions\n * of ngAnimate may have caused natural CSS transitions to break and not render properly due to\n * $animate temporarily blocking transitions using `0s none` in order to allow the setup CSS class\n * (the `-add` or `-remove` class) to be applied without triggering an animation. However, as of\n * **version 1.3**, this workaround has been removed with ngAnimate and all non-ngAnimate CSS\n * class transitions are compatible with ngAnimate.\n *\n * There is, however, one special case when dealing with class-based transitions in ngAnimate.\n * When rendering class-based transitions that make use of the setup and active CSS classes\n * (e.g. `.fade-add` and `.fade-add-active` for when `.fade` is added) be sure to define\n * the transition value **on the active CSS class** and not the setup class.\n *\n * ```css\n * .fade-add {\n *   /&#42; remember to place a 0s transition here\n *      to ensure that the styles are applied instantly\n *      even if the element already has a transition style &#42;/\n *   transition:0s linear all;\n *\n *   /&#42; starting CSS styles &#42;/\n *   opacity:1;\n * }\n * .fade-add.fade-add-active {\n *   /&#42; this will be the length of the animation &#42;/\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * The setup CSS class (in this case `.fade-add`) also has a transition style property, however, it\n * has a duration of zero. This may not be required, however, incase the browser is unable to render\n * the styling present in this CSS class instantly then it could be that the browser is attempting\n * to perform an unnecessary transition.\n *\n * This workaround, however, does not apply to  standard class-based transitions that are rendered\n * when a CSS class containing a transition is applied to an element:\n *\n * ```css\n * /&#42; this works as expected &#42;/\n * .fade {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * Please keep this in mind when coding the CSS markup that will be used within class-based transitions.\n * Also, try not to mix the two class-based animation flavors together since the CSS code may become\n * overly complex.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n * </div>\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   -webkit-transition: 1s linear all;\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   -webkit-transition-delay: 0.1s;\n *   transition-delay: 0.1s;\n *\n *   /&#42; in case the stagger doesn't work then these two values\n *    must be set to 0 to avoid an accidental CSS inheritance &#42;/\n *   -webkit-transition-duration: 0s;\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if more than 10ms has passed after the last animation has been fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * $timeout(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n * }, 100, false);\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ## JavaScript-defined Animations\n * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not\n * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.\n *\n * ```js\n * //!annotate=\"YourApp\" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.\n * var ngModule = angular.module('YourApp', ['ngAnimate']);\n * ngModule.animation('.my-crazy-animation', function() {\n *   return {\n *     enter: function(element, done) {\n *       //run the animation here and call done when the animation is complete\n *       return function(cancelled) {\n *         //this (optional) function will be called when the animation\n *         //completes or when the animation is cancelled (the cancelled\n *         //flag will be set to true if cancelled).\n *       };\n *     },\n *     leave: function(element, done) { },\n *     move: function(element, done) { },\n *\n *     //animation that can be triggered before the class is added\n *     beforeAddClass: function(element, className, done) { },\n *\n *     //animation that can be triggered after the class is added\n *     addClass: function(element, className, done) { },\n *\n *     //animation that can be triggered before the class is removed\n *     beforeRemoveClass: function(element, className, done) { },\n *\n *     //animation that can be triggered after the class is removed\n *     removeClass: function(element, className, done) { }\n *   };\n * });\n * ```\n *\n * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run\n * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits\n * the element's CSS class attribute value and then run the matching animation event function (if found).\n * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will\n * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).\n *\n * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.\n * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,\n * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation\n * or transition code that is defined via a stylesheet).\n *\n *\n * ### Applying Directive-specific Styles to an Animation\n * In some cases a directive or service may want to provide `$animate` with extra details that the animation will\n * include into its animation. Let's say for example we wanted to render an animation that animates an element\n * towards the mouse coordinates as to where the user clicked last. By collecting the X/Y coordinates of the click\n * (via the event parameter) we can set the `top` and `left` styles into an object and pass that into our function\n * call to `$animate.addClass`.\n *\n * ```js\n * canvas.on('click', function(e) {\n *   $animate.addClass(element, 'on', {\n *     to: {\n *       left : e.client.x + 'px',\n *       top : e.client.y + 'px'\n *     }\n *   }):\n * });\n * ```\n *\n * Now when the animation runs, and a transition or keyframe animation is picked up, then the animation itself will\n * also include and transition the styling of the `left` and `top` properties into its running animation. If we want\n * to provide some starting animation values then we can do so by placing the starting animations styles into an object\n * called `from` in the same object as the `to` animations.\n *\n * ```js\n * canvas.on('click', function(e) {\n *   $animate.addClass(element, 'on', {\n *     from: {\n *        position: 'absolute',\n *        left: '0px',\n *        top: '0px'\n *     },\n *     to: {\n *       left : e.client.x + 'px',\n *       top : e.client.y + 'px'\n *     }\n *   }):\n * });\n * ```\n *\n * Once the animation is complete or cancelled then the union of both the before and after styles are applied to the\n * element. If `ngAnimate` is not present then the styles will be applied immediately.\n *\n */\n\nangular.module('ngAnimate', ['ng'])\n\n  /**\n   * @ngdoc provider\n   * @name $animateProvider\n   * @description\n   *\n   * The `$animateProvider` allows developers to register JavaScript animation event handlers directly inside of a module.\n   * When an animation is triggered, the $animate service will query the $animate service to find any animations that match\n   * the provided name value.\n   *\n   * Requires the {@link ngAnimate `ngAnimate`} module to be installed.\n   *\n   * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.\n   *\n   */\n  .directive('ngAnimateChildren', function() {\n    var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';\n    return function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (angular.isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN, true);\n      } else {\n        scope.$watch(val, function(value) {\n          element.data(NG_ANIMATE_CHILDREN, !!value);\n        });\n      }\n    };\n  })\n\n  //this private service is only used within CSS-enabled animations\n  //IE8 + IE9 do not support rAF natively, but that is fine since they\n  //also don't support transitions and keyframes which means that the code\n  //below will never be used by the two browsers.\n  .factory('$$animateReflow', ['$$rAF', '$document', function($$rAF, $document) {\n    var bod = $document[0].body;\n    return function(fn) {\n      //the returned function acts as the cancellation function\n      return $$rAF(function() {\n        //the line below will force the browser to perform a repaint\n        //so that all the animated elements within the animation frame\n        //will be properly updated and drawn on screen. This is\n        //required to perform multi-class CSS based animations with\n        //Firefox. DO NOT REMOVE THIS LINE.\n        var a = bod.offsetWidth + 1;\n        fn();\n      });\n    };\n  }])\n\n  .config(['$provide', '$animateProvider', function($provide, $animateProvider) {\n    var noop = angular.noop;\n    var forEach = angular.forEach;\n    var selectors = $animateProvider.$$selectors;\n    var isArray = angular.isArray;\n    var isString = angular.isString;\n    var isObject = angular.isObject;\n\n    var ELEMENT_NODE = 1;\n    var NG_ANIMATE_STATE = '$$ngAnimateState';\n    var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';\n    var NG_ANIMATE_CLASS_NAME = 'ng-animate';\n    var rootAnimateState = {running: true};\n\n    function extractElementNode(element) {\n      for (var i = 0; i < element.length; i++) {\n        var elm = element[i];\n        if (elm.nodeType == ELEMENT_NODE) {\n          return elm;\n        }\n      }\n    }\n\n    function prepareElement(element) {\n      return element && angular.element(element);\n    }\n\n    function stripCommentsFromElement(element) {\n      return angular.element(extractElementNode(element));\n    }\n\n    function isMatchingElement(elm1, elm2) {\n      return extractElementNode(elm1) == extractElementNode(elm2);\n    }\n    var $$jqLite;\n    $provide.decorator('$animate',\n        ['$delegate', '$$q', '$injector', '$sniffer', '$rootElement', '$$asyncCallback', '$rootScope', '$document', '$templateRequest', '$$jqLite',\n function($delegate,   $$q,   $injector,   $sniffer,   $rootElement,   $$asyncCallback,   $rootScope,   $document,   $templateRequest,   $$$jqLite) {\n\n      $$jqLite = $$$jqLite;\n      $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);\n\n      // Wait until all directive and route-related templates are downloaded and\n      // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n      // all of the remote templates being currently downloaded. If there are no\n      // templates currently downloading then the watcher will still fire anyway.\n      var deregisterWatch = $rootScope.$watch(\n        function() { return $templateRequest.totalPendingRequests; },\n        function(val, oldVal) {\n          if (val !== 0) return;\n          deregisterWatch();\n\n          // Now that all templates have been downloaded, $animate will wait until\n          // the post digest queue is empty before enabling animations. By having two\n          // calls to $postDigest calls we can ensure that the flag is enabled at the\n          // very end of the post digest queue. Since all of the animations in $animate\n          // use $postDigest, it's important that the code below executes at the end.\n          // This basically means that the page is fully downloaded and compiled before\n          // any animations are triggered.\n          $rootScope.$$postDigest(function() {\n            $rootScope.$$postDigest(function() {\n              rootAnimateState.running = false;\n            });\n          });\n        }\n      );\n\n      var globalAnimationCounter = 0;\n      var classNameFilter = $animateProvider.classNameFilter();\n      var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n      function classBasedAnimationsBlocked(element, setter) {\n        var data = element.data(NG_ANIMATE_STATE) || {};\n        if (setter) {\n          data.running = true;\n          data.structural = true;\n          element.data(NG_ANIMATE_STATE, data);\n        }\n        return data.disabled || (data.running && data.structural);\n      }\n\n      function runAnimationPostDigest(fn) {\n        var cancelFn, defer = $$q.defer();\n        defer.promise.$$cancelFn = function() {\n          cancelFn && cancelFn();\n        };\n        $rootScope.$$postDigest(function() {\n          cancelFn = fn(function() {\n            defer.resolve();\n          });\n        });\n        return defer.promise;\n      }\n\n      function parseAnimateOptions(options) {\n        // some plugin code may still be passing in the callback\n        // function as the last param for the $animate methods so\n        // it's best to only allow string or array values for now\n        if (isObject(options)) {\n          if (options.tempClasses && isString(options.tempClasses)) {\n            options.tempClasses = options.tempClasses.split(/\\s+/);\n          }\n          return options;\n        }\n      }\n\n      function resolveElementClasses(element, cache, runningAnimations) {\n        runningAnimations = runningAnimations || {};\n\n        var lookup = {};\n        forEach(runningAnimations, function(data, selector) {\n          forEach(selector.split(' '), function(s) {\n            lookup[s]=data;\n          });\n        });\n\n        var hasClasses = Object.create(null);\n        forEach((element.attr('class') || '').split(/\\s+/), function(className) {\n          hasClasses[className] = true;\n        });\n\n        var toAdd = [], toRemove = [];\n        forEach((cache && cache.classes) || [], function(status, className) {\n          var hasClass = hasClasses[className];\n          var matchingAnimation = lookup[className] || {};\n\n          // When addClass and removeClass is called then $animate will check to\n          // see if addClass and removeClass cancel each other out. When there are\n          // more calls to removeClass than addClass then the count falls below 0\n          // and then the removeClass animation will be allowed. Otherwise if the\n          // count is above 0 then that means an addClass animation will commence.\n          // Once an animation is allowed then the code will also check to see if\n          // there exists any on-going animation that is already adding or remvoing\n          // the matching CSS class.\n          if (status === false) {\n            //does it have the class or will it have the class\n            if (hasClass || matchingAnimation.event == 'addClass') {\n              toRemove.push(className);\n            }\n          } else if (status === true) {\n            //is the class missing or will it be removed?\n            if (!hasClass || matchingAnimation.event == 'removeClass') {\n              toAdd.push(className);\n            }\n          }\n        });\n\n        return (toAdd.length + toRemove.length) > 0 && [toAdd.join(' '), toRemove.join(' ')];\n      }\n\n      function lookup(name) {\n        if (name) {\n          var matches = [],\n              flagMap = {},\n              classes = name.substr(1).split('.');\n\n          //the empty string value is the default animation\n          //operation which performs CSS transition and keyframe\n          //animations sniffing. This is always included for each\n          //element animation procedure if the browser supports\n          //transitions and/or keyframe animations. The default\n          //animation is added to the top of the list to prevent\n          //any previous animations from affecting the element styling\n          //prior to the element being animated.\n          if ($sniffer.transitions || $sniffer.animations) {\n            matches.push($injector.get(selectors['']));\n          }\n\n          for (var i=0; i < classes.length; i++) {\n            var klass = classes[i],\n                selectorFactoryName = selectors[klass];\n            if (selectorFactoryName && !flagMap[klass]) {\n              matches.push($injector.get(selectorFactoryName));\n              flagMap[klass] = true;\n            }\n          }\n          return matches;\n        }\n      }\n\n      function animationRunner(element, animationEvent, className, options) {\n        //transcluded directives may sometimes fire an animation using only comment nodes\n        //best to catch this early on to prevent any animation operations from occurring\n        var node = element[0];\n        if (!node) {\n          return;\n        }\n\n        if (options) {\n          options.to = options.to || {};\n          options.from = options.from || {};\n        }\n\n        var classNameAdd;\n        var classNameRemove;\n        if (isArray(className)) {\n          classNameAdd = className[0];\n          classNameRemove = className[1];\n          if (!classNameAdd) {\n            className = classNameRemove;\n            animationEvent = 'removeClass';\n          } else if (!classNameRemove) {\n            className = classNameAdd;\n            animationEvent = 'addClass';\n          } else {\n            className = classNameAdd + ' ' + classNameRemove;\n          }\n        }\n\n        var isSetClassOperation = animationEvent == 'setClass';\n        var isClassBased = isSetClassOperation\n                           || animationEvent == 'addClass'\n                           || animationEvent == 'removeClass'\n                           || animationEvent == 'animate';\n\n        var currentClassName = element.attr('class');\n        var classes = currentClassName + ' ' + className;\n        if (!isAnimatableClassName(classes)) {\n          return;\n        }\n\n        var beforeComplete = noop,\n            beforeCancel = [],\n            before = [],\n            afterComplete = noop,\n            afterCancel = [],\n            after = [];\n\n        var animationLookup = (' ' + classes).replace(/\\s+/g,'.');\n        forEach(lookup(animationLookup), function(animationFactory) {\n          var created = registerAnimation(animationFactory, animationEvent);\n          if (!created && isSetClassOperation) {\n            registerAnimation(animationFactory, 'addClass');\n            registerAnimation(animationFactory, 'removeClass');\n          }\n        });\n\n        function registerAnimation(animationFactory, event) {\n          var afterFn = animationFactory[event];\n          var beforeFn = animationFactory['before' + event.charAt(0).toUpperCase() + event.substr(1)];\n          if (afterFn || beforeFn) {\n            if (event == 'leave') {\n              beforeFn = afterFn;\n              //when set as null then animation knows to skip this phase\n              afterFn = null;\n            }\n            after.push({\n              event: event, fn: afterFn\n            });\n            before.push({\n              event: event, fn: beforeFn\n            });\n            return true;\n          }\n        }\n\n        function run(fns, cancellations, allCompleteFn) {\n          var animations = [];\n          forEach(fns, function(animation) {\n            animation.fn && animations.push(animation);\n          });\n\n          var count = 0;\n          function afterAnimationComplete(index) {\n            if (cancellations) {\n              (cancellations[index] || noop)();\n              if (++count < animations.length) return;\n              cancellations = null;\n            }\n            allCompleteFn();\n          }\n\n          //The code below adds directly to the array in order to work with\n          //both sync and async animations. Sync animations are when the done()\n          //operation is called right away. DO NOT REFACTOR!\n          forEach(animations, function(animation, index) {\n            var progress = function() {\n              afterAnimationComplete(index);\n            };\n            switch (animation.event) {\n              case 'setClass':\n                cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));\n                break;\n              case 'animate':\n                cancellations.push(animation.fn(element, className, options.from, options.to, progress));\n                break;\n              case 'addClass':\n                cancellations.push(animation.fn(element, classNameAdd || className,     progress, options));\n                break;\n              case 'removeClass':\n                cancellations.push(animation.fn(element, classNameRemove || className,  progress, options));\n                break;\n              default:\n                cancellations.push(animation.fn(element, progress, options));\n                break;\n            }\n          });\n\n          if (cancellations && cancellations.length === 0) {\n            allCompleteFn();\n          }\n        }\n\n        return {\n          node: node,\n          event: animationEvent,\n          className: className,\n          isClassBased: isClassBased,\n          isSetClassOperation: isSetClassOperation,\n          applyStyles: function() {\n            if (options) {\n              element.css(angular.extend(options.from || {}, options.to || {}));\n            }\n          },\n          before: function(allCompleteFn) {\n            beforeComplete = allCompleteFn;\n            run(before, beforeCancel, function() {\n              beforeComplete = noop;\n              allCompleteFn();\n            });\n          },\n          after: function(allCompleteFn) {\n            afterComplete = allCompleteFn;\n            run(after, afterCancel, function() {\n              afterComplete = noop;\n              allCompleteFn();\n            });\n          },\n          cancel: function() {\n            if (beforeCancel) {\n              forEach(beforeCancel, function(cancelFn) {\n                (cancelFn || noop)(true);\n              });\n              beforeComplete(true);\n            }\n            if (afterCancel) {\n              forEach(afterCancel, function(cancelFn) {\n                (cancelFn || noop)(true);\n              });\n              afterComplete(true);\n            }\n          }\n        };\n      }\n\n      /**\n       * @ngdoc service\n       * @name $animate\n       * @kind object\n       *\n       * @description\n       * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.\n       * When any of these operations are run, the $animate service\n       * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)\n       * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.\n       *\n       * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives\n       * will work out of the box without any extra configuration.\n       *\n       * Requires the {@link ngAnimate `ngAnimate`} module to be installed.\n       *\n       * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.\n       * ## Callback Promises\n       * With AngularJS 1.3, each of the animation methods, on the `$animate` service, return a promise when called. The\n       * promise itself is then resolved once the animation has completed itself, has been cancelled or has been\n       * skipped due to animations being disabled. (Note that even if the animation is cancelled it will still\n       * call the resolve function of the animation.)\n       *\n       * ```js\n       * $animate.enter(element, container).then(function() {\n       *   //...this is called once the animation is complete...\n       * });\n       * ```\n       *\n       * Also note that, due to the nature of the callback promise, if any Angular-specific code (like changing the scope,\n       * location of the page, etc...) is executed within the callback promise then be sure to wrap the code using\n       * `$scope.$apply(...)`;\n       *\n       * ```js\n       * $animate.leave(element).then(function() {\n       *   $scope.$apply(function() {\n       *     $location.path('/new-page');\n       *   });\n       * });\n       * ```\n       *\n       * An animation can also be cancelled by calling the `$animate.cancel(promise)` method with the provided\n       * promise that was returned when the animation was started.\n       *\n       * ```js\n       * var promise = $animate.addClass(element, 'super-long-animation');\n       * promise.then(function() {\n       *   //this will still be called even if cancelled\n       * });\n       *\n       * element.on('click', function() {\n       *   //tooo lazy to wait for the animation to end\n       *   $animate.cancel(promise);\n       * });\n       * ```\n       *\n       * (Keep in mind that the promise cancellation is unique to `$animate` since promises in\n       * general cannot be cancelled.)\n       *\n       */\n      return {\n        /**\n         * @ngdoc method\n         * @name $animate#animate\n         * @kind function\n         *\n         * @description\n         * Performs an inline animation on the element which applies the provided `to` and `from` CSS styles to the element.\n         * If any detected CSS transition, keyframe or JavaScript matches the provided `className` value then the animation\n         * will take on the provided styles. For example, if a transition animation is set for the given className then the\n         * provided `from` and `to` styles will be applied alongside the given transition. If a JavaScript animation is\n         * detected then the provided styles will be given in as function paramters.\n         *\n         * ```js\n         * ngModule.animation('.my-inline-animation', function() {\n         *   return {\n         *     animate : function(element, className, from, to, done) {\n         *       //styles\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * Below is a breakdown of each step that occurs during the `animate` animation:\n         *\n         * | Animation Step                                                                                                        | What the element class attribute looks like                  |\n         * |-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------|\n         * | 1. `$animate.animate(...)` is called                                                                                  | `class=\"my-animation\"`                                       |\n         * | 2. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                            |\n         * | 3. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                            |\n         * | 4. the `className` class value is added to the element                                                                | `class=\"my-animation ng-animate className\"`                  |\n         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate className\"`                  |\n         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.className` class styling is applied right away| `class=\"my-animation ng-animate className\"`                  |\n         * | 7. `$animate` applies the provided collection of `from` CSS styles to the element                                     | `class=\"my-animation ng-animate className\"`                  |\n         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate className\"`                  |\n         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate className\"`                  |\n         * | 10. the `className-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate className className-active\"` |\n         * | 11. `$animate` applies the collection of `to` CSS styles to the element which are then handled by the transition      | `class=\"my-animation ng-animate className className-active\"` |\n         * | 12. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate className className-active\"` |\n         * | 13. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                       |\n         * | 14. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                       |\n         *\n         * @param {DOMElement} element the element that will be the focus of the enter animation\n         * @param {object} from a collection of CSS styles that will be applied to the element at the start of the animation\n         * @param {object} to a collection of CSS styles that the element will animate towards\n         * @param {string=} className an optional CSS class that will be added to the element for the duration of the animation (the default class is `ng-inline-animate`)\n         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        animate: function(element, from, to, className, options) {\n          className = className || 'ng-inline-animate';\n          options = parseAnimateOptions(options) || {};\n          options.from = to ? from : null;\n          options.to   = to ? to : from;\n\n          return runAnimationPostDigest(function(done) {\n            return performAnimation('animate', className, stripCommentsFromElement(element), null, null, noop, options, done);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#enter\n         * @kind function\n         *\n         * @description\n         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once\n         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:\n         *\n         * Below is a breakdown of each step that occurs during enter animation:\n         *\n         * | Animation Step                                                                                                        | What the element class attribute looks like                |\n         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|\n         * | 1. `$animate.enter(...)` is called                                                                                    | `class=\"my-animation\"`                                     |\n         * | 2. element is inserted into the `parentElement` element or beside the `afterElement` element                          | `class=\"my-animation\"`                                     |\n         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                          |\n         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                          |\n         * | 5. the `.ng-enter` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-enter\"`                 |\n         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate ng-enter\"`                 |\n         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-enter` class styling is applied right away | `class=\"my-animation ng-animate ng-enter\"`                 |\n         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate ng-enter\"`                 |\n         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate ng-enter\"`                 |\n         * | 10. the `.ng-enter-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate ng-enter ng-enter-active\"` |\n         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate ng-enter ng-enter-active\"` |\n         * | 12. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                     |\n         * | 13. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                     |\n         *\n         * @param {DOMElement} element the element that will be the focus of the enter animation\n         * @param {DOMElement} parentElement the parent element of the element that will be the focus of the enter animation\n         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation\n         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        enter: function(element, parentElement, afterElement, options) {\n          options = parseAnimateOptions(options);\n          element = angular.element(element);\n          parentElement = prepareElement(parentElement);\n          afterElement = prepareElement(afterElement);\n\n          classBasedAnimationsBlocked(element, true);\n          $delegate.enter(element, parentElement, afterElement);\n          return runAnimationPostDigest(function(done) {\n            return performAnimation('enter', 'ng-enter', stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#leave\n         * @kind function\n         *\n         * @description\n         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once\n         * the animation is started, the following CSS classes will be added for the duration of the animation:\n         *\n         * Below is a breakdown of each step that occurs during leave animation:\n         *\n         * | Animation Step                                                                                                        | What the element class attribute looks like                |\n         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|\n         * | 1. `$animate.leave(...)` is called                                                                                    | `class=\"my-animation\"`                                     |\n         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class=\"my-animation ng-animate\"`                          |\n         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class=\"my-animation ng-animate\"`                          |\n         * | 4. the `.ng-leave` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-leave\"`                 |\n         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class=\"my-animation ng-animate ng-leave\"`                 |\n         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.ng-leave` class styling is applied right away | `class=\"my-animation ng-animate ng-leave\"`                 |\n         * | 7. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class=\"my-animation ng-animate ng-leave\"`                 |\n         * | 8. `$animate` removes the CSS transition block placed on the element                                                  | `class=\"my-animation ng-animate ng-leave\"`                 |\n         * | 9. the `.ng-leave-active` class is added (this triggers the CSS transition/animation)                                 | `class=\"my-animation ng-animate ng-leave ng-leave-active\"` |\n         * | 10. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate ng-leave ng-leave-active\"` |\n         * | 11. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                     |\n         * | 12. The element is removed from the DOM                                                                               | ...                                                        |\n         * | 13. The returned promise is resolved.                                                                                 | ...                                                        |\n         *\n         * @param {DOMElement} element the element that will be the focus of the leave animation\n         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        leave: function(element, options) {\n          options = parseAnimateOptions(options);\n          element = angular.element(element);\n\n          cancelChildAnimations(element);\n          classBasedAnimationsBlocked(element, true);\n          return runAnimationPostDigest(function(done) {\n            return performAnimation('leave', 'ng-leave', stripCommentsFromElement(element), null, null, function() {\n              $delegate.leave(element);\n            }, options, done);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#move\n         * @kind function\n         *\n         * @description\n         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or\n         * add the element directly after the afterElement element if present. Then the move animation will be run. Once\n         * the animation is started, the following CSS classes will be added for the duration of the animation:\n         *\n         * Below is a breakdown of each step that occurs during move animation:\n         *\n         * | Animation Step                                                                                                       | What the element class attribute looks like              |\n         * |----------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|\n         * | 1. `$animate.move(...)` is called                                                                                    | `class=\"my-animation\"`                                   |\n         * | 2. element is moved into the parentElement element or beside the afterElement element                                | `class=\"my-animation\"`                                   |\n         * | 3. `$animate` waits for the next digest to start the animation                                                       | `class=\"my-animation ng-animate\"`                        |\n         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class=\"my-animation ng-animate\"`                        |\n         * | 5. the `.ng-move` class is added to the element                                                                      | `class=\"my-animation ng-animate ng-move\"`                |\n         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class=\"my-animation ng-animate ng-move\"`                |\n         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-move` class styling is applied right away | `class=\"my-animation ng-animate ng-move\"`                |\n         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class=\"my-animation ng-animate ng-move\"`                |\n         * | 9. `$animate` removes the CSS transition block placed on the element                                                 | `class=\"my-animation ng-animate ng-move\"`                |\n         * | 10. the `.ng-move-active` class is added (this triggers the CSS transition/animation)                                | `class=\"my-animation ng-animate ng-move ng-move-active\"` |\n         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                          | `class=\"my-animation ng-animate ng-move ng-move-active\"` |\n         * | 12. The animation ends and all generated CSS classes are removed from the element                                    | `class=\"my-animation\"`                                   |\n         * | 13. The returned promise is resolved.                                                                                | `class=\"my-animation\"`                                   |\n         *\n         * @param {DOMElement} element the element that will be the focus of the move animation\n         * @param {DOMElement} parentElement the parentElement element of the element that will be the focus of the move animation\n         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation\n         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        move: function(element, parentElement, afterElement, options) {\n          options = parseAnimateOptions(options);\n          element = angular.element(element);\n          parentElement = prepareElement(parentElement);\n          afterElement = prepareElement(afterElement);\n\n          cancelChildAnimations(element);\n          classBasedAnimationsBlocked(element, true);\n          $delegate.move(element, parentElement, afterElement);\n          return runAnimationPostDigest(function(done) {\n            return performAnimation('move', 'ng-move', stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#addClass\n         *\n         * @description\n         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.\n         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide\n         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions\n         * or keyframes are defined on the -add-active or base CSS class).\n         *\n         * Below is a breakdown of each step that occurs during addClass animation:\n         *\n         * | Animation Step                                                                                         | What the element class attribute looks like                        |\n         * |--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n         * | 1. `$animate.addClass(element, 'super')` is called                                                     | `class=\"my-animation\"`                                             |\n         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                           | `class=\"my-animation ng-animate\"`                                  |\n         * | 3. the `.super-add` class is added to the element                                                      | `class=\"my-animation ng-animate super-add\"`                        |\n         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                              | `class=\"my-animation ng-animate super-add\"`                        |\n         * | 5. the `.super` and `.super-add-active` classes are added (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay          | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n         * | 7. `$animate` waits for the animation to complete (via events and timeout)                             | `class=\"my-animation ng-animate super super-add super-add-active\"` |\n         * | 8. The animation ends and all generated CSS classes are removed from the element                       | `class=\"my-animation super\"`                                       |\n         * | 9. The super class is kept on the element                                                              | `class=\"my-animation super\"`                                       |\n         * | 10. The returned promise is resolved.                                                                  | `class=\"my-animation super\"`                                       |\n         *\n         * @param {DOMElement} element the element that will be animated\n         * @param {string} className the CSS class that will be added to the element and then animated\n         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        addClass: function(element, className, options) {\n          return this.setClass(element, className, [], options);\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#removeClass\n         *\n         * @description\n         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value\n         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in\n         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if\n         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).\n         *\n         * Below is a breakdown of each step that occurs during removeClass animation:\n         *\n         * | Animation Step                                                                                                       | What the element class attribute looks like                        |\n         * |----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|\n         * | 1. `$animate.removeClass(element, 'super')` is called                                                                | `class=\"my-animation super\"`                                       |\n         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class=\"my-animation super ng-animate\"`                            |\n         * | 3. the `.super-remove` class is added to the element                                                                 | `class=\"my-animation super ng-animate super-remove\"`               |\n         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class=\"my-animation super ng-animate super-remove\"`               |\n         * | 5. the `.super-remove-active` classes are added and `.super` is removed (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                           | `class=\"my-animation ng-animate super-remove super-remove-active\"` |\n         * | 8. The animation ends and all generated CSS classes are removed from the element                                     | `class=\"my-animation\"`                                             |\n         * | 9. The returned promise is resolved.                                                                                 | `class=\"my-animation\"`                                             |\n         *\n         *\n         * @param {DOMElement} element the element that will be animated\n         * @param {string} className the CSS class that will be animated and then removed from the element\n         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n        */\n        removeClass: function(element, className, options) {\n          return this.setClass(element, [], className, options);\n        },\n\n        /**\n         *\n         * @ngdoc method\n         * @name $animate#setClass\n         *\n         * @description Adds and/or removes the given CSS classes to and from the element.\n         * Once complete, the `done()` callback will be fired (if provided).\n         *\n         * | Animation Step                                                                                                                               | What the element class attribute looks like                                            |\n         * |----------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|\n         * | 1. `$animate.setClass(element, 'on', 'off')` is called                                                                                       | `class=\"my-animation off\"`                                                             |\n         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                                                 | `class=\"my-animation ng-animate off\"`                                                  |\n         * | 3. the `.on-add` and `.off-remove` classes are added to the element                                                                          | `class=\"my-animation ng-animate on-add off-remove off\"`                                |\n         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                                                    | `class=\"my-animation ng-animate on-add off-remove off\"`                                |\n         * | 5. the `.on`, `.on-add-active` and `.off-remove-active` classes are added and `.off` is removed (this triggers the CSS transition/animation) | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                                                | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                                                   | `class=\"my-animation ng-animate on on-add on-add-active off-remove off-remove-active\"` |\n         * | 8. The animation ends and all generated CSS classes are removed from the element                                                             | `class=\"my-animation on\"`                                                              |\n         * | 9. The returned promise is resolved.                                                                                                         | `class=\"my-animation on\"`                                                              |\n         *\n         * @param {DOMElement} element the element which will have its CSS classes changed\n         *   removed from it\n         * @param {string} add the CSS classes which will be added to the element\n         * @param {string} remove the CSS class which will be removed from the element\n         *   CSS classes have been set on the element\n         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation\n         * @return {Promise} the animation callback promise\n         */\n        setClass: function(element, add, remove, options) {\n          options = parseAnimateOptions(options);\n\n          var STORAGE_KEY = '$$animateClasses';\n          element = angular.element(element);\n          element = stripCommentsFromElement(element);\n\n          if (classBasedAnimationsBlocked(element)) {\n            return $delegate.$$setClassImmediately(element, add, remove, options);\n          }\n\n          // we're using a combined array for both the add and remove\n          // operations since the ORDER OF addClass and removeClass matters\n          var classes, cache = element.data(STORAGE_KEY);\n          var hasCache = !!cache;\n          if (!cache) {\n            cache = {};\n            cache.classes = {};\n          }\n          classes = cache.classes;\n\n          add = isArray(add) ? add : add.split(' ');\n          forEach(add, function(c) {\n            if (c && c.length) {\n              classes[c] = true;\n            }\n          });\n\n          remove = isArray(remove) ? remove : remove.split(' ');\n          forEach(remove, function(c) {\n            if (c && c.length) {\n              classes[c] = false;\n            }\n          });\n\n          if (hasCache) {\n            if (options && cache.options) {\n              cache.options = angular.extend(cache.options || {}, options);\n            }\n\n            //the digest cycle will combine all the animations into one function\n            return cache.promise;\n          } else {\n            element.data(STORAGE_KEY, cache = {\n              classes: classes,\n              options: options\n            });\n          }\n\n          return cache.promise = runAnimationPostDigest(function(done) {\n            var parentElement = element.parent();\n            var elementNode = extractElementNode(element);\n            var parentNode = elementNode.parentNode;\n            // TODO(matsko): move this code into the animationsDisabled() function once #8092 is fixed\n            if (!parentNode || parentNode['$$NG_REMOVED'] || elementNode['$$NG_REMOVED']) {\n              done();\n              return;\n            }\n\n            var cache = element.data(STORAGE_KEY);\n            element.removeData(STORAGE_KEY);\n\n            var state = element.data(NG_ANIMATE_STATE) || {};\n            var classes = resolveElementClasses(element, cache, state.active);\n            return !classes\n              ? done()\n              : performAnimation('setClass', classes, element, parentElement, null, function() {\n                  if (classes[0]) $delegate.$$addClassImmediately(element, classes[0]);\n                  if (classes[1]) $delegate.$$removeClassImmediately(element, classes[1]);\n                }, cache.options, done);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#cancel\n         * @kind function\n         *\n         * @param {Promise} animationPromise The animation promise that is returned when an animation is started.\n         *\n         * @description\n         * Cancels the provided animation.\n        */\n        cancel: function(promise) {\n          promise.$$cancelFn();\n        },\n\n        /**\n         * @ngdoc method\n         * @name $animate#enabled\n         * @kind function\n         *\n         * @param {boolean=} value If provided then set the animation on or off.\n         * @param {DOMElement=} element If provided then the element will be used to represent the enable/disable operation\n         * @return {boolean} Current animation state.\n         *\n         * @description\n         * Globally enables/disables animations.\n         *\n        */\n        enabled: function(value, element) {\n          switch (arguments.length) {\n            case 2:\n              if (value) {\n                cleanup(element);\n              } else {\n                var data = element.data(NG_ANIMATE_STATE) || {};\n                data.disabled = true;\n                element.data(NG_ANIMATE_STATE, data);\n              }\n            break;\n\n            case 1:\n              rootAnimateState.disabled = !value;\n            break;\n\n            default:\n              value = !rootAnimateState.disabled;\n            break;\n          }\n          return !!value;\n         }\n      };\n\n      /*\n        all animations call this shared animation triggering function internally.\n        The animationEvent variable refers to the JavaScript animation event that will be triggered\n        and the className value is the name of the animation that will be applied within the\n        CSS code. Element, `parentElement` and `afterElement` are provided DOM elements for the animation\n        and the onComplete callback will be fired once the animation is fully complete.\n      */\n      function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {\n        var noopCancel = noop;\n        var runner = animationRunner(element, animationEvent, className, options);\n        if (!runner) {\n          fireDOMOperation();\n          fireBeforeCallbackAsync();\n          fireAfterCallbackAsync();\n          closeAnimation();\n          return noopCancel;\n        }\n\n        animationEvent = runner.event;\n        className = runner.className;\n        var elementEvents = angular.element._data(runner.node);\n        elementEvents = elementEvents && elementEvents.events;\n\n        if (!parentElement) {\n          parentElement = afterElement ? afterElement.parent() : element.parent();\n        }\n\n        //skip the animation if animations are disabled, a parent is already being animated,\n        //the element is not currently attached to the document body or then completely close\n        //the animation if any matching animations are not found at all.\n        //NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case an animation was found.\n        if (animationsDisabled(element, parentElement)) {\n          fireDOMOperation();\n          fireBeforeCallbackAsync();\n          fireAfterCallbackAsync();\n          closeAnimation();\n          return noopCancel;\n        }\n\n        var ngAnimateState  = element.data(NG_ANIMATE_STATE) || {};\n        var runningAnimations     = ngAnimateState.active || {};\n        var totalActiveAnimations = ngAnimateState.totalActive || 0;\n        var lastAnimation         = ngAnimateState.last;\n        var skipAnimation = false;\n\n        if (totalActiveAnimations > 0) {\n          var animationsToCancel = [];\n          if (!runner.isClassBased) {\n            if (animationEvent == 'leave' && runningAnimations['ng-leave']) {\n              skipAnimation = true;\n            } else {\n              //cancel all animations when a structural animation takes place\n              for (var klass in runningAnimations) {\n                animationsToCancel.push(runningAnimations[klass]);\n              }\n              ngAnimateState = {};\n              cleanup(element, true);\n            }\n          } else if (lastAnimation.event == 'setClass') {\n            animationsToCancel.push(lastAnimation);\n            cleanup(element, className);\n          } else if (runningAnimations[className]) {\n            var current = runningAnimations[className];\n            if (current.event == animationEvent) {\n              skipAnimation = true;\n            } else {\n              animationsToCancel.push(current);\n              cleanup(element, className);\n            }\n          }\n\n          if (animationsToCancel.length > 0) {\n            forEach(animationsToCancel, function(operation) {\n              operation.cancel();\n            });\n          }\n        }\n\n        if (runner.isClassBased\n            && !runner.isSetClassOperation\n            && animationEvent != 'animate'\n            && !skipAnimation) {\n          skipAnimation = (animationEvent == 'addClass') == element.hasClass(className); //opposite of XOR\n        }\n\n        if (skipAnimation) {\n          fireDOMOperation();\n          fireBeforeCallbackAsync();\n          fireAfterCallbackAsync();\n          fireDoneCallbackAsync();\n          return noopCancel;\n        }\n\n        runningAnimations     = ngAnimateState.active || {};\n        totalActiveAnimations = ngAnimateState.totalActive || 0;\n\n        if (animationEvent == 'leave') {\n          //there's no need to ever remove the listener since the element\n          //will be removed (destroyed) after the leave animation ends or\n          //is cancelled midway\n          element.one('$destroy', function(e) {\n            var element = angular.element(this);\n            var state = element.data(NG_ANIMATE_STATE);\n            if (state) {\n              var activeLeaveAnimation = state.active['ng-leave'];\n              if (activeLeaveAnimation) {\n                activeLeaveAnimation.cancel();\n                cleanup(element, 'ng-leave');\n              }\n            }\n          });\n        }\n\n        //the ng-animate class does nothing, but it's here to allow for\n        //parent animations to find and cancel child animations when needed\n        $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME);\n        if (options && options.tempClasses) {\n          forEach(options.tempClasses, function(className) {\n            $$jqLite.addClass(element, className);\n          });\n        }\n\n        var localAnimationCount = globalAnimationCounter++;\n        totalActiveAnimations++;\n        runningAnimations[className] = runner;\n\n        element.data(NG_ANIMATE_STATE, {\n          last: runner,\n          active: runningAnimations,\n          index: localAnimationCount,\n          totalActive: totalActiveAnimations\n        });\n\n        //first we run the before animations and when all of those are complete\n        //then we perform the DOM operation and run the next set of animations\n        fireBeforeCallbackAsync();\n        runner.before(function(cancelled) {\n          var data = element.data(NG_ANIMATE_STATE);\n          cancelled = cancelled ||\n                        !data || !data.active[className] ||\n                        (runner.isClassBased && data.active[className].event != animationEvent);\n\n          fireDOMOperation();\n          if (cancelled === true) {\n            closeAnimation();\n          } else {\n            fireAfterCallbackAsync();\n            runner.after(closeAnimation);\n          }\n        });\n\n        return runner.cancel;\n\n        function fireDOMCallback(animationPhase) {\n          var eventName = '$animate:' + animationPhase;\n          if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {\n            $$asyncCallback(function() {\n              element.triggerHandler(eventName, {\n                event: animationEvent,\n                className: className\n              });\n            });\n          }\n        }\n\n        function fireBeforeCallbackAsync() {\n          fireDOMCallback('before');\n        }\n\n        function fireAfterCallbackAsync() {\n          fireDOMCallback('after');\n        }\n\n        function fireDoneCallbackAsync() {\n          fireDOMCallback('close');\n          doneCallback();\n        }\n\n        //it is less complicated to use a flag than managing and canceling\n        //timeouts containing multiple callbacks.\n        function fireDOMOperation() {\n          if (!fireDOMOperation.hasBeenRun) {\n            fireDOMOperation.hasBeenRun = true;\n            domOperation();\n          }\n        }\n\n        function closeAnimation() {\n          if (!closeAnimation.hasBeenRun) {\n            if (runner) { //the runner doesn't exist if it fails to instantiate\n              runner.applyStyles();\n            }\n\n            closeAnimation.hasBeenRun = true;\n            if (options && options.tempClasses) {\n              forEach(options.tempClasses, function(className) {\n                $$jqLite.removeClass(element, className);\n              });\n            }\n\n            var data = element.data(NG_ANIMATE_STATE);\n            if (data) {\n\n              /* only structural animations wait for reflow before removing an\n                 animation, but class-based animations don't. An example of this\n                 failing would be when a parent HTML tag has a ng-class attribute\n                 causing ALL directives below to skip animations during the digest */\n              if (runner && runner.isClassBased) {\n                cleanup(element, className);\n              } else {\n                $$asyncCallback(function() {\n                  var data = element.data(NG_ANIMATE_STATE) || {};\n                  if (localAnimationCount == data.index) {\n                    cleanup(element, className, animationEvent);\n                  }\n                });\n                element.data(NG_ANIMATE_STATE, data);\n              }\n            }\n            fireDoneCallbackAsync();\n          }\n        }\n      }\n\n      function cancelChildAnimations(element) {\n        var node = extractElementNode(element);\n        if (node) {\n          var nodes = angular.isFunction(node.getElementsByClassName) ?\n            node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) :\n            node.querySelectorAll('.' + NG_ANIMATE_CLASS_NAME);\n          forEach(nodes, function(element) {\n            element = angular.element(element);\n            var data = element.data(NG_ANIMATE_STATE);\n            if (data && data.active) {\n              forEach(data.active, function(runner) {\n                runner.cancel();\n              });\n            }\n          });\n        }\n      }\n\n      function cleanup(element, className) {\n        if (isMatchingElement(element, $rootElement)) {\n          if (!rootAnimateState.disabled) {\n            rootAnimateState.running = false;\n            rootAnimateState.structural = false;\n          }\n        } else if (className) {\n          var data = element.data(NG_ANIMATE_STATE) || {};\n\n          var removeAnimations = className === true;\n          if (!removeAnimations && data.active && data.active[className]) {\n            data.totalActive--;\n            delete data.active[className];\n          }\n\n          if (removeAnimations || !data.totalActive) {\n            $$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME);\n            element.removeData(NG_ANIMATE_STATE);\n          }\n        }\n      }\n\n      function animationsDisabled(element, parentElement) {\n        if (rootAnimateState.disabled) {\n          return true;\n        }\n\n        if (isMatchingElement(element, $rootElement)) {\n          return rootAnimateState.running;\n        }\n\n        var allowChildAnimations, parentRunningAnimation, hasParent;\n        do {\n          //the element did not reach the root element which means that it\n          //is not apart of the DOM. Therefore there is no reason to do\n          //any animations on it\n          if (parentElement.length === 0) break;\n\n          var isRoot = isMatchingElement(parentElement, $rootElement);\n          var state = isRoot ? rootAnimateState : (parentElement.data(NG_ANIMATE_STATE) || {});\n          if (state.disabled) {\n            return true;\n          }\n\n          //no matter what, for an animation to work it must reach the root element\n          //this implies that the element is attached to the DOM when the animation is run\n          if (isRoot) {\n            hasParent = true;\n          }\n\n          //once a flag is found that is strictly false then everything before\n          //it will be discarded and all child animations will be restricted\n          if (allowChildAnimations !== false) {\n            var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);\n            if (angular.isDefined(animateChildrenFlag)) {\n              allowChildAnimations = animateChildrenFlag;\n            }\n          }\n\n          parentRunningAnimation = parentRunningAnimation ||\n                                   state.running ||\n                                   (state.last && !state.last.isClassBased);\n        }\n        while (parentElement = parentElement.parent());\n\n        return !hasParent || (!allowChildAnimations && parentRunningAnimation);\n      }\n    }]);\n\n    $animateProvider.register('', ['$window', '$sniffer', '$timeout', '$$animateReflow',\n                           function($window,   $sniffer,   $timeout,   $$animateReflow) {\n      // Detect proper transitionend/animationend event names.\n      var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n      // If unprefixed events are not supported but webkit-prefixed are, use the latter.\n      // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n      // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n      // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n      // Register both events in case `window.onanimationend` is not supported because of that,\n      // do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n      // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n      // therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition\n      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n        CSS_PREFIX = '-webkit-';\n        TRANSITION_PROP = 'WebkitTransition';\n        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n      } else {\n        TRANSITION_PROP = 'transition';\n        TRANSITIONEND_EVENT = 'transitionend';\n      }\n\n      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n        CSS_PREFIX = '-webkit-';\n        ANIMATION_PROP = 'WebkitAnimation';\n        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n      } else {\n        ANIMATION_PROP = 'animation';\n        ANIMATIONEND_EVENT = 'animationend';\n      }\n\n      var DURATION_KEY = 'Duration';\n      var PROPERTY_KEY = 'Property';\n      var DELAY_KEY = 'Delay';\n      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\n      var ANIMATION_PLAYSTATE_KEY = 'PlayState';\n      var NG_ANIMATE_PARENT_KEY = '$$ngAnimateKey';\n      var NG_ANIMATE_CSS_DATA_KEY = '$$ngAnimateCSS3Data';\n      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n      var CLOSING_TIME_BUFFER = 1.5;\n      var ONE_SECOND = 1000;\n\n      var lookupCache = {};\n      var parentCounter = 0;\n      var animationReflowQueue = [];\n      var cancelAnimationReflow;\n      function clearCacheAfterReflow() {\n        if (!cancelAnimationReflow) {\n          cancelAnimationReflow = $$animateReflow(function() {\n            animationReflowQueue = [];\n            cancelAnimationReflow = null;\n            lookupCache = {};\n          });\n        }\n      }\n\n      function afterReflow(element, callback) {\n        if (cancelAnimationReflow) {\n          cancelAnimationReflow();\n        }\n        animationReflowQueue.push(callback);\n        cancelAnimationReflow = $$animateReflow(function() {\n          forEach(animationReflowQueue, function(fn) {\n            fn();\n          });\n\n          animationReflowQueue = [];\n          cancelAnimationReflow = null;\n          lookupCache = {};\n        });\n      }\n\n      var closingTimer = null;\n      var closingTimestamp = 0;\n      var animationElementQueue = [];\n      function animationCloseHandler(element, totalTime) {\n        var node = extractElementNode(element);\n        element = angular.element(node);\n\n        //this item will be garbage collected by the closing\n        //animation timeout\n        animationElementQueue.push(element);\n\n        //but it may not need to cancel out the existing timeout\n        //if the timestamp is less than the previous one\n        var futureTimestamp = Date.now() + totalTime;\n        if (futureTimestamp <= closingTimestamp) {\n          return;\n        }\n\n        $timeout.cancel(closingTimer);\n\n        closingTimestamp = futureTimestamp;\n        closingTimer = $timeout(function() {\n          closeAllAnimations(animationElementQueue);\n          animationElementQueue = [];\n        }, totalTime, false);\n      }\n\n      function closeAllAnimations(elements) {\n        forEach(elements, function(element) {\n          var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);\n          if (elementData) {\n            forEach(elementData.closeAnimationFns, function(fn) {\n              fn();\n            });\n          }\n        });\n      }\n\n      function getElementAnimationDetails(element, cacheKey) {\n        var data = cacheKey ? lookupCache[cacheKey] : null;\n        if (!data) {\n          var transitionDuration = 0;\n          var transitionDelay = 0;\n          var animationDuration = 0;\n          var animationDelay = 0;\n\n          //we want all the styles defined before and after\n          forEach(element, function(element) {\n            if (element.nodeType == ELEMENT_NODE) {\n              var elementStyles = $window.getComputedStyle(element) || {};\n\n              var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];\n              transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);\n\n              var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];\n              transitionDelay  = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);\n\n              var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];\n              animationDelay   = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);\n\n              var aDuration  = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);\n\n              if (aDuration > 0) {\n                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;\n              }\n              animationDuration = Math.max(aDuration, animationDuration);\n            }\n          });\n          data = {\n            total: 0,\n            transitionDelay: transitionDelay,\n            transitionDuration: transitionDuration,\n            animationDelay: animationDelay,\n            animationDuration: animationDuration\n          };\n          if (cacheKey) {\n            lookupCache[cacheKey] = data;\n          }\n        }\n        return data;\n      }\n\n      function parseMaxTime(str) {\n        var maxValue = 0;\n        var values = isString(str) ?\n          str.split(/\\s*,\\s*/) :\n          [];\n        forEach(values, function(value) {\n          maxValue = Math.max(parseFloat(value) || 0, maxValue);\n        });\n        return maxValue;\n      }\n\n      function getCacheKey(element) {\n        var parentElement = element.parent();\n        var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);\n        if (!parentID) {\n          parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);\n          parentID = parentCounter;\n        }\n        return parentID + '-' + extractElementNode(element).getAttribute('class');\n      }\n\n      function animateSetup(animationEvent, element, className, styles) {\n        var structural = ['ng-enter','ng-leave','ng-move'].indexOf(className) >= 0;\n\n        var cacheKey = getCacheKey(element);\n        var eventCacheKey = cacheKey + ' ' + className;\n        var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;\n\n        var stagger = {};\n        if (itemIndex > 0) {\n          var staggerClassName = className + '-stagger';\n          var staggerCacheKey = cacheKey + ' ' + staggerClassName;\n          var applyClasses = !lookupCache[staggerCacheKey];\n\n          applyClasses && $$jqLite.addClass(element, staggerClassName);\n\n          stagger = getElementAnimationDetails(element, staggerCacheKey);\n\n          applyClasses && $$jqLite.removeClass(element, staggerClassName);\n        }\n\n        $$jqLite.addClass(element, className);\n\n        var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};\n        var timings = getElementAnimationDetails(element, eventCacheKey);\n        var transitionDuration = timings.transitionDuration;\n        var animationDuration = timings.animationDuration;\n\n        if (structural && transitionDuration === 0 && animationDuration === 0) {\n          $$jqLite.removeClass(element, className);\n          return false;\n        }\n\n        var blockTransition = styles || (structural && transitionDuration > 0);\n        var blockAnimation = animationDuration > 0 &&\n                             stagger.animationDelay > 0 &&\n                             stagger.animationDuration === 0;\n\n        var closeAnimationFns = formerData.closeAnimationFns || [];\n        element.data(NG_ANIMATE_CSS_DATA_KEY, {\n          stagger: stagger,\n          cacheKey: eventCacheKey,\n          running: formerData.running || 0,\n          itemIndex: itemIndex,\n          blockTransition: blockTransition,\n          closeAnimationFns: closeAnimationFns\n        });\n\n        var node = extractElementNode(element);\n\n        if (blockTransition) {\n          blockTransitions(node, true);\n          if (styles) {\n            element.css(styles);\n          }\n        }\n\n        if (blockAnimation) {\n          blockAnimations(node, true);\n        }\n\n        return true;\n      }\n\n      function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {\n        var node = extractElementNode(element);\n        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);\n        if (node.getAttribute('class').indexOf(className) == -1 || !elementData) {\n          activeAnimationComplete();\n          return;\n        }\n\n        var activeClassName = '';\n        var pendingClassName = '';\n        forEach(className.split(' '), function(klass, i) {\n          var prefix = (i > 0 ? ' ' : '') + klass;\n          activeClassName += prefix + '-active';\n          pendingClassName += prefix + '-pending';\n        });\n\n        var style = '';\n        var appliedStyles = [];\n        var itemIndex = elementData.itemIndex;\n        var stagger = elementData.stagger;\n        var staggerTime = 0;\n        if (itemIndex > 0) {\n          var transitionStaggerDelay = 0;\n          if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {\n            transitionStaggerDelay = stagger.transitionDelay * itemIndex;\n          }\n\n          var animationStaggerDelay = 0;\n          if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {\n            animationStaggerDelay = stagger.animationDelay * itemIndex;\n            appliedStyles.push(CSS_PREFIX + 'animation-play-state');\n          }\n\n          staggerTime = Math.round(Math.max(transitionStaggerDelay, animationStaggerDelay) * 100) / 100;\n        }\n\n        if (!staggerTime) {\n          $$jqLite.addClass(element, activeClassName);\n          if (elementData.blockTransition) {\n            blockTransitions(node, false);\n          }\n        }\n\n        var eventCacheKey = elementData.cacheKey + ' ' + activeClassName;\n        var timings = getElementAnimationDetails(element, eventCacheKey);\n        var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);\n        if (maxDuration === 0) {\n          $$jqLite.removeClass(element, activeClassName);\n          animateClose(element, className);\n          activeAnimationComplete();\n          return;\n        }\n\n        if (!staggerTime && styles && Object.keys(styles).length > 0) {\n          if (!timings.transitionDuration) {\n            element.css('transition', timings.animationDuration + 's linear all');\n            appliedStyles.push('transition');\n          }\n          element.css(styles);\n        }\n\n        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);\n        var maxDelayTime = maxDelay * ONE_SECOND;\n\n        if (appliedStyles.length > 0) {\n          //the element being animated may sometimes contain comment nodes in\n          //the jqLite object, so we're safe to use a single variable to house\n          //the styles since there is always only one element being animated\n          var oldStyle = node.getAttribute('style') || '';\n          if (oldStyle.charAt(oldStyle.length - 1) !== ';') {\n            oldStyle += ';';\n          }\n          node.setAttribute('style', oldStyle + ' ' + style);\n        }\n\n        var startTime = Date.now();\n        var css3AnimationEvents = ANIMATIONEND_EVENT + ' ' + TRANSITIONEND_EVENT;\n        var animationTime     = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;\n        var totalTime         = (staggerTime + animationTime) * ONE_SECOND;\n\n        var staggerTimeout;\n        if (staggerTime > 0) {\n          $$jqLite.addClass(element, pendingClassName);\n          staggerTimeout = $timeout(function() {\n            staggerTimeout = null;\n\n            if (timings.transitionDuration > 0) {\n              blockTransitions(node, false);\n            }\n            if (timings.animationDuration > 0) {\n              blockAnimations(node, false);\n            }\n\n            $$jqLite.addClass(element, activeClassName);\n            $$jqLite.removeClass(element, pendingClassName);\n\n            if (styles) {\n              if (timings.transitionDuration === 0) {\n                element.css('transition', timings.animationDuration + 's linear all');\n              }\n              element.css(styles);\n              appliedStyles.push('transition');\n            }\n          }, staggerTime * ONE_SECOND, false);\n        }\n\n        element.on(css3AnimationEvents, onAnimationProgress);\n        elementData.closeAnimationFns.push(function() {\n          onEnd();\n          activeAnimationComplete();\n        });\n\n        elementData.running++;\n        animationCloseHandler(element, totalTime);\n        return onEnd;\n\n        // This will automatically be called by $animate so\n        // there is no need to attach this internally to the\n        // timeout done method.\n        function onEnd() {\n          element.off(css3AnimationEvents, onAnimationProgress);\n          $$jqLite.removeClass(element, activeClassName);\n          $$jqLite.removeClass(element, pendingClassName);\n          if (staggerTimeout) {\n            $timeout.cancel(staggerTimeout);\n          }\n          animateClose(element, className);\n          var node = extractElementNode(element);\n          for (var i in appliedStyles) {\n            node.style.removeProperty(appliedStyles[i]);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            activeAnimationComplete();\n          }\n        }\n      }\n\n      function blockTransitions(node, bool) {\n        node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? 'none' : '';\n      }\n\n      function blockAnimations(node, bool) {\n        node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? 'paused' : '';\n      }\n\n      function animateBefore(animationEvent, element, className, styles) {\n        if (animateSetup(animationEvent, element, className, styles)) {\n          return function(cancelled) {\n            cancelled && animateClose(element, className);\n          };\n        }\n      }\n\n      function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {\n        if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {\n          return animateRun(animationEvent, element, className, afterAnimationComplete, styles);\n        } else {\n          animateClose(element, className);\n          afterAnimationComplete();\n        }\n      }\n\n      function animate(animationEvent, element, className, animationComplete, options) {\n        //If the animateSetup function doesn't bother returning a\n        //cancellation function then it means that there is no animation\n        //to perform at all\n        var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);\n        if (!preReflowCancellation) {\n          clearCacheAfterReflow();\n          animationComplete();\n          return;\n        }\n\n        //There are two cancellation functions: one is before the first\n        //reflow animation and the second is during the active state\n        //animation. The first function will take care of removing the\n        //data from the element which will not make the 2nd animation\n        //happen in the first place\n        var cancel = preReflowCancellation;\n        afterReflow(element, function() {\n          //once the reflow is complete then we point cancel to\n          //the new cancellation function which will remove all of the\n          //animation properties from the active animation\n          cancel = animateAfter(animationEvent, element, className, animationComplete, options.to);\n        });\n\n        return function(cancelled) {\n          (cancel || noop)(cancelled);\n        };\n      }\n\n      function animateClose(element, className) {\n        $$jqLite.removeClass(element, className);\n        var data = element.data(NG_ANIMATE_CSS_DATA_KEY);\n        if (data) {\n          if (data.running) {\n            data.running--;\n          }\n          if (!data.running || data.running === 0) {\n            element.removeData(NG_ANIMATE_CSS_DATA_KEY);\n          }\n        }\n      }\n\n      return {\n        animate: function(element, className, from, to, animationCompleted, options) {\n          options = options || {};\n          options.from = from;\n          options.to = to;\n          return animate('animate', element, className, animationCompleted, options);\n        },\n\n        enter: function(element, animationCompleted, options) {\n          options = options || {};\n          return animate('enter', element, 'ng-enter', animationCompleted, options);\n        },\n\n        leave: function(element, animationCompleted, options) {\n          options = options || {};\n          return animate('leave', element, 'ng-leave', animationCompleted, options);\n        },\n\n        move: function(element, animationCompleted, options) {\n          options = options || {};\n          return animate('move', element, 'ng-move', animationCompleted, options);\n        },\n\n        beforeSetClass: function(element, add, remove, animationCompleted, options) {\n          options = options || {};\n          var className = suffixClasses(remove, '-remove') + ' ' +\n                          suffixClasses(add, '-add');\n          var cancellationMethod = animateBefore('setClass', element, className, options.from);\n          if (cancellationMethod) {\n            afterReflow(element, animationCompleted);\n            return cancellationMethod;\n          }\n          clearCacheAfterReflow();\n          animationCompleted();\n        },\n\n        beforeAddClass: function(element, className, animationCompleted, options) {\n          options = options || {};\n          var cancellationMethod = animateBefore('addClass', element, suffixClasses(className, '-add'), options.from);\n          if (cancellationMethod) {\n            afterReflow(element, animationCompleted);\n            return cancellationMethod;\n          }\n          clearCacheAfterReflow();\n          animationCompleted();\n        },\n\n        beforeRemoveClass: function(element, className, animationCompleted, options) {\n          options = options || {};\n          var cancellationMethod = animateBefore('removeClass', element, suffixClasses(className, '-remove'), options.from);\n          if (cancellationMethod) {\n            afterReflow(element, animationCompleted);\n            return cancellationMethod;\n          }\n          clearCacheAfterReflow();\n          animationCompleted();\n        },\n\n        setClass: function(element, add, remove, animationCompleted, options) {\n          options = options || {};\n          remove = suffixClasses(remove, '-remove');\n          add = suffixClasses(add, '-add');\n          var className = remove + ' ' + add;\n          return animateAfter('setClass', element, className, animationCompleted, options.to);\n        },\n\n        addClass: function(element, className, animationCompleted, options) {\n          options = options || {};\n          return animateAfter('addClass', element, suffixClasses(className, '-add'), animationCompleted, options.to);\n        },\n\n        removeClass: function(element, className, animationCompleted, options) {\n          options = options || {};\n          return animateAfter('removeClass', element, suffixClasses(className, '-remove'), animationCompleted, options.to);\n        }\n      };\n\n      function suffixClasses(classes, suffix) {\n        var className = '';\n        classes = isArray(classes) ? classes : classes.split(/\\s+/);\n        forEach(classes, function(klass, i) {\n          if (klass && klass.length > 0) {\n            className += (i > 0 ? ' ' : '') + klass + suffix;\n          }\n        });\n        return className;\n      }\n    }]);\n  }]);\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-animate/angular-animate.js\n ** module id = 2\n ** module chunks = 0\n **/","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-animate/index.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * @license AngularJS v1.3.15\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngAria\n * @description\n *\n * The `ngAria` module provides support for common\n * [<abbr title=\"Accessible Rich Internet Applications\">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)\n * attributes that convey state or semantic information about the application for users\n * of assistive technologies, such as screen readers.\n *\n * <div doc-module-components=\"ngAria\"></div>\n *\n * ## Usage\n *\n * For ngAria to do its magic, simply include the module as a dependency. The directives supported\n * by ngAria are:\n * `ngModel`, `ngDisabled`, `ngShow`, `ngHide`, `ngClick`, `ngDblClick`, and `ngMessages`.\n *\n * Below is a more detailed breakdown of the attributes handled by ngAria:\n *\n * | Directive                                   | Supported Attributes                                                                   |\n * |---------------------------------------------|----------------------------------------------------------------------------------------|\n * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                          |\n * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                               |\n * | {@link module:ngMessages ngMessages}        | aria-live                                                                              |\n * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required, input roles |\n * | {@link ng.directive:ngClick ngClick}        | tabindex, keypress event, button role                                                               |\n *\n * Find out more information about each directive by reading the\n * {@link guide/accessibility ngAria Developer Guide}.\n *\n * ##Example\n * Using ngDisabled with ngAria:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\">\n * ```\n * Becomes:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\" aria-disabled=\"true\">\n * ```\n *\n * ##Disabling Attributes\n * It's possible to disable individual attributes added by ngAria with the\n * {@link ngAria.$ariaProvider#config config} method. For more details, see the\n * {@link guide/accessibility Developer Guide}.\n */\n /* global -ngAriaModule */\nvar ngAriaModule = angular.module('ngAria', ['ng']).\n                        provider('$aria', $AriaProvider);\n\n/**\n * @ngdoc provider\n * @name $ariaProvider\n *\n * @description\n *\n * Used for configuring the ARIA attributes injected and managed by ngAria.\n *\n * ```js\n * angular.module('myApp', ['ngAria'], function config($ariaProvider) {\n *   $ariaProvider.config({\n *     ariaValue: true,\n *     tabindex: false\n *   });\n * });\n *```\n *\n * ## Dependencies\n * Requires the {@link ngAria} module to be installed.\n *\n */\nfunction $AriaProvider() {\n  var config = {\n    ariaHidden: true,\n    ariaChecked: true,\n    ariaDisabled: true,\n    ariaRequired: true,\n    ariaInvalid: true,\n    ariaMultiline: true,\n    ariaValue: true,\n    tabindex: true,\n    bindKeypress: true\n  };\n\n  /**\n   * @ngdoc method\n   * @name $ariaProvider#config\n   *\n   * @param {object} config object to enable/disable specific ARIA attributes\n   *\n   *  - **ariaHidden** – `{boolean}` – Enables/disables aria-hidden tags\n   *  - **ariaChecked** – `{boolean}` – Enables/disables aria-checked tags\n   *  - **ariaDisabled** – `{boolean}` – Enables/disables aria-disabled tags\n   *  - **ariaRequired** – `{boolean}` – Enables/disables aria-required tags\n   *  - **ariaInvalid** – `{boolean}` – Enables/disables aria-invalid tags\n   *  - **ariaMultiline** – `{boolean}` – Enables/disables aria-multiline tags\n   *  - **ariaValue** – `{boolean}` – Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags\n   *  - **tabindex** – `{boolean}` – Enables/disables tabindex tags\n   *  - **bindKeypress** – `{boolean}` – Enables/disables keypress event binding on `&lt;div&gt;` and\n   *    `&lt;li&gt;` elements with ng-click\n   *\n   * @description\n   * Enables/disables various ARIA attributes\n   */\n  this.config = function(newConfig) {\n    config = angular.extend(config, newConfig);\n  };\n\n  function watchExpr(attrName, ariaAttr, negate) {\n    return function(scope, elem, attr) {\n      var ariaCamelName = attr.$normalize(ariaAttr);\n      if (config[ariaCamelName] && !attr[ariaCamelName]) {\n        scope.$watch(attr[attrName], function(boolVal) {\n          if (negate) {\n            boolVal = !boolVal;\n          }\n          elem.attr(ariaAttr, boolVal);\n        });\n      }\n    };\n  }\n\n  /**\n   * @ngdoc service\n   * @name $aria\n   *\n   * @description\n   * @priority 200\n   *\n   * The $aria service contains helper methods for applying common\n   * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.\n   *\n   * ngAria injects common accessibility attributes that tell assistive technologies when HTML\n   * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,\n   * let's review a code snippet from ngAria itself:\n   *\n   *```js\n   * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {\n   *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n   * }])\n   *```\n   * Shown above, the ngAria module creates a directive with the same signature as the\n   * traditional `ng-disabled` directive. But this ngAria version is dedicated to\n   * solely managing accessibility attributes. The internal `$aria` service is used to watch the\n   * boolean attribute `ngDisabled`. If it has not been explicitly set by the developer,\n   * `aria-disabled` is injected as an attribute with its value synchronized to the value in\n   * `ngDisabled`.\n   *\n   * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do\n   * anything to enable this feature. The `aria-disabled` attribute is automatically managed\n   * simply as a silent side-effect of using `ng-disabled` with the ngAria module.\n   *\n   * The full list of directives that interface with ngAria:\n   * * **ngModel**\n   * * **ngShow**\n   * * **ngHide**\n   * * **ngClick**\n   * * **ngDblclick**\n   * * **ngMessages**\n   * * **ngDisabled**\n   *\n   * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each\n   * directive.\n   *\n   *\n   * ## Dependencies\n   * Requires the {@link ngAria} module to be installed.\n   */\n  this.$get = function() {\n    return {\n      config: function(key) {\n        return config[key];\n      },\n      $$watchExpr: watchExpr\n    };\n  };\n}\n\n\nngAriaModule.directive('ngShow', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngShow', 'aria-hidden', true);\n}])\n.directive('ngHide', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngHide', 'aria-hidden', false);\n}])\n.directive('ngModel', ['$aria', function($aria) {\n\n  function shouldAttachAttr(attr, normalizedAttr, elem) {\n    return $aria.config(normalizedAttr) && !elem.attr(attr);\n  }\n\n  function shouldAttachRole(role, elem) {\n    return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');\n  }\n\n  function getShape(attr, elem) {\n    var type = attr.type,\n        role = attr.role;\n\n    return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :\n           ((type || role) === 'radio'    || role === 'menuitemradio') ? 'radio' :\n           (type === 'range'              || role === 'progressbar' || role === 'slider') ? 'range' :\n           (type || role) === 'textbox'   || elem[0].nodeName === 'TEXTAREA' ? 'multiline' : '';\n  }\n\n  return {\n    restrict: 'A',\n    require: '?ngModel',\n    priority: 200, //Make sure watches are fired after any other directives that affect the ngModel value\n    link: function(scope, elem, attr, ngModel) {\n      var shape = getShape(attr, elem);\n      var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem);\n\n      function ngAriaWatchModelValue() {\n        return ngModel.$modelValue;\n      }\n\n      function getRadioReaction() {\n        if (needsTabIndex) {\n          needsTabIndex = false;\n          return function ngAriaRadioReaction(newVal) {\n            var boolVal = (attr.value == ngModel.$viewValue);\n            elem.attr('aria-checked', boolVal);\n            elem.attr('tabindex', 0 - !boolVal);\n          };\n        } else {\n          return function ngAriaRadioReaction(newVal) {\n            elem.attr('aria-checked', (attr.value == ngModel.$viewValue));\n          };\n        }\n      }\n\n      function ngAriaCheckboxReaction(newVal) {\n        elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));\n      }\n\n      switch (shape) {\n        case 'radio':\n        case 'checkbox':\n          if (shouldAttachRole(shape, elem)) {\n            elem.attr('role', shape);\n          }\n          if (shouldAttachAttr('aria-checked', 'ariaChecked', elem)) {\n            scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?\n                getRadioReaction() : ngAriaCheckboxReaction);\n          }\n          break;\n        case 'range':\n          if (shouldAttachRole(shape, elem)) {\n            elem.attr('role', 'slider');\n          }\n          if ($aria.config('ariaValue')) {\n            if (attr.min && !elem.attr('aria-valuemin')) {\n              elem.attr('aria-valuemin', attr.min);\n            }\n            if (attr.max && !elem.attr('aria-valuemax')) {\n              elem.attr('aria-valuemax', attr.max);\n            }\n            if (!elem.attr('aria-valuenow')) {\n              scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {\n                elem.attr('aria-valuenow', newVal);\n              });\n            }\n          }\n          break;\n        case 'multiline':\n          if (shouldAttachAttr('aria-multiline', 'ariaMultiline', elem)) {\n            elem.attr('aria-multiline', true);\n          }\n          break;\n      }\n\n      if (needsTabIndex) {\n        elem.attr('tabindex', 0);\n      }\n\n      if (ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem)) {\n        scope.$watch(function ngAriaRequiredWatch() {\n          return ngModel.$error.required;\n        }, function ngAriaRequiredReaction(newVal) {\n          elem.attr('aria-required', !!newVal);\n        });\n      }\n\n      if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem)) {\n        scope.$watch(function ngAriaInvalidWatch() {\n          return ngModel.$invalid;\n        }, function ngAriaInvalidReaction(newVal) {\n          elem.attr('aria-invalid', !!newVal);\n        });\n      }\n    }\n  };\n}])\n.directive('ngDisabled', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n}])\n.directive('ngMessages', function() {\n  return {\n    restrict: 'A',\n    require: '?ngMessages',\n    link: function(scope, elem, attr, ngMessages) {\n      if (!elem.attr('aria-live')) {\n        elem.attr('aria-live', 'assertive');\n      }\n    }\n  };\n})\n.directive('ngClick',['$aria', '$parse', function($aria, $parse) {\n  return {\n    restrict: 'A',\n    compile: function(elem, attr) {\n      var fn = $parse(attr.ngClick, /* interceptorFn */ null, /* expensiveChecks */ true);\n      return function(scope, elem, attr) {\n\n        var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA'];\n\n        function isNodeOneOf(elem, nodeTypeArray) {\n          if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {\n            return true;\n          }\n        }\n        if (!elem.attr('role') && !isNodeOneOf(elem, nodeBlackList)) {\n          elem.attr('role', 'button');\n        }\n\n        if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n          elem.attr('tabindex', 0);\n        }\n\n        if ($aria.config('bindKeypress') && !attr.ngKeypress && !isNodeOneOf(elem, nodeBlackList)) {\n          elem.on('keypress', function(event) {\n            if (event.keyCode === 32 || event.keyCode === 13) {\n              scope.$apply(callback);\n            }\n\n            function callback() {\n              fn(scope, { $event: event });\n            }\n          });\n        }\n      };\n    }\n  };\n}])\n.directive('ngDblclick', ['$aria', function($aria) {\n  return function(scope, elem, attr) {\n    if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n      elem.attr('tabindex', 0);\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-aria/angular-aria.js\n ** module id = 4\n ** module chunks = 0\n **/","require('./angular-aria');\nmodule.exports = 'ngAria';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-aria/index.js\n ** module id = 5\n ** module chunks = 0\n **/","/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v0.10.0\n */\n(function( window, angular, undefined ){\n\"use strict\";\n\n(function(){\n\"use strict\";\n\nangular.module('ngMaterial', [\"ng\",\"ngAnimate\",\"ngAria\",\"material.core\",\"material.core.gestures\",\"material.core.theming.palette\",\"material.core.theming\",\"material.components.autocomplete\",\"material.components.backdrop\",\"material.components.bottomSheet\",\"material.components.button\",\"material.components.card\",\"material.components.checkbox\",\"material.components.content\",\"material.components.chips\",\"material.components.dialog\",\"material.components.fabActions\",\"material.components.divider\",\"material.components.fabSpeedDial\",\"material.components.fabToolbar\",\"material.components.gridList\",\"material.components.fabTrigger\",\"material.components.icon\",\"material.components.input\",\"material.components.list\",\"material.components.menu\",\"material.components.progressCircular\",\"material.components.progressLinear\",\"material.components.radioButton\",\"material.components.select\",\"material.components.sidenav\",\"material.components.slider\",\"material.components.subheader\",\"material.components.sticky\",\"material.components.swipe\",\"material.components.switch\",\"material.components.tabs\",\"material.components.toast\",\"material.components.toolbar\",\"material.components.tooltip\",\"material.components.whiteframe\"]);\n})();\n(function(){\n\"use strict\";\n\n\n/**\n * Initialization function that validates environment\n * requirements.\n */\nangular\n  .module('material.core', [ 'material.core.gestures', 'material.core.theming' ])\n  .config( MdCoreConfigure );\n\n\nfunction MdCoreConfigure($provide, $mdThemingProvider) {\n\n  $provide.decorator('$$rAF', [\"$delegate\", rAFDecorator]);\n\n  $mdThemingProvider.theme('default')\n    .primaryPalette('indigo')\n    .accentPalette('pink')\n    .warnPalette('red')\n    .backgroundPalette('grey');\n}\nMdCoreConfigure.$inject = [\"$provide\", \"$mdThemingProvider\"];\n\nfunction rAFDecorator( $delegate ) {\n  /**\n   * Use this to throttle events that come in often.\n   * The throttled function will always use the *last* invocation before the\n   * coming frame.\n   *\n   * For example, window resize events that fire many times a second:\n   * If we set to use an raf-throttled callback on window resize, then\n   * our callback will only be fired once per frame, with the last resize\n   * event that happened before that frame.\n   *\n   * @param {function} callback function to debounce\n   */\n  $delegate.throttle = function(cb) {\n    var queueArgs, alreadyQueued, queueCb, context;\n    return function debounced() {\n      queueArgs = arguments;\n      context = this;\n      queueCb = cb;\n      if (!alreadyQueued) {\n        alreadyQueued = true;\n        $delegate(function() {\n          queueCb.apply(context, queueArgs);\n          alreadyQueued = false;\n        });\n      }\n    };\n  };\n  return $delegate;\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n.factory('$mdConstant', MdConstantFactory);\n\nfunction MdConstantFactory($$rAF, $sniffer) {\n\n  var webkit = /webkit/i.test($sniffer.vendorPrefix);\n  function vendorProperty(name) {\n    return webkit ?  ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;\n  }\n\n  return {\n    KEY_CODE: {\n      ENTER: 13,\n      ESCAPE: 27,\n      SPACE: 32,\n      LEFT_ARROW : 37,\n      UP_ARROW : 38,\n      RIGHT_ARROW : 39,\n      DOWN_ARROW : 40,\n      TAB : 9,\n      BACKSPACE: 8,\n      DELETE: 46\n    },\n    CSS: {\n      /* Constants */\n      TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),\n      ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),\n\n      TRANSFORM: vendorProperty('transform'),\n      TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),\n      TRANSITION: vendorProperty('transition'),\n      TRANSITION_DURATION: vendorProperty('transitionDuration'),\n      ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),\n      ANIMATION_DURATION: vendorProperty('animationDuration'),\n      ANIMATION_NAME: vendorProperty('animationName'),\n      ANIMATION_TIMING: vendorProperty('animationTimingFunction'),\n      ANIMATION_DIRECTION: vendorProperty('animationDirection')\n    },\n    MEDIA: {\n      'sm': '(max-width: 600px)',\n      'gt-sm': '(min-width: 600px)',\n      'md': '(min-width: 600px) and (max-width: 960px)',\n      'gt-md': '(min-width: 960px)',\n      'lg': '(min-width: 960px) and (max-width: 1200px)',\n      'gt-lg': '(min-width: 1200px)'\n    },\n    MEDIA_PRIORITY: [\n      'gt-lg',\n      'lg',\n      'gt-md',\n      'md',\n      'gt-sm',\n      'sm'\n    ]\n  };\n}\nMdConstantFactory.$inject = [\"$$rAF\", \"$sniffer\"];\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n    .module('material.core')\n    .config( [\"$provide\", function($provide){\n       $provide.decorator('$mdUtil', ['$delegate', function ($delegate){\n           /**\n            * Inject the iterator facade to easily support iteration and accessors\n            * @see iterator below\n            */\n           $delegate.iterator = MdIterator;\n\n           return $delegate;\n         }\n       ]);\n     }]);\n\n  /**\n   * iterator is a list facade to easily support iteration and accessors\n   *\n   * @param items Array list which this iterator will enumerate\n   * @param reloop Boolean enables iterator to consider the list as an endless reloop\n   */\n  function MdIterator(items, reloop) {\n    var trueFn = function() { return true; };\n\n    if (items && !angular.isArray(items)) {\n      items = Array.prototype.slice.call(items);\n    }\n\n    reloop = !!reloop;\n    var _items = items || [ ];\n\n    // Published API\n    return {\n      items: getItems,\n      count: count,\n\n      inRange: inRange,\n      contains: contains,\n      indexOf: indexOf,\n      itemAt: itemAt,\n\n      findBy: findBy,\n\n      add: add,\n      remove: remove,\n\n      first: first,\n      last: last,\n      next: angular.bind(null, findSubsequentItem, false),\n      previous: angular.bind(null, findSubsequentItem, true),\n\n      hasPrevious: hasPrevious,\n      hasNext: hasNext\n\n    };\n\n    /**\n     * Publish copy of the enumerable set\n     * @returns {Array|*}\n     */\n    function getItems() {\n      return [].concat(_items);\n    }\n\n    /**\n     * Determine length of the list\n     * @returns {Array.length|*|number}\n     */\n    function count() {\n      return _items.length;\n    }\n\n    /**\n     * Is the index specified valid\n     * @param index\n     * @returns {Array.length|*|number|boolean}\n     */\n    function inRange(index) {\n      return _items.length && ( index > -1 ) && (index < _items.length );\n    }\n\n    /**\n     * Can the iterator proceed to the next item in the list; relative to\n     * the specified item.\n     *\n     * @param item\n     * @returns {Array.length|*|number|boolean}\n     */\n    function hasNext(item) {\n      return item ? inRange(indexOf(item) + 1) : false;\n    }\n\n    /**\n     * Can the iterator proceed to the previous item in the list; relative to\n     * the specified item.\n     *\n     * @param item\n     * @returns {Array.length|*|number|boolean}\n     */\n    function hasPrevious(item) {\n      return item ? inRange(indexOf(item) - 1) : false;\n    }\n\n    /**\n     * Get item at specified index/position\n     * @param index\n     * @returns {*}\n     */\n    function itemAt(index) {\n      return inRange(index) ? _items[index] : null;\n    }\n\n    /**\n     * Find all elements matching the key/value pair\n     * otherwise return null\n     *\n     * @param val\n     * @param key\n     *\n     * @return array\n     */\n    function findBy(key, val) {\n      return _items.filter(function(item) {\n        return item[key] === val;\n      });\n    }\n\n    /**\n     * Add item to list\n     * @param item\n     * @param index\n     * @returns {*}\n     */\n    function add(item, index) {\n      if ( !item ) return -1;\n\n      if (!angular.isNumber(index)) {\n        index = _items.length;\n      }\n\n      _items.splice(index, 0, item);\n\n      return indexOf(item);\n    }\n\n    /**\n     * Remove item from list...\n     * @param item\n     */\n    function remove(item) {\n      if ( contains(item) ){\n        _items.splice(indexOf(item), 1);\n      }\n    }\n\n    /**\n     * Get the zero-based index of the target item\n     * @param item\n     * @returns {*}\n     */\n    function indexOf(item) {\n      return _items.indexOf(item);\n    }\n\n    /**\n     * Boolean existence check\n     * @param item\n     * @returns {boolean}\n     */\n    function contains(item) {\n      return item && (indexOf(item) > -1);\n    }\n\n    /**\n     * Return first item in the list\n     * @returns {*}\n     */\n    function first() {\n      return _items.length ? _items[0] : null;\n    }\n\n    /**\n     * Return last item in the list...\n     * @returns {*}\n     */\n    function last() {\n      return _items.length ? _items[_items.length - 1] : null;\n    }\n\n    /**\n     * Find the next item. If reloop is true and at the end of the list, it will go back to the\n     * first item. If given, the `validate` callback will be used to determine whether the next item\n     * is valid. If not valid, it will try to find the next item again.\n     *\n     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)\n     * @param {*} item The item whose subsequent item we are looking for\n     * @param {Function=} validate The `validate` function\n     * @param {integer=} limit The recursion limit\n     *\n     * @returns {*} The subsequent item or null\n     */\n    function findSubsequentItem(backwards, item, validate, limit) {\n      validate = validate || trueFn;\n\n      var curIndex = indexOf(item);\n      while (true) {\n        if (!inRange(curIndex)) return null;\n\n        var nextIndex = curIndex + (backwards ? -1 : 1);\n        var foundItem = null;\n        if (inRange(nextIndex)) {\n          foundItem = _items[nextIndex];\n        } else if (reloop) {\n          foundItem = backwards ? last() : first();\n          nextIndex = indexOf(foundItem);\n        }\n\n        if ((foundItem === null) || (nextIndex === limit)) return null;\n        if (validate(foundItem)) return foundItem;\n\n        if (angular.isUndefined(limit)) limit = nextIndex;\n\n        curIndex = nextIndex;\n      }\n    }\n  }\n\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n.factory('$mdMedia', mdMediaFactory);\n\n/**\n * @ngdoc service\n * @name $mdMedia\n * @module material.core\n *\n * @description\n * `$mdMedia` is used to evaluate whether a given media query is true or false given the\n * current device's screen / window size. The media query will be re-evaluated on resize, allowing\n * you to register a watch.\n *\n * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints.\n *  (`sm`, `gt-sm`, `md`, `gt-md`, `lg`, `gt-lg`).\n *\n * @returns {boolean} a boolean representing whether or not the given media query is true or false.\n *\n * @usage\n * <hljs lang=\"js\">\n * app.controller('MyController', function($mdMedia, $scope) {\n *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {\n *     $scope.bigScreen = big;\n *   });\n *\n *   $scope.screenIsSmall = $mdMedia('sm');\n *   $scope.customQuery = $mdMedia('(min-width: 1234px)');\n *   $scope.anotherCustom = $mdMedia('max-width: 300px');\n * });\n * </hljs>\n */\n\nfunction mdMediaFactory($mdConstant, $rootScope, $window) {\n  var queries = {};\n  var mqls = {};\n  var results = {};\n  var normalizeCache = {};\n\n  $mdMedia.getResponsiveAttribute = getResponsiveAttribute;\n  $mdMedia.getQuery = getQuery;\n  $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;\n\n  return $mdMedia;\n\n  function $mdMedia(query) {\n    var validated = queries[query];\n    if (angular.isUndefined(validated)) {\n      validated = queries[query] = validate(query);\n    }\n\n    var result = results[validated];\n    if (angular.isUndefined(result)) {\n      result = add(validated);\n    }\n\n    return result;\n  }\n\n  function validate(query) {\n    return $mdConstant.MEDIA[query] ||\n           ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);\n  }\n\n  function add(query) {\n    var result = mqls[query] = $window.matchMedia(query);\n    result.addListener(onQueryChange);\n    return (results[result.media] = !!result.matches);\n  }\n\n  function onQueryChange(query) {\n    $rootScope.$evalAsync(function() {\n      results[query.media] = !!query.matches;\n    });\n  }\n\n  function getQuery(name) {\n    return mqls[name];\n  }\n\n  function getResponsiveAttribute(attrs, attrName) {\n    for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {\n      var mediaName = $mdConstant.MEDIA_PRIORITY[i];\n      if (!mqls[queries[mediaName]].matches) {\n        continue;\n      }\n\n      var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n      if (attrs[normalizedName]) {\n        return attrs[normalizedName];\n      }\n    }\n\n    // fallback on unprefixed\n    return attrs[getNormalizedName(attrs, attrName)];\n  }\n\n  function watchResponsiveAttributes(attrNames, attrs, watchFn) {\n    var unwatchFns = [];\n    attrNames.forEach(function(attrName) {\n      var normalizedName = getNormalizedName(attrs, attrName);\n      if (attrs[normalizedName]) {\n        unwatchFns.push(\n            attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));\n      }\n\n      for (var mediaName in $mdConstant.MEDIA) {\n        normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n        if (!attrs[normalizedName]) {\n          return;\n        }\n\n        unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));\n      }\n    });\n\n    return function unwatch() {\n      unwatchFns.forEach(function(fn) { fn(); })\n    };\n  }\n\n  // Improves performance dramatically\n  function getNormalizedName(attrs, attrName) {\n    return normalizeCache[attrName] ||\n        (normalizeCache[attrName] = attrs.$normalize(attrName));\n  }\n}\nmdMediaFactory.$inject = [\"$mdConstant\", \"$rootScope\", \"$window\"];\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * This var has to be outside the angular factory, otherwise when\n * there are multiple material apps on the same page, each app\n * will create its own instance of this array and the app's IDs\n * will not be unique.\n */\nvar nextUniqueId = 0;\n\nangular.module('material.core')\n.factory('$mdUtil', [\"$cacheFactory\", \"$document\", \"$timeout\", \"$q\", \"$window\", \"$mdConstant\", function($cacheFactory, $document, $timeout, $q, $window, $mdConstant) {\n  var Util;\n\n  function getNode(el) {\n    return el[0] || el;\n  }\n\n  return Util = {\n    now: window.performance ?\n      angular.bind(window.performance, window.performance.now) :\n      Date.now,\n\n    clientRect: function(element, offsetParent, isOffsetRect) {\n      var node = getNode(element);\n      offsetParent = getNode(offsetParent || node.offsetParent || document.body);\n      var nodeRect = node.getBoundingClientRect();\n\n      // The user can ask for an offsetRect: a rect relative to the offsetParent,\n      // or a clientRect: a rect relative to the page\n      var offsetRect = isOffsetRect ?\n        offsetParent.getBoundingClientRect() :\n        { left: 0, top: 0, width: 0, height: 0 };\n      return {\n        left: nodeRect.left - offsetRect.left,\n        top: nodeRect.top - offsetRect.top,\n        width: nodeRect.width,\n        height: nodeRect.height\n      };\n    },\n    offsetRect: function(element, offsetParent) {\n      return Util.clientRect(element, offsetParent, true);\n    },\n\n    // Annoying method to copy nodes to an array, thanks to IE\n    nodesToArray: function (nodes) {\n      var results = [];\n      for (var i = 0; i < nodes.length; ++i) {\n        results.push(nodes.item(i));\n      }\n      return results;\n    },\n\n    // Disables scroll around the passed element.\n    disableScrollAround: function(element) {\n      if (Util.disableScrollAround._enableScrolling) return Util.disableScrollAround._enableScrolling;\n      element = angular.element(element);\n      var body = $document[0].body,\n          restoreBody = disableBodyScroll(),\n          restoreElement = disableElementScroll();\n\n      return Util.disableScrollAround._enableScrolling = function () {\n        restoreBody();\n        restoreElement();\n        delete Util.disableScrollAround._enableScrolling;\n      };\n\n      // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events\n      function disableElementScroll() {\n        var zIndex = $window.getComputedStyle(element[0]).zIndex - 1;\n        if (isNaN(zIndex)) zIndex = 99;\n        var scrollMask = angular.element(\n            '<div class=\"md-scroll-mask\" style=\"z-index: ' + zIndex + '\">' +\n            '  <div class=\"md-scroll-mask-bar\"></div>' +\n            '</div>');\n        body.appendChild(scrollMask[0]);\n\n        scrollMask.on('wheel', preventDefault);\n        scrollMask.on('touchmove', preventDefault);\n        $document.on('keydown', disableKeyNav);\n\n        return function restoreScroll () {\n          scrollMask.off('wheel');\n          scrollMask.off('touchmove');\n          scrollMask[0].parentNode.removeChild(scrollMask[0]);\n          $document.off('keydown', disableKeyNav);\n          delete Util.disableScrollAround._enableScrolling;\n        };\n\n        // Prevent keypresses from elements inside the body\n        // used to stop the keypresses that could cause the page to scroll\n        // (arrow keys, spacebar, tab, etc).\n        function disableKeyNav(e) {\n          //-- temporarily removed this logic, will possibly re-add at a later date\n          return;\n          if (!element[0].contains(e.target)) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          }\n        }\n\n        function preventDefault(e) {\n          e.preventDefault();\n        }\n      }\n\n      // Converts the body to a position fixed block and translate it to the proper scroll\n      // position\n      function disableBodyScroll() {\n        var restoreStyle = body.getAttribute('style') || '';\n        var scrollOffset = body.scrollTop + body.parentElement.scrollTop;\n\n        applyStyles(body, {\n          position: 'fixed',\n          width: '100%',\n          overflowY: 'scroll',\n          top: -scrollOffset + 'px'\n        });\n\n        return function restoreScroll() {\n          body.setAttribute('style', restoreStyle);\n          body.scrollTop = scrollOffset;\n        };\n      }\n\n      function applyStyles (el, styles) {\n        for (var key in styles) {\n          el.style[key] = styles[key];\n        }\n      }\n    },\n    enableScrolling: function () {\n      var method = this.disableScrollAround._enableScrolling;\n      method && method();\n    },\n    floatingScrollbars: function() {\n      if (this.floatingScrollbars.cached === undefined) {\n        var tempNode = angular.element('<div style=\"width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll\"><div style=\"height: 60;\"></div></div>');\n        $document[0].body.appendChild(tempNode[0]);\n        this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);\n        tempNode.remove();\n      }\n      return this.floatingScrollbars.cached;\n    },\n\n    // Mobile safari only allows you to set focus in click event listeners...\n    forceFocus: function(element) {\n      var node = element[0] || element;\n\n      document.addEventListener('click', function focusOnClick(ev) {\n        if (ev.target === node && ev.$focus) {\n          node.focus();\n          ev.stopImmediatePropagation();\n          ev.preventDefault();\n          node.removeEventListener('click', focusOnClick);\n        }\n      }, true);\n\n      var newEvent = document.createEvent('MouseEvents');\n      newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0,\n                       false, false, false, false, 0, null);\n      newEvent.$material = true;\n      newEvent.$focus = true;\n      node.dispatchEvent(newEvent);\n    },\n\n    transitionEndPromise: function(element, opts) {\n      opts = opts || {};\n      var deferred = $q.defer();\n      element.on($mdConstant.CSS.TRANSITIONEND, finished);\n      function finished(ev) {\n        // Make sure this transitionend didn't bubble up from a child\n        if (!ev || ev.target === element[0]) {\n          element.off($mdConstant.CSS.TRANSITIONEND, finished);\n          deferred.resolve();\n        }\n      }\n      if (opts.timeout) $timeout(finished, opts.timeout);\n      return deferred.promise;\n    },\n\n    fakeNgModel: function() {\n      return {\n        $fake: true,\n        $setTouched: angular.noop,\n        $setViewValue: function(value) {\n          this.$viewValue = value;\n          this.$render(value);\n          this.$viewChangeListeners.forEach(function(cb) { cb(); });\n        },\n        $isEmpty: function(value) {\n          return ('' + value).length === 0;\n        },\n        $parsers: [],\n        $formatters: [],\n        $viewChangeListeners: [],\n        $render: angular.noop\n      };\n    },\n\n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds.\n    // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs\n    // @param invokeApply should the $timeout trigger $digest() dirty checking\n    debounce: function (func, wait, scope, invokeApply) {\n      var timer;\n\n      return function debounced() {\n        var context = scope,\n          args = Array.prototype.slice.call(arguments);\n\n        $timeout.cancel(timer);\n        timer = $timeout(function() {\n\n          timer = undefined;\n          func.apply(context, args);\n\n        }, wait || 10, invokeApply );\n      };\n    },\n\n    // Returns a function that can only be triggered every `delay` milliseconds.\n    // In other words, the function will not be called unless it has been more\n    // than `delay` milliseconds since the last call.\n    throttle: function throttle(func, delay) {\n      var recent;\n      return function throttled() {\n        var context = this;\n        var args = arguments;\n        var now = Util.now();\n\n        if (!recent || (now - recent > delay)) {\n          func.apply(context, args);\n          recent = now;\n        }\n      };\n    },\n\n    /**\n     * Measures the number of milliseconds taken to run the provided callback\n     * function. Uses a high-precision timer if available.\n     */\n    time: function time(cb) {\n      var start = Util.now();\n      cb();\n      return Util.now() - start;\n    },\n\n    /**\n     * Get a unique ID.\n     *\n     * @returns {string} an unique numeric string\n     */\n    nextUid: function() {\n      return '' + nextUniqueId++;\n    },\n\n    // Stop watchers and events from firing on a scope without destroying it,\n    // by disconnecting it from its parent and its siblings' linked lists.\n    disconnectScope: function disconnectScope(scope) {\n      if (!scope) return;\n\n      // we can't destroy the root scope or a scope that has been already destroyed\n      if (scope.$root === scope) return;\n      if (scope.$$destroyed ) return;\n\n      var parent = scope.$parent;\n      scope.$$disconnected = true;\n\n      // See Scope.$destroy\n      if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;\n      if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;\n      if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;\n      if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;\n\n      scope.$$nextSibling = scope.$$prevSibling = null;\n\n    },\n\n    // Undo the effects of disconnectScope above.\n    reconnectScope: function reconnectScope(scope) {\n      if (!scope) return;\n\n      // we can't disconnect the root node or scope already disconnected\n      if (scope.$root === scope) return;\n      if (!scope.$$disconnected) return;\n\n      var child = scope;\n\n      var parent = child.$parent;\n      child.$$disconnected = false;\n      // See Scope.$new for this logic...\n      child.$$prevSibling = parent.$$childTail;\n      if (parent.$$childHead) {\n        parent.$$childTail.$$nextSibling = child;\n        parent.$$childTail = child;\n      } else {\n        parent.$$childHead = parent.$$childTail = child;\n      }\n    },\n\n    /*\n     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName\n     *\n     * @param el Element to start walking the DOM from\n     * @param tagName Tag name to find closest to el, such as 'form'\n     */\n    getClosest: function getClosest(el, tagName, onlyParent) {\n      if (el instanceof angular.element) el = el[0];\n      tagName = tagName.toUpperCase();\n      if (onlyParent) el = el.parentNode;\n      if (!el) return null;\n      do {\n        if (el.nodeName === tagName) {\n          return el;\n        }\n      } while (el = el.parentNode);\n      return null;\n    },\n\n    /**\n     * Functional equivalent for $element.filter(‘md-bottom-sheet’)\n     * useful with interimElements where the element and its container are important...\n     */\n    extractElementByName: function (element, nodeName) {\n      for (var i = 0, len = element.length; i < len; i++) {\n        if (element[i].nodeName.toLowerCase() === nodeName){\n          return angular.element(element[i]);\n        }\n      }\n      return element;\n    },\n\n    /**\n     * Give optional properties with no value a boolean true by default\n     */\n    initOptionalProperties: function (scope, attr, defaults ) {\n       defaults = defaults || { };\n       angular.forEach(scope.$$isolateBindings, function (binding, key) {\n         if (binding.optional && angular.isUndefined(scope[key])) {\n           var hasKey = attr.hasOwnProperty(attr.$normalize(binding.attrName));\n\n           scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : hasKey;\n         }\n       });\n    }\n\n  };\n\n}]);\n\n/*\n * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.\n *\n * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.\n *\n * TODO(ajoslin): This should be added in a better place later.\n */\n\nangular.element.prototype.focus = angular.element.prototype.focus || function() {\n  if (this.length) {\n    this[0].focus();\n  }\n  return this;\n};\nangular.element.prototype.blur = angular.element.prototype.blur || function() {\n  if (this.length) {\n    this[0].blur();\n  }\n  return this;\n};\n\n})();\n(function(){\n\"use strict\";\n\n\nangular.module('material.core')\n  .service('$mdAria', AriaService);\n\n/*\n * @ngInject\n */\nfunction AriaService($$rAF, $log, $window) {\n\n  return {\n    expect: expect,\n    expectAsync: expectAsync,\n    expectWithText: expectWithText\n  };\n\n  /**\n   * Check if expected attribute has been specified on the target element or child\n   * @param element\n   * @param attrName\n   * @param {optional} defaultValue What to set the attr to if no value is found\n   */\n  function expect(element, attrName, defaultValue) {\n    var node = element[0] || element;\n\n    // if node exists and neither it nor its children have the attribute\n    if (node &&\n       ((!node.hasAttribute(attrName) ||\n        node.getAttribute(attrName).length === 0) &&\n        !childHasAttribute(node, attrName))) {\n\n      defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';\n      if (defaultValue.length) {\n        element.attr(attrName, defaultValue);\n      } else {\n        $log.warn('ARIA: Attribute \"', attrName, '\", required for accessibility, is missing on node:', node);\n      }\n\n    }\n  }\n\n  function expectAsync(element, attrName, defaultValueGetter) {\n    // Problem: when retrieving the element's contents synchronously to find the label,\n    // the text may not be defined yet in the case of a binding.\n    // There is a higher chance that a binding will be defined if we wait one frame.\n    $$rAF(function() {\n      expect(element, attrName, defaultValueGetter());\n    });\n  }\n\n  function expectWithText(element, attrName) {\n    expectAsync(element, attrName, function() {\n      return getText(element);\n    });\n  }\n\n  function getText(element) {\n    return element.text().trim();\n  }\n\n  function childHasAttribute(node, attrName) {\n    var hasChildren = node.hasChildNodes(),\n        hasAttr = false;\n\n    function isHidden(el) {\n      var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);\n      return (style.display === 'none');\n    }\n\n    if(hasChildren) {\n      var children = node.childNodes;\n      for(var i=0; i<children.length; i++){\n        var child = children[i];\n        if(child.nodeType === 1 && child.hasAttribute(attrName)) {\n          if(!isHidden(child)){\n            hasAttr = true;\n          }\n        }\n      }\n    }\n    return hasAttr;\n  }\n}\nAriaService.$inject = [\"$$rAF\", \"$log\", \"$window\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .service('$mdCompiler', mdCompilerService);\n\nfunction mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n  /* jshint validthis: true */\n\n  /*\n   * @ngdoc service\n   * @name $mdCompiler\n   * @module material.core\n   * @description\n   * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $mdCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $mdCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is \n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties: \n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function(options) {\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.  \n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function(value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    //Add the locals, which are just straight values to inject\n    //eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (templateUrl) {\n      resolve.$template = $http.get(templateUrl, {cache: $templateCache})\n        .then(function(response) {\n          return response.data;\n        });\n    } else {\n      resolve.$template = $q.when(template);\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function(locals) {\n\n      var template = transformTemplate(locals.$template);\n      var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      //Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          //Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            var ctrl = invokeCtrl();\n            //See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n          return linkFn(scope);\n        }\n      };\n    });\n\n  };\n}\nmdCompilerService.$inject = [\"$q\", \"$http\", \"$injector\", \"$compile\", \"$controller\", \"$templateCache\"];\n\n})();\n(function(){\n\"use strict\";\n\n  var HANDLERS = {};\n  /* The state of the current 'pointer'\n   * The pointer represents the state of the current touch.\n   * It contains normalized x and y coordinates from DOM events,\n   * as well as other information abstracted from the DOM.\n   */\n  var pointer, lastPointer, forceSkipClickHijack = false;\n\n  // Used to attach event listeners once when multiple ng-apps are running.\n  var isInitialized = false;\n  \n  angular\n    .module('material.core.gestures', [ ])\n    .provider('$mdGesture', MdGestureProvider)\n    .factory('$$MdGestureHandler', MdGestureHandler)\n    .run( attachToDocument );\n\n  /**\n     * @ngdoc service\n     * @name $mdGestureProvider\n     * @module material.core.gestures\n     *\n     * @description\n     * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.\n     * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile\n     * devices.\n     *\n     * <hljs lang=\"js\">\n     *   app.config(function($mdGestureProvider) {\n     *\n     *     // For mobile devices without jQuery loaded, do not\n     *     // intercept click events during the capture phase.\n     *     $mdGestureProvider.skipClickHijack();\n     *\n     *   });\n     * </hljs>\n     *\n     */\n  function MdGestureProvider() { }\n\n  MdGestureProvider.prototype = {\n\n    // Publish access to setter to configure a variable  BEFORE the\n    // $mdGesture service is instantiated...\n    skipClickHijack: function() {\n      return forceSkipClickHijack = true;\n    },\n\n    /**\n     * $get is used to build an instance of $mdGesture\n     * @ngInject\n     */\n    $get : [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\", function($$MdGestureHandler, $$rAF, $timeout) {\n         return new MdGesture($$MdGestureHandler, $$rAF, $timeout);\n    }]\n  };\n\n\n\n  /**\n   * MdGesture factory construction function\n   * @ngInject\n   */\n  function MdGesture($$MdGestureHandler, $$rAF, $timeout) {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    var isIos = userAgent.match(/ipad|iphone|ipod/i);\n    var isAndroid = userAgent.match(/android/i);\n    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\n    var self = {\n      handler: addHandler,\n      register: register,\n      // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?\n      isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack\n    };\n\n    if (self.isHijackingClicks) {\n      self.handler('click', {\n        options: {\n          maxDistance: 6\n        },\n        onEnd: function (ev, pointer) {\n          if (pointer.distance < this.state.options.maxDistance) {\n            this.dispatchEvent(ev, 'click');\n          }\n        }\n      });\n    }\n\n    /*\n     * Register an element to listen for a handler.\n     * This allows an element to override the default options for a handler.\n     * Additionally, some handlers like drag and hold only dispatch events if\n     * the domEvent happens inside an element that's registered to listen for these events.\n     *\n     * @see GestureHandler for how overriding of default options works.\n     * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horziontal: false })\n     */\n    function register(element, handlerName, options) {\n      var handler = HANDLERS[handlerName.replace(/^\\$md./, '')];\n      if (!handler) {\n        throw new Error('Failed to register element with handler ' + handlerName + '. ' +\n        'Available handlers: ' + Object.keys(HANDLERS).join(', '));\n      }\n      return handler.registerElement(element, options);\n    }\n\n    /*\n     * add a handler to $mdGesture. see below.\n     */\n    function addHandler(name, definition) {\n      var handler = new $$MdGestureHandler(name);\n      angular.extend(handler, definition);\n      HANDLERS[name] = handler;\n\n      return self;\n    }\n\n    /*\n     * Register handlers. These listen to touch/start/move events, interpret them,\n     * and dispatch gesture events depending on options & conditions. These are all\n     * instances of GestureHandler.\n     * @see GestureHandler \n     */\n    return self\n      /*\n       * The press handler dispatches an event on touchdown/touchend.\n       * It's a simple abstraction of touch/mouse/pointer start and end.\n       */\n      .handler('press', {\n        onStart: function (ev, pointer) {\n          this.dispatchEvent(ev, '$md.pressdown');\n        },\n        onEnd: function (ev, pointer) {\n          this.dispatchEvent(ev, '$md.pressup');\n        }\n      })\n\n      /*\n       * The hold handler dispatches an event if the user keeps their finger within\n       * the same <maxDistance> area for <delay> ms.\n       * The hold handler will only run if a parent of the touch target is registered\n       * to listen for hold events through $mdGesture.register()\n       */\n      .handler('hold', {\n        options: {\n          maxDistance: 6,\n          delay: 500\n        },\n        onCancel: function () {\n          $timeout.cancel(this.state.timeout);\n        },\n        onStart: function (ev, pointer) {\n          // For hold, require a parent to be registered with $mdGesture.register()\n          // Because we prevent scroll events, this is necessary.\n          if (!this.state.registeredParent) return this.cancel();\n\n          this.state.pos = {x: pointer.x, y: pointer.y};\n          this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {\n            this.dispatchEvent(ev, '$md.hold');\n            this.cancel(); //we're done!\n          }), this.state.options.delay, false);\n        },\n        onMove: function (ev, pointer) {\n          // Don't scroll while waiting for hold.\n          // If we don't preventDefault touchmove events here, Android will assume we don't\n          // want to listen to anymore touch events. It will start scrolling and stop sending\n          // touchmove events.\n          ev.preventDefault();\n\n          // If the user moves greater than <maxDistance> pixels, stop the hold timer\n          // set in onStart\n          var dx = this.state.pos.x - pointer.x;\n          var dy = this.state.pos.y - pointer.y;\n          if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {\n            this.cancel();\n          }\n        },\n        onEnd: function () {\n          this.onCancel();\n        }\n      })\n\n      /*\n       * The drag handler dispatches a drag event if the user holds and moves his finger greater than\n       * <minDistance> px in the x or y direction, depending on options.horizontal.\n       * The drag will be cancelled if the user moves his finger greater than <minDistance>*<cancelMultiplier> in\n       * the perpindicular direction. Eg if the drag is horizontal and the user moves his finger <minDistance>*<cancelMultiplier>\n       * pixels vertically, this handler won't consider the move part of a drag.\n       */\n      .handler('drag', {\n        options: {\n          minDistance: 6,\n          horizontal: true,\n          cancelMultiplier: 1.5\n        },\n        onStart: function (ev) {\n          // For drag, require a parent to be registered with $mdGesture.register()\n          if (!this.state.registeredParent) this.cancel();\n        },\n        onMove: function (ev, pointer) {\n          var shouldStartDrag, shouldCancel;\n          // Don't scroll while deciding if this touchmove qualifies as a drag event.\n          // If we don't preventDefault touchmove events here, Android will assume we don't\n          // want to listen to anymore touch events. It will start scrolling and stop sending\n          // touchmove events.\n          ev.preventDefault();\n\n          if (!this.state.dragPointer) {\n            if (this.state.options.horizontal) {\n              shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;\n              shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n            } else {\n              shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;\n              shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n            }\n\n            if (shouldStartDrag) {\n              // Create a new pointer representing this drag, starting at this point where the drag started.\n              this.state.dragPointer = makeStartPointer(ev);\n              updatePointerState(ev, this.state.dragPointer);\n              this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);\n\n            } else if (shouldCancel) {\n              this.cancel();\n            }\n          } else {\n            this.dispatchDragMove(ev);\n          }\n        },\n        // Only dispatch dragmove events every frame; any more is unnecessray\n        dispatchDragMove: $$rAF.throttle(function (ev) {\n          // Make sure the drag didn't stop while waiting for the next frame\n          if (this.state.isRunning) {\n            updatePointerState(ev, this.state.dragPointer);\n            this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);\n          }\n        }),\n        onEnd: function (ev, pointer) {\n          if (this.state.dragPointer) {\n            updatePointerState(ev, this.state.dragPointer);\n            this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);\n          }\n        }\n      })\n\n      /*\n       * The swipe handler will dispatch a swipe event if, on the end of a touch,\n       * the velocity and distance were high enough.\n       * TODO: add vertical swiping with a `horizontal` option similar to the drag handler.\n       */\n      .handler('swipe', {\n        options: {\n          minVelocity: 0.65,\n          minDistance: 10\n        },\n        onEnd: function (ev, pointer) {\n          if (Math.abs(pointer.velocityX) > this.state.options.minVelocity &&\n            Math.abs(pointer.distanceX) > this.state.options.minDistance) {\n            var eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';\n            this.dispatchEvent(ev, eventType);\n          }\n        }\n      });\n\n  }\n  MdGesture.$inject = [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\"];\n\n  /**\n   * MdGestureHandler\n   * A GestureHandler is an object which is able to dispatch custom dom events\n   * based on native dom {touch,pointer,mouse}{start,move,end} events.\n   *\n   * A gesture will manage its lifecycle through the start,move,end, and cancel\n   * functions, which are called by native dom events.\n   *\n   * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be\n   * overridden by elements registering through $mdGesture.register()\n   */\n  function GestureHandler (name) {\n    this.name = name;\n    this.state = {};\n  }\n\n  function MdGestureHandler() {\n    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\n    GestureHandler.prototype = {\n      options: {},\n      // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events\n      // differently when jQuery is loaded\n      dispatchEvent: hasJQuery ?  jQueryDispatchEvent : nativeDispatchEvent,\n\n      // These are overridden by the registered handler\n      onStart: angular.noop,\n      onMove: angular.noop,\n      onEnd: angular.noop,\n      onCancel: angular.noop,\n\n      // onStart sets up a new state for the handler, which includes options from the\n      // nearest registered parent element of ev.target.\n      start: function (ev, pointer) {\n        if (this.state.isRunning) return;\n        var parentTarget = this.getNearestParent(ev.target);\n        // Get the options from the nearest registered parent\n        var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};\n\n        this.state = {\n          isRunning: true,\n          // Override the default options with the nearest registered parent's options\n          options: angular.extend({}, this.options, parentTargetOptions),\n          // Pass in the registered parent node to the state so the onStart listener can use\n          registeredParent: parentTarget\n        };\n        this.onStart(ev, pointer);\n      },\n      move: function (ev, pointer) {\n        if (!this.state.isRunning) return;\n        this.onMove(ev, pointer);\n      },\n      end: function (ev, pointer) {\n        if (!this.state.isRunning) return;\n        this.onEnd(ev, pointer);\n        this.state.isRunning = false;\n      },\n      cancel: function (ev, pointer) {\n        this.onCancel(ev, pointer);\n        this.state = {};\n      },\n\n      // Find and return the nearest parent element that has been registered to\n      // listen for this handler via $mdGesture.register(element, 'handlerName').\n      getNearestParent: function (node) {\n        var current = node;\n        while (current) {\n          if ((current.$mdGesture || {})[this.name]) {\n            return current;\n          }\n          current = current.parentNode;\n        }\n        return null;\n      },\n\n      // Called from $mdGesture.register when an element reigsters itself with a handler.\n      // Store the options the user gave on the DOMElement itself. These options will\n      // be retrieved with getNearestParent when the handler starts.\n      registerElement: function (element, options) {\n        var self = this;\n        element[0].$mdGesture = element[0].$mdGesture || {};\n        element[0].$mdGesture[this.name] = options || {};\n        element.on('$destroy', onDestroy);\n\n        return onDestroy;\n\n        function onDestroy() {\n          delete element[0].$mdGesture[self.name];\n          element.off('$destroy', onDestroy);\n        }\n      }\n    };\n\n    return GestureHandler;\n\n    /*\n     * Dispatch an event with jQuery\n     * TODO: Make sure this sends bubbling events\n     *\n     * @param srcEvent the original DOM touch event that started this.\n     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n     * @param eventPointer the pointer object that matches this event.\n     */\n    function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {\n      eventPointer = eventPointer || pointer;\n      var eventObj = new angular.element.Event(eventType);\n\n      eventObj.$material = true;\n      eventObj.pointer = eventPointer;\n      eventObj.srcEvent = srcEvent;\n\n      angular.extend(eventObj, {\n        clientX: eventPointer.x,\n        clientY: eventPointer.y,\n        screenX: eventPointer.x,\n        screenY: eventPointer.y,\n        pageX: eventPointer.x,\n        pageY: eventPointer.y,\n        ctrlKey: srcEvent.ctrlKey,\n        altKey: srcEvent.altKey,\n        shiftKey: srcEvent.shiftKey,\n        metaKey: srcEvent.metaKey\n      });\n      angular.element(eventPointer.target).trigger(eventObj);\n    }\n\n    /*\n     * NOTE: nativeDispatchEvent is very performance sensitive.\n     * @param srcEvent the original DOM touch event that started this.\n     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n     * @param eventPointer the pointer object that matches this event.\n     */\n    function nativeDispatchEvent(srcEvent, eventType, eventPointer) {\n      eventPointer = eventPointer || pointer;\n      var eventObj;\n\n      if (eventType === 'click') {\n        eventObj = document.createEvent('MouseEvents');\n        eventObj.initMouseEvent(\n          'click', true, true, window, srcEvent.detail,\n          eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y,\n          srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey,\n          srcEvent.button, srcEvent.relatedTarget || null\n        );\n\n      } else {\n        eventObj = document.createEvent('CustomEvent');\n        eventObj.initCustomEvent(eventType, true, true, {});\n      }\n      eventObj.$material = true;\n      eventObj.pointer = eventPointer;\n      eventObj.srcEvent = srcEvent;\n      eventPointer.target.dispatchEvent(eventObj);\n    }\n\n  }\n\n  /**\n   * Attach Gestures: hook document and check shouldHijack clicks\n   * @ngInject\n   */\n  function attachToDocument( $mdGesture, $$MdGestureHandler ) {\n\n    // Polyfill document.contains for IE11.\n    // TODO: move to util\n    document.contains || (document.contains = function (node) {\n      return document.body.contains(node);\n    });\n\n    if (!isInitialized && $mdGesture.isHijackingClicks ) {\n      /*\n       * If hijack clicks is true, we preventDefault any click that wasn't\n       * sent by ngMaterial. This is because on older Android & iOS, a false, or 'ghost',\n       * click event will be sent ~400ms after a touchend event happens.\n       * The only way to know if this click is real is to prevent any normal\n       * click events, and add a flag to events sent by material so we know not to prevent those.\n       * \n       * Two exceptions to click events that should be prevented are:\n       *  - click events sent by the keyboard (eg form submit)\n       *  - events that originate from an Ionic app\n       */\n      document.addEventListener('click', function clickHijacker(ev) {\n        var isKeyClick = ev.clientX === 0 && ev.clientY === 0;\n        if (!isKeyClick && !ev.$material && !ev.isIonicTap) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }, true);\n      \n      isInitialized = true;\n    }\n\n    // Listen to all events to cover all platforms.\n    var START_EVENTS = 'mousedown touchstart pointerdown';\n    var MOVE_EVENTS = 'mousemove touchmove pointermove';\n    var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';\n\n    angular.element(document)\n      .on(START_EVENTS, gestureStart)\n      .on(MOVE_EVENTS, gestureMove)\n      .on(END_EVENTS, gestureEnd)\n      // For testing\n      .on('$$mdGestureReset', function gestureClearCache () {\n        lastPointer = pointer = null;\n      });\n\n    /*\n     * When a DOM event happens, run all registered gesture handlers' lifecycle\n     * methods which match the DOM event.\n     * Eg when a 'touchstart' event happens, runHandlers('start') will call and\n     * run `handler.cancel()` and `handler.start()` on all registered handlers.\n     */\n    function runHandlers(handlerEvent, event) {\n      var handler;\n      for (var name in HANDLERS) {\n        handler = HANDLERS[name];\n        if( handler instanceof $$MdGestureHandler ) {\n\n          if (handlerEvent === 'start') {\n            // Run cancel to reset any handlers' state\n            handler.cancel();\n          }\n          handler[handlerEvent](event, pointer);\n\n        }\n      }\n    }\n\n    /*\n     * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)\n     * If it is legitimate, we initiate the pointer state and mark the current pointer's type\n     * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events\n     * won't effect it.\n     */\n    function gestureStart(ev) {\n      // If we're already touched down, abort\n      if (pointer) return;\n\n      var now = +Date.now();\n\n      // iOS & old android bug: after a touch event, a click event is sent 350 ms later.\n      // If <400ms have passed, don't allow an event of a different type than the previous event\n      if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {\n        return;\n      }\n\n      pointer = makeStartPointer(ev);\n\n      runHandlers('start', ev);\n    }\n    /*\n     * If a move event happens of the right type, update the pointer and run all the move handlers.\n     * \"of the right type\": if a mousemove happens but our pointer started with a touch event, do nothing.\n     */\n    function gestureMove(ev) {\n      if (!pointer || !typesMatch(ev, pointer)) return;\n\n      updatePointerState(ev, pointer);\n      runHandlers('move', ev);\n    }\n    /*\n     * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as 'lastPointer'\n     */\n    function gestureEnd(ev) {\n      if (!pointer || !typesMatch(ev, pointer)) return;\n\n      updatePointerState(ev, pointer);\n      pointer.endTime = +Date.now();\n\n      runHandlers('end', ev);\n\n      lastPointer = pointer;\n      pointer = null;\n    }\n\n  }\n  attachToDocument.$inject = [\"$mdGesture\", \"$$MdGestureHandler\"];\n\n  // ********************\n  // Module Functions\n  // ********************\n\n  /*\n   * Initiate the pointer. x, y, and the pointer's type.\n   */\n  function makeStartPointer(ev) {\n    var point = getEventPoint(ev);\n    var startPointer = {\n      startTime: +Date.now(),\n      target: ev.target,\n      // 'p' for pointer events, 'm' for mouse, 't' for touch\n      type: ev.type.charAt(0)\n    };\n    startPointer.startX = startPointer.x = point.pageX;\n    startPointer.startY = startPointer.y = point.pageY;\n    return startPointer;\n  }\n\n  /*\n   * return whether the pointer's type matches the event's type.\n   * Eg if a touch event happens but the pointer has a mouse type, return false.\n   */\n  function typesMatch(ev, pointer) {\n    return ev && pointer && ev.type.charAt(0) === pointer.type;\n  }\n\n  /*\n   * Update the given pointer based upon the given DOMEvent.\n   * Distance, velocity, direction, duration, etc\n   */\n  function updatePointerState(ev, pointer) {\n    var point = getEventPoint(ev);\n    var x = pointer.x = point.pageX;\n    var y = pointer.y = point.pageY;\n\n    pointer.distanceX = x - pointer.startX;\n    pointer.distanceY = y - pointer.startY;\n    pointer.distance = Math.sqrt(\n      pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY\n    );\n\n    pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';\n    pointer.directionY = pointer.distanceY > 0 ? 'up' : pointer.distanceY < 0 ? 'down' : '';\n\n    pointer.duration = +Date.now() - pointer.startTime;\n    pointer.velocityX = pointer.distanceX / pointer.duration;\n    pointer.velocityY = pointer.distanceY / pointer.duration;\n  }\n\n  /*\n   * Normalize the point where the DOM event happened whether it's touch or mouse.\n   * @returns point event obj with pageX and pageY on it.\n   */\n  function getEventPoint(ev) {\n    ev = ev.originalEvent || ev; // support jQuery events\n    return (ev.touches && ev.touches[0]) ||\n      (ev.changedTouches && ev.changedTouches[0]) ||\n      ev;\n  }\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .provider('$$interimElement', InterimElementProvider);\n\n/*\n * @ngdoc service\n * @name $$interimElement\n * @module material.core\n *\n * @description\n *\n * Factory that contructs `$$interimElement.$service` services.\n * Used internally in material design for elements that appear on screen temporarily.\n * The service provides a promise-like API for interacting with the temporary\n * elements.\n *\n * ```js\n * app.service('$mdToast', function($$interimElement) {\n *   var $mdToast = $$interimElement(toastDefaultOptions);\n *   return $mdToast;\n * });\n * ```\n * @param {object=} defaultOptions Options used by default for the `show` method on the service.\n *\n * @returns {$$interimElement.$service}\n *\n */\n\nfunction InterimElementProvider() {\n  createInterimElementProvider.$get = InterimElementFactory;\n  InterimElementFactory.$inject = [\"$document\", \"$q\", \"$rootScope\", \"$timeout\", \"$rootElement\", \"$animate\", \"$interpolate\", \"$mdCompiler\", \"$mdTheming\"];\n  return createInterimElementProvider;\n\n  /**\n   * Returns a new provider which allows configuration of a new interimElement\n   * service. Allows configuration of default options & methods for options,\n   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)\n   */\n  function createInterimElementProvider(interimFactoryName) {\n    var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];\n\n    var customMethods = {};\n    var providerConfig = {\n      presets: {}\n    };\n\n    var provider = {\n      setDefaults: setDefaults,\n      addPreset: addPreset,\n      addMethod: addMethod,\n      $get: factory\n    };\n\n    /**\n     * all interim elements will come with the 'build' preset\n     */\n    provider.addPreset('build', {\n      methods: ['controller', 'controllerAs', 'resolve',\n        'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']\n    });\n\n    factory.$inject = [\"$$interimElement\", \"$animate\", \"$injector\"];\n    return provider;\n\n    /**\n     * Save the configured defaults to be used when the factory is instantiated\n     */\n    function setDefaults(definition) {\n      providerConfig.optionsFactory = definition.options;\n      providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);\n      return provider;\n    }\n\n    /**\n     * Add a method to the factory that isn't specific to any interim element operations\n     */\n\n    function addMethod(name, fn) {\n      customMethods[name] = fn;\n      return provider;\n    }\n\n    /**\n     * Save the configured preset to be used when the factory is instantiated\n     */\n    function addPreset(name, definition) {\n      definition = definition || {};\n      definition.methods = definition.methods || [];\n      definition.options = definition.options || function() { return {}; };\n\n      if (/^cancel|hide|show$/.test(name)) {\n        throw new Error(\"Preset '\" + name + \"' in \" + interimFactoryName + \" is reserved!\");\n      }\n      if (definition.methods.indexOf('_options') > -1) {\n        throw new Error(\"Method '_options' in \" + interimFactoryName + \" is reserved!\");\n      }\n      providerConfig.presets[name] = {\n        methods: definition.methods.concat(EXPOSED_METHODS),\n        optionsFactory: definition.options,\n        argOption: definition.argOption\n      };\n      return provider;\n    }\n\n    /**\n     * Create a factory that has the given methods & defaults implementing interimElement\n     */\n    /* @ngInject */\n    function factory($$interimElement, $animate, $injector) {\n      var defaultMethods;\n      var defaultOptions;\n      var interimElementService = $$interimElement();\n\n      /*\n       * publicService is what the developer will be using.\n       * It has methods hide(), cancel(), show(), build(), and any other\n       * presets which were set during the config phase.\n       */\n      var publicService = {\n        hide: interimElementService.hide,\n        cancel: interimElementService.cancel,\n        show: showInterimElement\n      };\n\n      defaultMethods = providerConfig.methods || [];\n      // This must be invoked after the publicService is initialized\n      defaultOptions = invokeFactory(providerConfig.optionsFactory, {});\n\n      // Copy over the simple custom methods\n      angular.forEach(customMethods, function(fn, name) {\n        publicService[name] = fn;\n      });\n\n      angular.forEach(providerConfig.presets, function(definition, name) {\n        var presetDefaults = invokeFactory(definition.optionsFactory, {});\n        var presetMethods = (definition.methods || []).concat(defaultMethods);\n\n        // Every interimElement built with a preset has a field called `$type`,\n        // which matches the name of the preset.\n        // Eg in preset 'confirm', options.$type === 'confirm'\n        angular.extend(presetDefaults, { $type: name });\n\n        // This creates a preset class which has setter methods for every\n        // method given in the `.addPreset()` function, as well as every\n        // method given in the `.setDefaults()` function.\n        //\n        // @example\n        // .setDefaults({\n        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],\n        //   options: dialogDefaultOptions\n        // })\n        // .addPreset('alert', {\n        //   methods: ['title', 'ok'],\n        //   options: alertDialogOptions\n        // })\n        //\n        // Set values will be passed to the options when interimElemnt.show() is called.\n        function Preset(opts) {\n          this._options = angular.extend({}, presetDefaults, opts);\n        }\n        angular.forEach(presetMethods, function(name) {\n          Preset.prototype[name] = function(value) {\n            this._options[name] = value;\n            return this;\n          };\n        });\n\n        // Create shortcut method for one-linear methods\n        if (definition.argOption) {\n          var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);\n          publicService[methodName] = function(arg) {\n            var config = publicService[name](arg);\n            return publicService.show(config);\n          };\n        }\n\n        // eg $mdDialog.alert() will return a new alert preset\n        publicService[name] = function(arg) {\n          // If argOption is supplied, eg `argOption: 'content'`, then we assume\n          // if the argument is not an options object then it is the `argOption` option.\n          //\n          // @example `$mdToast.simple('hello')` // sets options.content to hello\n          //                                     // because argOption === 'content'\n          if (arguments.length && definition.argOption && !angular.isObject(arg) &&\n              !angular.isArray(arg)) {\n            return (new Preset())[definition.argOption](arg);\n          } else {\n            return new Preset(arg);\n          }\n\n        };\n      });\n\n      return publicService;\n\n      function showInterimElement(opts) {\n        // opts is either a preset which stores its options on an _options field,\n        // or just an object made up of options\n        if (opts && opts._options) opts = opts._options;\n        return interimElementService.show(\n          angular.extend({}, defaultOptions, opts)\n        );\n      }\n\n      /**\n       * Helper to call $injector.invoke with a local of the factory name for\n       * this provider.\n       * If an $mdDialog is providing options for a dialog and tries to inject\n       * $mdDialog, a circular dependency error will happen.\n       * We get around that by manually injecting $mdDialog as a local.\n       */\n      function invokeFactory(factory, defaultVal) {\n        var locals = {};\n        locals[interimFactoryName] = publicService;\n        return $injector.invoke(factory || function() { return defaultVal; }, {}, locals);\n      }\n\n    }\n\n  }\n\n  /* @ngInject */\n  function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate,\n                                 $interpolate, $mdCompiler, $mdTheming ) {\n    var startSymbol = $interpolate.startSymbol(),\n        endSymbol = $interpolate.endSymbol(),\n        usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}')),\n        processTemplate  = usesStandardSymbols ? angular.identity : replaceInterpolationSymbols;\n\n    return function createInterimElementService() {\n      /*\n       * @ngdoc service\n       * @name $$interimElement.$service\n       *\n       * @description\n       * A service used to control inserting and removing an element into the DOM.\n       *\n       */\n      var stack = [];\n      var service;\n      return service = {\n        show: show,\n        hide: hide,\n        cancel: cancel\n      };\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#show\n       * @kind function\n       *\n       * @description\n       * Adds the `$interimElement` to the DOM and returns a promise that will be resolved or rejected\n       * with hide or cancel, respectively.\n       *\n       * @param {*} options is hashMap of settings\n       * @returns a Promise\n       *\n       */\n      function show(options) {\n        if (stack.length) {\n          return service.cancel().then(function() {\n            return show(options);\n          });\n        } else {\n          var interimElement = new InterimElement(options);\n          stack.push(interimElement);\n          return interimElement.show().then(function() {\n            return interimElement.deferred.promise;\n          });\n        }\n      }\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#hide\n       * @kind function\n       *\n       * @description\n       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`\n       *\n       * @param {*} resolveParam Data to resolve the promise with\n       * @returns a Promise that will be resolved after the element has been removed.\n       *\n       */\n      function hide(response) {\n        var interimElement = stack.shift();\n        return interimElement && interimElement.remove().then(function() {\n          interimElement.deferred.resolve(response);\n        });\n      }\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#cancel\n       * @kind function\n       *\n       * @description\n       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`\n       *\n       * @param {*} reason Data to reject the promise with\n       * @returns Promise that will be resolved after the element has been removed.\n       *\n       */\n      function cancel(reason) {\n        var interimElement = stack.shift();\n        return $q.when(interimElement && interimElement.remove().then(function() {\n          interimElement.deferred.reject(reason);\n        }));\n      }\n\n\n      /*\n       * Internal Interim Element Object\n       * Used internally to manage the DOM element and related data\n       */\n      function InterimElement(options) {\n        var self;\n        var hideTimeout, element, showDone, removeDone;\n\n        options = options || {};\n        options = angular.extend({\n          preserveScope: false,\n          scope: options.scope || $rootScope.$new(options.isolateScope),\n          onShow: function(scope, element, options) {\n            return $animate.enter(element, options.parent);\n          },\n          onRemove: function(scope, element, options) {\n            // Element could be undefined if a new element is shown before\n            // the old one finishes compiling.\n            return element && $animate.leave(element) || $q.when();\n          }\n        }, options);\n\n        if (options.template) {\n          options.template = processTemplate(options.template);\n        }\n\n        return self = {\n          options: options,\n          deferred: $q.defer(),\n          show: function() {\n            var compilePromise;\n            if (options.skipCompile) {\n              compilePromise = $q(function(resolve) { \n                resolve({\n                  locals: {},\n                  link: function() { return options.element; }\n                });\n              });\n            } else {\n              compilePromise = $mdCompiler.compile(options);\n            }\n\n            return showDone = compilePromise.then(function(compileData) {\n              angular.extend(compileData.locals, self.options);\n\n              element = compileData.link(options.scope);\n\n              // Search for parent at insertion time, if not specified\n              if (angular.isFunction(options.parent)) {\n                options.parent = options.parent(options.scope, element, options);\n              } else if (angular.isString(options.parent)) {\n                options.parent = angular.element($document[0].querySelector(options.parent));\n              }\n\n              // If parent querySelector/getter function fails, or it's just null,\n              // find a default.\n              if (!(options.parent || {}).length) {\n                var el;\n                if ($rootElement[0] && $rootElement[0].querySelector) {\n                  el = $rootElement[0].querySelector(':not(svg) > body');\n                }\n                if (!el) el = $rootElement[0];\n                if (el.nodeName == '#comment') {\n                  el = $document[0].body;\n                }\n                options.parent = angular.element(el);\n              }\n\n              if (options.themable) $mdTheming(element);\n              var ret = options.onShow(options.scope, element, options);\n              return $q.when(ret)\n                .then(function(){\n                  // Issue onComplete callback when the `show()` finishes\n                  (options.onComplete || angular.noop)(options.scope, element, options);\n                  startHideTimeout();\n                });\n\n              function startHideTimeout() {\n                if (options.hideDelay) {\n                  hideTimeout = $timeout(service.cancel, options.hideDelay) ;\n                }\n              }\n            }, function(reason) { showDone = true; self.deferred.reject(reason); });\n          },\n          cancelTimeout: function() {\n            if (hideTimeout) {\n              $timeout.cancel(hideTimeout);\n              hideTimeout = undefined;\n            }\n          },\n          remove: function() {\n            self.cancelTimeout();\n            return removeDone = $q.when(showDone).then(function() {\n              var ret = element ? options.onRemove(options.scope, element, options) : true;\n              return $q.when(ret).then(function() {\n                if (!options.preserveScope) options.scope.$destroy();\n                removeDone = true;\n              });\n            });\n          }\n        };\n      }\n    };\n\n    /*\n     * Replace `{{` and `}}` in a string (usually a template) with the actual start-/endSymbols used\n     * for interpolation. This allows pre-defined templates (for components such as dialog, toast etc)\n     * to continue to work in apps that use custom interpolation start-/endSymbols.\n     *\n     * @param {string} text The text in which to replace `{{` / `}}`\n     * @returns {string} The modified string using the actual interpolation start-/endSymbols\n     */\n    function replaceInterpolationSymbols(text) {\n      if (!text || !angular.isString(text)) return text;\n      return text.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n    }\n  }\n\n}\n\n})();\n(function(){\n\"use strict\";\n\n  /**\n   * @ngdoc module\n   * @name material.core.componentRegistry\n   *\n   * @description\n   * A component instance registration service.\n   * Note: currently this as a private service in the SideNav component.\n   */\n  angular.module('material.core')\n    .factory('$mdComponentRegistry', ComponentRegistry);\n\n  /*\n   * @private\n   * @ngdoc factory\n   * @name ComponentRegistry\n   * @module material.core.componentRegistry\n   *\n   */\n  function ComponentRegistry($log, $q) {\n\n    var self;\n    var instances = [ ];\n    var pendings = { };\n\n    return self = {\n      /**\n       * Used to print an error when an instance for a handle isn't found.\n       */\n      notFoundError: function(handle) {\n        $log.error('No instance found for handle', handle);\n      },\n      /**\n       * Return all registered instances as an array.\n       */\n      getInstances: function() {\n        return instances;\n      },\n\n      /**\n       * Get a registered instance.\n       * @param handle the String handle to look up for a registered instance.\n       */\n      get: function(handle) {\n        if ( !isValidID(handle) ) return null;\n\n        var i, j, instance;\n        for(i = 0, j = instances.length; i < j; i++) {\n          instance = instances[i];\n          if(instance.$$mdHandle === handle) {\n            return instance;\n          }\n        }\n        return null;\n      },\n\n      /**\n       * Register an instance.\n       * @param instance the instance to register\n       * @param handle the handle to identify the instance under.\n       */\n      register: function(instance, handle) {\n        if ( !handle ) return angular.noop;\n\n        instance.$$mdHandle = handle;\n        instances.push(instance);\n        resolveWhen();\n\n        return deregister;\n\n        /**\n         * Remove registration for an instance\n         */\n        function deregister() {\n          var index = instances.indexOf(instance);\n          if (index !== -1) {\n            instances.splice(index, 1);\n          }\n        }\n\n        /**\n         * Resolve any pending promises for this instance\n         */\n        function resolveWhen() {\n          var dfd = pendings[handle];\n          if ( dfd ) {\n            dfd.resolve( instance );\n            delete pendings[handle];\n          }\n        }\n      },\n\n      /**\n       * Async accessor to registered component instance\n       * If not available then a promise is created to notify\n       * all listeners when the instance is registered.\n       */\n      when : function(handle) {\n        if ( isValidID(handle) ) {\n          var deferred = $q.defer();\n          var instance = self.get(handle);\n\n          if ( instance )  {\n            deferred.resolve( instance );\n          } else {\n            pendings[handle] = deferred;\n          }\n\n          return deferred.promise;\n        }\n        return $q.reject(\"Invalid `md-component-id` value.\");\n      }\n\n    };\n\n    function isValidID(handle){\n      return handle && (handle !== \"\");\n    }\n\n  }\n  ComponentRegistry.$inject = [\"$log\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  /**\n   * @ngdoc service\n   * @name $mdButtonInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdButtonInkRipple', MdButtonInkRipple);\n\n  function MdButtonInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      var elementOptions = optionsForElement(element);\n      return $mdInkRipple.attach(scope, element, angular.extend(elementOptions, options));\n    };\n\n    function optionsForElement(element) {\n      if (element.hasClass('md-icon-button')) {\n        return {\n          isMenuItem: element.hasClass('md-menu-item'),\n          fitRipple: true,\n          center: true\n        };\n      } else {\n        return {\n          isMenuItem: element.hasClass('md-menu-item'),\n          dimBackground: true\n        }\n      }\n    };\n  }\n  MdButtonInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n    /**\n   * @ngdoc service\n   * @name $mdCheckboxInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);\n\n  function MdCheckboxInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: true,\n        dimBackground: false,\n        fitRipple: true\n      }, options));\n    };\n  }\n  MdCheckboxInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  /**\n   * @ngdoc service\n   * @name $mdListInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdListInkRipple', MdListInkRipple);\n\n  function MdListInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: false,\n        dimBackground: true,\n        outline: false,\n        rippleSize: 'full'\n      }, options));\n    };\n  }\n  MdListInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .factory('$mdInkRipple', InkRippleService)\n  .directive('mdInkRipple', InkRippleDirective)\n  .directive('mdNoInk', attrNoDirective())\n  .directive('mdNoBar', attrNoDirective())\n  .directive('mdNoStretch', attrNoDirective());\n\nfunction InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {\n  return {\n    controller: angular.noop,\n    link: function (scope, element, attr) {\n      if (attr.hasOwnProperty('mdInkRippleCheckbox')) {\n        $mdCheckboxInkRipple.attach(scope, element);\n      } else {\n        $mdButtonInkRipple.attach(scope, element);\n      }\n    }\n  };\n}\nInkRippleDirective.$inject = [\"$mdButtonInkRipple\", \"$mdCheckboxInkRipple\"];\n\nfunction InkRippleService($window, $timeout) {\n\n  return {\n    attach: attach\n  };\n\n  function attach(scope, element, options) {\n    if (element.controller('mdNoInk')) return angular.noop;\n\n    options = angular.extend({\n      colorElement: element,\n      mousedown: true,\n      hover: true,\n      focus: true,\n      center: false,\n      mousedownPauseTime: 150,\n      dimBackground: false,\n      outline: false,\n      fullRipple: true,\n      isMenuItem: false,\n      fitRipple: false\n    }, options);\n\n    var rippleSize,\n        controller = element.controller('mdInkRipple') || {},\n        counter = 0,\n        ripples = [],\n        states = [],\n        isActiveExpr = element.attr('md-highlight'),\n        isActive = false,\n        isHeld = false,\n        node = element[0],\n        rippleSizeSetting = element.attr('md-ripple-size'),\n        color = parseColor(element.attr('md-ink-ripple')) || parseColor(options.colorElement.length && $window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\n    switch (rippleSizeSetting) {\n      case 'full':\n        options.fullRipple = true;\n        break;\n      case 'partial':\n        options.fullRipple = false;\n        break;\n    }\n\n    // expose onInput for ripple testing\n    if (options.mousedown) {\n      element.on('$md.pressdown', onPressDown)\n        .on('$md.pressup', onPressUp);\n    }\n\n    controller.createRipple = createRipple;\n\n    if (isActiveExpr) {\n      scope.$watch(isActiveExpr, function watchActive(newValue) {\n        isActive = newValue;\n        if (isActive && !ripples.length) {\n          $timeout(function () { createRipple(0, 0); }, 0, false);\n        }\n        angular.forEach(ripples, updateElement);\n      });\n    }\n\n    // Publish self-detach method if desired...\n    return function detach() {\n      element.off('$md.pressdown', onPressDown)\n        .off('$md.pressup', onPressUp);\n      getRippleContainer().remove();\n    };\n\n    /**\n     * Gets the current ripple container\n     * If there is no ripple container, it creates one and returns it\n     *\n     * @returns {angular.element} ripple container element\n     */\n    function getRippleContainer() {\n      var container = element.data('$mdRippleContainer');\n      if (container) return container;\n      container = angular.element('<div class=\"md-ripple-container\">');\n      element.append(container);\n      element.data('$mdRippleContainer', container);\n      return container;\n    }\n\n    function parseColor(color) {\n      if (!color) return;\n      if (color.indexOf('rgba') === 0) return color.replace(/\\d?\\.?\\d*\\s*\\)\\s*$/, '0.1)');\n      if (color.indexOf('rgb')  === 0) return rgbToRGBA(color);\n      if (color.indexOf('#')    === 0) return hexToRGBA(color);\n\n      /**\n       * Converts a hex value to an rgba string\n       *\n       * @param {string} hex value (3 or 6 digits) to be converted\n       *\n       * @returns {string} rgba color with 0.1 alpha\n       */\n      function hexToRGBA(color) {\n        var hex = color.charAt(0) === '#' ? color.substr(1) : color,\n          dig = hex.length / 3,\n          red = hex.substr(0, dig),\n          grn = hex.substr(dig, dig),\n          blu = hex.substr(dig * 2);\n        if (dig === 1) {\n          red += red;\n          grn += grn;\n          blu += blu;\n        }\n        return 'rgba(' + parseInt(red, 16) + ',' + parseInt(grn, 16) + ',' + parseInt(blu, 16) + ',0.1)';\n      }\n\n      /**\n       * Converts rgb value to rgba string\n       *\n       * @param {string} rgb color string\n       *\n       * @returns {string} rgba color with 0.1 alpha\n       */\n      function rgbToRGBA(color) {\n        return color.replace(')', ', 0.1)').replace('(', 'a(');\n      }\n\n    }\n\n    function removeElement(elem, wait) {\n      ripples.splice(ripples.indexOf(elem), 1);\n      if (ripples.length === 0) {\n        getRippleContainer().css({ backgroundColor: '' });\n      }\n      $timeout(function () { elem.remove(); }, wait, false);\n    }\n\n    function updateElement(elem) {\n      var index = ripples.indexOf(elem),\n          state = states[index] || {},\n          elemIsActive = ripples.length > 1 ? false : isActive,\n          elemIsHeld   = ripples.length > 1 ? false : isHeld;\n      if (elemIsActive || state.animating || elemIsHeld) {\n        elem.addClass('md-ripple-visible');\n      } else if (elem) {\n        elem.removeClass('md-ripple-visible');\n        if (options.outline) {\n          elem.css({\n            width: rippleSize + 'px',\n            height: rippleSize + 'px',\n            marginLeft: (rippleSize * -1) + 'px',\n            marginTop: (rippleSize * -1) + 'px'\n          });\n        }\n        removeElement(elem, options.outline ? 450 : 650);\n      }\n    }\n\n    /**\n     * Creates a ripple at the provided coordinates\n     *\n     * @param {number} left cursor position\n     * @param {number} top cursor position\n     *\n     * @returns {angular.element} the generated ripple element\n     */\n    function createRipple(left, top) {\n\n      color = parseColor(element.attr('md-ink-ripple')) || parseColor($window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\n      var container = getRippleContainer(),\n          size = getRippleSize(left, top),\n          css = getRippleCss(size, left, top),\n          elem = getRippleElement(css),\n          index = ripples.indexOf(elem),\n          state = states[index] || {};\n\n      rippleSize = size;\n\n      state.animating = true;\n\n      $timeout(function () {\n        if (options.dimBackground) {\n          container.css({ backgroundColor: color });\n        }\n        elem.addClass('md-ripple-placed md-ripple-scaled');\n        if (options.outline) {\n          elem.css({\n            borderWidth: (size * 0.5) + 'px',\n            marginLeft: (size * -0.5) + 'px',\n            marginTop: (size * -0.5) + 'px'\n          });\n        } else {\n          elem.css({ left: '50%', top: '50%' });\n        }\n        updateElement(elem);\n        $timeout(function () {\n          state.animating = false;\n          updateElement(elem);\n        }, (options.outline ? 450 : 225), false);\n      }, 0, false);\n\n      return elem;\n\n      /**\n       * Creates the ripple element with the provided css\n       *\n       * @param {object} css properties to be applied\n       *\n       * @returns {angular.element} the generated ripple element\n       */\n      function getRippleElement(css) {\n        var elem = angular.element('<div class=\"md-ripple\" data-counter=\"' + counter++ + '\">');\n        ripples.unshift(elem);\n        states.unshift({ animating: true });\n        container.append(elem);\n        css && elem.css(css);\n        return elem;\n      }\n\n      /**\n       * Calculate the ripple size\n       *\n       * @returns {number} calculated ripple diameter\n       */\n      function getRippleSize(left, top) {\n        var width = container.prop('offsetWidth'),\n            height = container.prop('offsetHeight'),\n            multiplier, size, rect;\n        if (options.isMenuItem) {\n          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n        } else if (options.outline) {\n          rect = node.getBoundingClientRect();\n          left -= rect.left;\n          top -= rect.top;\n          width = Math.max(left, width - left);\n          height = Math.max(top, height - top);\n          size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n        } else {\n          multiplier = options.fullRipple ? 1.1 : 0.8;\n          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * multiplier;\n          if (options.fitRipple) {\n            size = Math.min(height, width, size);\n          }\n        }\n        return size;\n      }\n\n      /**\n       * Generates the ripple css\n       *\n       * @param {number} the diameter of the ripple\n       * @param {number} the left cursor offset\n       * @param {number} the top cursor offset\n       *\n       * @returns {{backgroundColor: string, borderColor: string, width: string, height: string}}\n       */\n      function getRippleCss(size, left, top) {\n        var rect = node.getBoundingClientRect(),\n            css  = {\n              backgroundColor: rgbaToRGB(color),\n              borderColor: rgbaToRGB(color),\n              width: size + 'px',\n              height: size + 'px'\n            };\n\n        if (options.outline) {\n          css.width = 0;\n          css.height = 0;\n        } else {\n          css.marginLeft = css.marginTop = (size * -0.5) + 'px';\n        }\n\n        if (options.center) {\n          css.left = css.top = '50%';\n        } else {\n          css.left = Math.round((left - rect.left) / container.prop('offsetWidth') * 100) + '%';\n          css.top = Math.round((top - rect.top) / container.prop('offsetHeight') * 100) + '%';\n        }\n\n        return css;\n\n        /**\n         * Converts rgba string to rgb, removing the alpha value\n         *\n         * @param {string} rgba color\n         *\n         * @returns {string} rgb color\n         */\n        function rgbaToRGB(color) {\n          return color.replace('rgba', 'rgb').replace(/,[^\\),]+\\)/, ')');\n        }\n      }\n    }\n\n    /**\n     * Handles user input start and stop events\n     *\n     */\n    function onPressDown(ev) {\n      if (!isRippleAllowed()) return;\n\n      createRipple(ev.pointer.x, ev.pointer.y);\n      isHeld = true;\n    }\n    function onPressUp() {\n      isHeld = false;\n      var ripple = ripples[ ripples.length - 1 ];\n      $timeout(function () { updateElement(ripple); }, 0, false);\n    }\n\n    /**\n     * Determines if the ripple is allowed\n     *\n     * @returns {boolean} true if the ripple is allowed, false if not\n     */\n    function isRippleAllowed() {\n      var parent = node.parentNode;\n      var grandparent = parent && parent.parentNode;\n      var ancestor = grandparent && grandparent.parentNode;\n      return !isDisabled(node) && !isDisabled(parent) && !isDisabled(grandparent) && !isDisabled(ancestor);\n      function isDisabled (elem) {\n        return elem && elem.hasAttribute && elem.hasAttribute('disabled');\n      }\n    }\n\n  }\n}\nInkRippleService.$inject = [\"$window\", \"$timeout\"];\n\n/**\n * noink/nobar/nostretch directive: make any element that has one of\n * these attributes be given a controller, so that other directives can\n * `require:` these and see if there is a `no<xxx>` parent attribute.\n *\n * @usage\n * <hljs lang=\"html\">\n * <parent md-no-ink>\n *   <child detect-no>\n *   </child>\n * </parent>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * myApp.directive('detectNo', function() {\n *   return {\n *     require: ['^?mdNoInk', ^?mdNoBar'],\n *     link: function(scope, element, attr, ctrls) {\n *       var noinkCtrl = ctrls[0];\n *       var nobarCtrl = ctrls[1];\n *       if (noInkCtrl) {\n *         alert(\"the md-no-ink flag has been specified on an ancestor!\");\n *       }\n *       if (nobarCtrl) {\n *         alert(\"the md-no-bar flag has been specified on an ancestor!\");\n *       }\n *     }\n *   };\n * });\n * </hljs>\n */\nfunction attrNoDirective() {\n  return function() {\n    return {\n      controller: angular.noop\n    };\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n    /**\n   * @ngdoc service\n   * @name $mdTabInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdTabInkRipple', MdTabInkRipple);\n\n  function MdTabInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: false,\n        dimBackground: true,\n        outline: false,\n        rippleSize: 'full'\n      }, options));\n    };\n  }\n  MdTabInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core.theming.palette', [])\n.constant('$mdColorPalette', {\n  'red': {\n    '50': '#ffebee',\n    '100': '#ffcdd2',\n    '200': '#ef9a9a',\n    '300': '#e57373',\n    '400': '#ef5350',\n    '500': '#f44336',\n    '600': '#e53935',\n    '700': '#d32f2f',\n    '800': '#c62828',\n    '900': '#b71c1c',\n    'A100': '#ff8a80',\n    'A200': '#ff5252',\n    'A400': '#ff1744',\n    'A700': '#d50000',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n  },\n  'pink': {\n    '50': '#fce4ec',\n    '100': '#f8bbd0',\n    '200': '#f48fb1',\n    '300': '#f06292',\n    '400': '#ec407a',\n    '500': '#e91e63',\n    '600': '#d81b60',\n    '700': '#c2185b',\n    '800': '#ad1457',\n    '900': '#880e4f',\n    'A100': '#ff80ab',\n    'A200': '#ff4081',\n    'A400': '#f50057',\n    'A700': '#c51162',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 A200 A400 A700'\n  },\n  'purple': {\n    '50': '#f3e5f5',\n    '100': '#e1bee7',\n    '200': '#ce93d8',\n    '300': '#ba68c8',\n    '400': '#ab47bc',\n    '500': '#9c27b0',\n    '600': '#8e24aa',\n    '700': '#7b1fa2',\n    '800': '#6a1b9a',\n    '900': '#4a148c',\n    'A100': '#ea80fc',\n    'A200': '#e040fb',\n    'A400': '#d500f9',\n    'A700': '#aa00ff',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200 A400 A700'\n  },\n  'deep-purple': {\n    '50': '#ede7f6',\n    '100': '#d1c4e9',\n    '200': '#b39ddb',\n    '300': '#9575cd',\n    '400': '#7e57c2',\n    '500': '#673ab7',\n    '600': '#5e35b1',\n    '700': '#512da8',\n    '800': '#4527a0',\n    '900': '#311b92',\n    'A100': '#b388ff',\n    'A200': '#7c4dff',\n    'A400': '#651fff',\n    'A700': '#6200ea',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200'\n  },\n  'indigo': {\n    '50': '#e8eaf6',\n    '100': '#c5cae9',\n    '200': '#9fa8da',\n    '300': '#7986cb',\n    '400': '#5c6bc0',\n    '500': '#3f51b5',\n    '600': '#3949ab',\n    '700': '#303f9f',\n    '800': '#283593',\n    '900': '#1a237e',\n    'A100': '#8c9eff',\n    'A200': '#536dfe',\n    'A400': '#3d5afe',\n    'A700': '#304ffe',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200 A400'\n  },\n  'blue': {\n    '50': '#e3f2fd',\n    '100': '#bbdefb',\n    '200': '#90caf9',\n    '300': '#64b5f6',\n    '400': '#42a5f5',\n    '500': '#2196f3',\n    '600': '#1e88e5',\n    '700': '#1976d2',\n    '800': '#1565c0',\n    '900': '#0d47a1',\n    'A100': '#82b1ff',\n    'A200': '#448aff',\n    'A400': '#2979ff',\n    'A700': '#2962ff',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n  },\n  'light-blue': {\n    '50': '#e1f5fe',\n    '100': '#b3e5fc',\n    '200': '#81d4fa',\n    '300': '#4fc3f7',\n    '400': '#29b6f6',\n    '500': '#03a9f4',\n    '600': '#039be5',\n    '700': '#0288d1',\n    '800': '#0277bd',\n    '900': '#01579b',\n    'A100': '#80d8ff',\n    'A200': '#40c4ff',\n    'A400': '#00b0ff',\n    'A700': '#0091ea',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900 A700',\n    'contrastStrongLightColors': '500 600 700 800 A700'\n  },\n  'cyan': {\n    '50': '#e0f7fa',\n    '100': '#b2ebf2',\n    '200': '#80deea',\n    '300': '#4dd0e1',\n    '400': '#26c6da',\n    '500': '#00bcd4',\n    '600': '#00acc1',\n    '700': '#0097a7',\n    '800': '#00838f',\n    '900': '#006064',\n    'A100': '#84ffff',\n    'A200': '#18ffff',\n    'A400': '#00e5ff',\n    'A700': '#00b8d4',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700 800'\n  },\n  'teal': {\n    '50': '#e0f2f1',\n    '100': '#b2dfdb',\n    '200': '#80cbc4',\n    '300': '#4db6ac',\n    '400': '#26a69a',\n    '500': '#009688',\n    '600': '#00897b',\n    '700': '#00796b',\n    '800': '#00695c',\n    '900': '#004d40',\n    'A100': '#a7ffeb',\n    'A200': '#64ffda',\n    'A400': '#1de9b6',\n    'A700': '#00bfa5',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700'\n  },\n  'green': {\n    '50': '#e8f5e9',\n    '100': '#c8e6c9',\n    '200': '#a5d6a7',\n    '300': '#81c784',\n    '400': '#66bb6a',\n    '500': '#4caf50',\n    '600': '#43a047',\n    '700': '#388e3c',\n    '800': '#2e7d32',\n    '900': '#1b5e20',\n    'A100': '#b9f6ca',\n    'A200': '#69f0ae',\n    'A400': '#00e676',\n    'A700': '#00c853',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700'\n  },\n  'light-green': {\n    '50': '#f1f8e9',\n    '100': '#dcedc8',\n    '200': '#c5e1a5',\n    '300': '#aed581',\n    '400': '#9ccc65',\n    '500': '#8bc34a',\n    '600': '#7cb342',\n    '700': '#689f38',\n    '800': '#558b2f',\n    '900': '#33691e',\n    'A100': '#ccff90',\n    'A200': '#b2ff59',\n    'A400': '#76ff03',\n    'A700': '#64dd17',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '800 900',\n    'contrastStrongLightColors': '800 900'\n  },\n  'lime': {\n    '50': '#f9fbe7',\n    '100': '#f0f4c3',\n    '200': '#e6ee9c',\n    '300': '#dce775',\n    '400': '#d4e157',\n    '500': '#cddc39',\n    '600': '#c0ca33',\n    '700': '#afb42b',\n    '800': '#9e9d24',\n    '900': '#827717',\n    'A100': '#f4ff81',\n    'A200': '#eeff41',\n    'A400': '#c6ff00',\n    'A700': '#aeea00',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '900',\n    'contrastStrongLightColors': '900'\n  },\n  'yellow': {\n    '50': '#fffde7',\n    '100': '#fff9c4',\n    '200': '#fff59d',\n    '300': '#fff176',\n    '400': '#ffee58',\n    '500': '#ffeb3b',\n    '600': '#fdd835',\n    '700': '#fbc02d',\n    '800': '#f9a825',\n    '900': '#f57f17',\n    'A100': '#ffff8d',\n    'A200': '#ffff00',\n    'A400': '#ffea00',\n    'A700': '#ffd600',\n    'contrastDefaultColor': 'dark'\n  },\n  'amber': {\n    '50': '#fff8e1',\n    '100': '#ffecb3',\n    '200': '#ffe082',\n    '300': '#ffd54f',\n    '400': '#ffca28',\n    '500': '#ffc107',\n    '600': '#ffb300',\n    '700': '#ffa000',\n    '800': '#ff8f00',\n    '900': '#ff6f00',\n    'A100': '#ffe57f',\n    'A200': '#ffd740',\n    'A400': '#ffc400',\n    'A700': '#ffab00',\n    'contrastDefaultColor': 'dark'\n  },\n  'orange': {\n    '50': '#fff3e0',\n    '100': '#ffe0b2',\n    '200': '#ffcc80',\n    '300': '#ffb74d',\n    '400': '#ffa726',\n    '500': '#ff9800',\n    '600': '#fb8c00',\n    '700': '#f57c00',\n    '800': '#ef6c00',\n    '900': '#e65100',\n    'A100': '#ffd180',\n    'A200': '#ffab40',\n    'A400': '#ff9100',\n    'A700': '#ff6d00',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '800 900',\n    'contrastStrongLightColors': '800 900'\n  },\n  'deep-orange': {\n    '50': '#fbe9e7',\n    '100': '#ffccbc',\n    '200': '#ffab91',\n    '300': '#ff8a65',\n    '400': '#ff7043',\n    '500': '#ff5722',\n    '600': '#f4511e',\n    '700': '#e64a19',\n    '800': '#d84315',\n    '900': '#bf360c',\n    'A100': '#ff9e80',\n    'A200': '#ff6e40',\n    'A400': '#ff3d00',\n    'A700': '#dd2c00',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100 A200',\n    'contrastStrongLightColors': '500 600 700 800 900 A400 A700'\n  },\n  'brown': {\n    '50': '#efebe9',\n    '100': '#d7ccc8',\n    '200': '#bcaaa4',\n    '300': '#a1887f',\n    '400': '#8d6e63',\n    '500': '#795548',\n    '600': '#6d4c41',\n    '700': '#5d4037',\n    '800': '#4e342e',\n    '900': '#3e2723',\n    'A100': '#d7ccc8',\n    'A200': '#bcaaa4',\n    'A400': '#8d6e63',\n    'A700': '#5d4037',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200',\n    'contrastStrongLightColors': '300 400'\n  },\n  'grey': {\n    '50': '#fafafa',\n    '100': '#f5f5f5',\n    '200': '#eeeeee',\n    '300': '#e0e0e0',\n    '400': '#bdbdbd',\n    '500': '#9e9e9e',\n    '600': '#757575',\n    '700': '#616161',\n    '800': '#424242',\n    '900': '#212121',\n    '1000': '#000000',\n    'A100': '#ffffff',\n    'A200': '#eeeeee',\n    'A400': '#bdbdbd',\n    'A700': '#616161',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '600 700 800 900'\n  },\n  'blue-grey': {\n    '50': '#eceff1',\n    '100': '#cfd8dc',\n    '200': '#b0bec5',\n    '300': '#90a4ae',\n    '400': '#78909c',\n    '500': '#607d8b',\n    '600': '#546e7a',\n    '700': '#455a64',\n    '800': '#37474f',\n    '900': '#263238',\n    'A100': '#cfd8dc',\n    'A200': '#b0bec5',\n    'A400': '#78909c',\n    'A700': '#455a64',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300',\n    'contrastStrongLightColors': '400 500'\n  }\n});\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core.theming', ['material.core.theming.palette'])\n  .directive('mdTheme', ThemingDirective)\n  .directive('mdThemable', ThemableDirective)\n  .provider('$mdTheming', ThemingProvider)\n  .run(generateThemes);\n\n/**\n * @ngdoc provider\n * @name $mdThemingProvider\n * @module material.core\n *\n * @description Provider to configure the `$mdTheming` service.\n */\n\n/**\n * @ngdoc method\n * @name $mdThemingProvider#setDefaultTheme\n * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.\n */\n\n/**\n * @ngdoc method\n * @name $mdThemingProvider#alwaysWatchTheme\n * @param {boolean} watch Whether or not to always watch themes for changes and re-apply\n * classes when they change. Default is `false`. Enabling can reduce performance.\n */\n\n/* Some Example Valid Theming Expressions\n * =======================================\n *\n * Intention group expansion: (valid for primary, accent, warn, background)\n *\n * {{primary-100}} - grab shade 100 from the primary palette\n * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7\n * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette\n * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1\n * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue\n * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules\n * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue\n * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules\n *\n * Foreground expansion: Applies rgba to black/white foreground text\n *\n * {{foreground-1}} - used for primary text\n * {{foreground-2}} - used for secondary text/divider\n * {{foreground-3}} - used for disabled text\n * {{foreground-4}} - used for dividers\n *\n */\n\n// In memory generated CSS rules; registered by theme.name\nvar GENERATED = { };\n\n// In memory storage of defined themes and color palettes (both loaded by CSS, and user specified)\nvar PALETTES;\nvar THEMES;\n\nvar DARK_FOREGROUND = {\n  name: 'dark',\n  '1': 'rgba(0,0,0,0.87)',\n  '2': 'rgba(0,0,0,0.54)',\n  '3': 'rgba(0,0,0,0.26)',\n  '4': 'rgba(0,0,0,0.12)'\n};\nvar LIGHT_FOREGROUND = {\n  name: 'light',\n  '1': 'rgba(255,255,255,1.0)',\n  '2': 'rgba(255,255,255,0.7)',\n  '3': 'rgba(255,255,255,0.3)',\n  '4': 'rgba(255,255,255,0.12)'\n};\n\nvar DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';\nvar LIGHT_SHADOW = '';\n\nvar DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');\nvar LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87');\nvar STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');\n\nvar THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];\nvar DEFAULT_COLOR_TYPE = 'primary';\n\n// A color in a theme will use these hues by default, if not specified by user.\nvar LIGHT_DEFAULT_HUES = {\n  'accent': {\n    'default': 'A200',\n    'hue-1': 'A100',\n    'hue-2': 'A400',\n    'hue-3': 'A700'\n  },\n  'background': {\n    'default': 'A100',\n    'hue-1': '300',\n    'hue-2': '800',\n    'hue-3': '900'\n  }\n};\n\nvar DARK_DEFAULT_HUES = {\n  'background': {\n    'default': '800',\n    'hue-1': '300',\n    'hue-2': '600',\n    'hue-3': '900'\n  }\n};\nTHEME_COLOR_TYPES.forEach(function(colorType) {\n  // Color types with unspecified default hues will use these default hue values\n  var defaultDefaultHues = {\n    'default': '500',\n    'hue-1': '300',\n    'hue-2': '800',\n    'hue-3': 'A100'\n  };\n  if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;\n  if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;\n});\n\nvar VALID_HUE_VALUES = [\n  '50', '100', '200', '300', '400', '500', '600',\n  '700', '800', '900', 'A100', 'A200', 'A400', 'A700'\n];\n\nfunction ThemingProvider($mdColorPalette) {\n  PALETTES = { };\n  THEMES = { };\n\n  var themingProvider;\n  var defaultTheme = 'default';\n  var alwaysWatchTheme = false;\n\n  // Load JS Defined Palettes\n  angular.extend(PALETTES, $mdColorPalette);\n\n  // Default theme defined in core.js\n\n  ThemingService.$inject = [\"$rootScope\", \"$log\"];\n  return themingProvider = {\n    definePalette: definePalette,\n    extendPalette: extendPalette,\n    theme: registerTheme,\n\n    setDefaultTheme: function(theme) {\n      defaultTheme = theme;\n    },\n    alwaysWatchTheme: function(alwaysWatch) {\n      alwaysWatchTheme = alwaysWatch;\n    },\n    $get: ThemingService,\n    _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,\n    _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,\n    _PALETTES: PALETTES,\n    _THEMES: THEMES,\n    _parseRules: parseRules,\n    _rgba: rgba\n  };\n\n  // Example: $mdThemingProvider.definePalette('neonRed', { 50: '#f5fafa', ... });\n  function definePalette(name, map) {\n    map = map || {};\n    PALETTES[name] = checkPaletteValid(name, map);\n    return themingProvider;\n  }\n\n  // Returns an new object which is a copy of a given palette `name` with variables from\n  // `map` overwritten\n  // Example: var neonRedMap = $mdThemingProvider.extendPalette('red', { 50: '#f5fafafa' });\n  function extendPalette(name, map) {\n    return checkPaletteValid(name,  angular.extend({}, PALETTES[name] || {}, map) );\n  }\n\n  // Make sure that palette has all required hues\n  function checkPaletteValid(name, map) {\n    var missingColors = VALID_HUE_VALUES.filter(function(field) {\n      return !map[field];\n    });\n    if (missingColors.length) {\n      throw new Error(\"Missing colors %1 in palette %2!\"\n                      .replace('%1', missingColors.join(', '))\n                      .replace('%2', name));\n    }\n\n    return map;\n  }\n\n  // Register a theme (which is a collection of color palettes to use with various states\n  // ie. warn, accent, primary )\n  // Optionally inherit from an existing theme\n  // $mdThemingProvider.theme('custom-theme').primaryPalette('red');\n  function registerTheme(name, inheritFrom) {\n    if (THEMES[name]) return THEMES[name];\n\n    inheritFrom = inheritFrom || 'default';\n\n    var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;\n    var theme = new Theme(name);\n\n    if (parentTheme) {\n      angular.forEach(parentTheme.colors, function(color, colorType) {\n        theme.colors[colorType] = {\n          name: color.name,\n          // Make sure a COPY of the hues is given to the child color,\n          // not the same reference.\n          hues: angular.extend({}, color.hues)\n        };\n      });\n    }\n    THEMES[name] = theme;\n\n    return theme;\n  }\n\n  function Theme(name) {\n    var self = this;\n    self.name = name;\n    self.colors = {};\n\n    self.dark = setDark;\n    setDark(false);\n\n    function setDark(isDark) {\n      isDark = arguments.length === 0 ? true : !!isDark;\n\n      // If no change, abort\n      if (isDark === self.isDark) return;\n\n      self.isDark = isDark;\n\n      self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;\n      self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;\n\n      // Light and dark themes have different default hues.\n      // Go through each existing color type for this theme, and for every\n      // hue value that is still the default hue value from the previous light/dark setting,\n      // set it to the default hue value from the new light/dark setting.\n      var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;\n      var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;\n      angular.forEach(newDefaultHues, function(newDefaults, colorType) {\n        var color = self.colors[colorType];\n        var oldDefaults = oldDefaultHues[colorType];\n        if (color) {\n          for (var hueName in color.hues) {\n            if (color.hues[hueName] === oldDefaults[hueName]) {\n              color.hues[hueName] = newDefaults[hueName];\n            }\n          }\n        }\n      });\n\n      return self;\n    }\n\n    THEME_COLOR_TYPES.forEach(function(colorType) {\n      var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];\n      self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {\n        var color = self.colors[colorType] = {\n          name: paletteName,\n          hues: angular.extend({}, defaultHues, hues)\n        };\n\n        Object.keys(color.hues).forEach(function(name) {\n          if (!defaultHues[name]) {\n            throw new Error(\"Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4\"\n              .replace('%1', name)\n              .replace('%2', self.name)\n              .replace('%3', paletteName)\n              .replace('%4', Object.keys(defaultHues).join(', '))\n            );\n          }\n        });\n        Object.keys(color.hues).map(function(key) {\n          return color.hues[key];\n        }).forEach(function(hueValue) {\n          if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {\n            throw new Error(\"Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5\"\n              .replace('%1', hueValue)\n              .replace('%2', self.name)\n              .replace('%3', colorType)\n              .replace('%4', paletteName)\n              .replace('%5', VALID_HUE_VALUES.join(', '))\n            );\n          }\n        });\n        return self;\n      };\n\n      self[colorType + 'Color'] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' +\n                     'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');\n        return self[colorType + 'Palette'].apply(self, args);\n      };\n    });\n  }\n\n  /**\n   * @ngdoc service\n   * @name $mdTheming\n   *\n   * @description\n   *\n   * Service that makes an element apply theming related classes to itself.\n   *\n   * ```js\n   * app.directive('myFancyDirective', function($mdTheming) {\n   *   return {\n   *     restrict: 'e',\n   *     link: function(scope, el, attrs) {\n   *       $mdTheming(el);\n   *     }\n   *   };\n   * });\n   * ```\n   * @param {el=} element to apply theming to\n   */\n  /* @ngInject */\n  function ThemingService($rootScope, $log) {\n\n    applyTheme.inherit = function(el, parent) {\n      var ctrl = parent.controller('mdTheme');\n\n      var attrThemeValue = el.attr('md-theme-watch');\n      if ( (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {\n        var deregisterWatch = $rootScope.$watch(function() {\n          return ctrl && ctrl.$mdTheme || defaultTheme;\n        }, changeTheme);\n        el.on('$destroy', deregisterWatch);\n      } else {\n        var theme = ctrl && ctrl.$mdTheme || defaultTheme;\n        changeTheme(theme);\n      }\n\n      function changeTheme(theme) {\n        if (!registered(theme)) {\n          $log.warn('Attempted to use unregistered theme \\'' + theme + '\\'. ' +\n                    'Register it with $mdThemingProvider.theme().');\n        }\n        var oldTheme = el.data('$mdThemeName');\n        if (oldTheme) el.removeClass('md-' + oldTheme +'-theme');\n        el.addClass('md-' + theme + '-theme');\n        el.data('$mdThemeName', theme);\n      }\n    };\n\n    applyTheme.THEMES = angular.extend({}, THEMES);\n    applyTheme.defaultTheme = function() { return defaultTheme; };\n    applyTheme.registered = registered;\n\n    return applyTheme;\n\n    function registered(themeName) {\n      if (themeName === undefined || themeName === '') return true;\n      return applyTheme.THEMES[themeName] !== undefined;\n    }\n\n    function applyTheme(scope, el) {\n      // Allow us to be invoked via a linking function signature.\n      if (el === undefined) {\n        el = scope;\n        scope = undefined;\n      }\n      if (scope === undefined) {\n        scope = $rootScope;\n      }\n      applyTheme.inherit(el, el);\n    }\n  }\n}\nThemingProvider.$inject = [\"$mdColorPalette\"];\n\nfunction ThemingDirective($mdTheming, $interpolate, $log) {\n  return {\n    priority: 100,\n    link: {\n      pre: function(scope, el, attrs) {\n        var ctrl = {\n          $setTheme: function(theme) {\n            if (!$mdTheming.registered(theme)) {\n              $log.warn('attempted to use unregistered theme \\'' + theme + '\\'');\n            }\n            ctrl.$mdTheme = theme;\n          }\n        };\n        el.data('$mdThemeController', ctrl);\n        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));\n        attrs.$observe('mdTheme', ctrl.$setTheme);\n      }\n    }\n  };\n}\nThemingDirective.$inject = [\"$mdTheming\", \"$interpolate\", \"$log\"];\n\nfunction ThemableDirective($mdTheming) {\n  return $mdTheming;\n}\nThemableDirective.$inject = [\"$mdTheming\"];\n\nfunction parseRules(theme, colorType, rules) {\n  checkValidPalette(theme, colorType);\n\n  rules = rules.replace(/THEME_NAME/g, theme.name);\n  var generatedRules = [];\n  var color = theme.colors[colorType];\n\n  var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');\n  // Matches '{{ primary-color }}', etc\n  var hueRegex = new RegExp('(\\'|\")?{{\\\\s*(' + colorType + ')-(color|contrast)-?(\\\\d\\\\.?\\\\d*)?\\\\s*}}(\\\"|\\')?','g');\n  var simpleVariableRegex = /'?\"?\\{\\{\\s*([a-zA-Z]+)-(A?\\d+|hue\\-[0-3]|shadow)-?(\\d\\.?\\d*)?\\s*\\}\\}'?\"?/g;\n  var palette = PALETTES[color.name];\n\n  // find and replace simple variables where we use a specific hue, not an entire palette\n  // eg. \"{{primary-100}}\"\n  //\\(' + THEME_COLOR_TYPES.join('\\|') + '\\)'\n  rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity) {\n    if (colorType === 'foreground') {\n      if (hue == 'shadow') {\n        return theme.foregroundShadow;\n      } else {\n        return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];\n      }\n    }\n    if (hue.indexOf('hue') === 0) {\n      hue = theme.colors[colorType].hues[hue];\n    }\n    return rgba( (PALETTES[ theme.colors[colorType].name ][hue] || '').value, opacity );\n  });\n\n  // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)\n  angular.forEach(color.hues, function(hueValue, hueName) {\n    var newRule = rules\n      .replace(hueRegex, function(match, _, colorType, hueType, opacity) {\n        return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);\n      });\n    if (hueName !== 'default') {\n      newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);\n    }\n\n    // Don't apply a selector rule to the default theme, making it easier to override\n    // styles of the base-component\n    if (theme.name == 'default') {\n      newRule = newRule.replace(/\\.md-default-theme/g, '');\n    }\n    generatedRules.push(newRule);\n  });\n\n  return generatedRules;\n}\n\n// Generate our themes at run time given the state of THEMES and PALETTES\nfunction generateThemes($injector) {\n\n  var head = document.getElementsByTagName('head')[0];\n  var firstChild = head ? head.firstElementChild : null;\n  var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';\n\n  if ( !firstChild ) return;\n  if (themeCss.length === 0) return; // no rules, so no point in running this expensive task\n\n  // Expose contrast colors for palettes to ensure that text is always readable\n  angular.forEach(PALETTES, sanitizePalette);\n\n  // MD_THEME_CSS is a string generated by the build process that includes all the themable\n  // components as templates\n\n  // Break the CSS into individual rules\n  var rulesByType = {};\n  var rules = themeCss\n                  .split(/\\}(?!(\\}|'|\"|;))/)\n                  .filter(function(rule) { return rule && rule.length; })\n                  .map(function(rule) { return rule.trim() + '}'; });\n\n\n  var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');\n\n  THEME_COLOR_TYPES.forEach(function(type) {\n    rulesByType[type] = '';\n  });\n\n\n  // Sort the rules based on type, allowing us to do color substitution on a per-type basis\n  rules.forEach(function(rule) {\n    var match = rule.match(ruleMatchRegex);\n    // First: test that if the rule has '.md-accent', it goes into the accent set of rules\n    for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {\n      if (rule.indexOf('.md-' + type) > -1) {\n        return rulesByType[type] += rule;\n      }\n    }\n\n    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from\n    // there\n    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {\n      if (rule.indexOf(type) > -1) {\n        return rulesByType[type] += rule;\n      }\n    }\n\n    // Default to the primary array\n    return rulesByType[DEFAULT_COLOR_TYPE] += rule;\n  });\n\n    // For each theme, use the color palettes specified for\n    // `primary`, `warn` and `accent` to generate CSS rules.\n\n    angular.forEach(THEMES, function(theme) {\n      if ( !GENERATED[theme.name] ) {\n\n\n        THEME_COLOR_TYPES.forEach(function(colorType) {\n          var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);\n          while (styleStrings.length) {\n            var style = document.createElement('style');\n                style.setAttribute('type', 'text/css');\n            style.appendChild(document.createTextNode(styleStrings.shift()));\n            head.insertBefore(style, firstChild);\n          }\n        });\n\n\n        if (theme.colors.primary.name == theme.colors.accent.name) {\n          console.warn(\"$mdThemingProvider: Using the same palette for primary and\" +\n                       \" accent. This violates the material design spec.\");\n        }\n\n        GENERATED[theme.name] = true;\n      }\n    });\n\n\n  // *************************\n  // Internal functions\n  // *************************\n\n  // The user specifies a 'default' contrast color as either light or dark,\n  // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)\n  function sanitizePalette(palette) {\n    var defaultContrast = palette.contrastDefaultColor;\n    var lightColors = palette.contrastLightColors || [];\n    var strongLightColors = palette.contrastStrongLightColors || [];\n    var darkColors = palette.contrastDarkColors || [];\n\n    // These colors are provided as space-separated lists\n    if (typeof lightColors === 'string') lightColors = lightColors.split(' ');\n    if (typeof strongLightColors === 'string') strongLightColors = strongLightColors.split(' ');\n    if (typeof darkColors === 'string') darkColors = darkColors.split(' ');\n\n    // Cleanup after ourselves\n    delete palette.contrastDefaultColor;\n    delete palette.contrastLightColors;\n    delete palette.contrastStrongLightColors;\n    delete palette.contrastDarkColors;\n\n    // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }\n    angular.forEach(palette, function(hueValue, hueName) {\n      if (angular.isObject(hueValue)) return; // Already converted\n      // Map everything to rgb colors\n      var rgbValue = colorToRgbaArray(hueValue);\n      if (!rgbValue) {\n        throw new Error(\"Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.\"\n                        .replace('%1', hueValue)\n                        .replace('%2', palette.name)\n                        .replace('%3', hueName));\n      }\n\n      palette[hueName] = {\n        value: rgbValue,\n        contrast: getContrastColor()\n      };\n      function getContrastColor() {\n        if (defaultContrast === 'light') {\n          if (darkColors.indexOf(hueName) > -1) {\n            return DARK_CONTRAST_COLOR;\n          } else {\n            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n              : LIGHT_CONTRAST_COLOR;\n          }\n        } else {\n          if (lightColors.indexOf(hueName) > -1) {\n            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n              : LIGHT_CONTRAST_COLOR;\n          } else {\n            return DARK_CONTRAST_COLOR;\n          }\n        }\n      }\n    });\n  }\n\n\n}\ngenerateThemes.$inject = [\"$injector\"];\n\nfunction checkValidPalette(theme, colorType) {\n  // If theme attempts to use a palette that doesnt exist, throw error\n  if (!PALETTES[ (theme.colors[colorType] || {}).name ]) {\n    throw new Error(\n      \"You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3\"\n                    .replace('%1', theme.name)\n                    .replace('%2', colorType)\n                    .replace('%3', Object.keys(PALETTES).join(', '))\n    );\n  }\n}\n\nfunction colorToRgbaArray(clr) {\n  if (angular.isArray(clr) && clr.length == 3) return clr;\n  if (/^rgb/.test(clr)) {\n    return clr.replace(/(^\\s*rgba?\\(|\\)\\s*$)/g, '').split(',').map(function(value, i) {\n      return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);\n    });\n  }\n  if (clr.charAt(0) == '#') clr = clr.substring(1);\n  if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;\n\n  var dig = clr.length / 3;\n  var red = clr.substr(0, dig);\n  var grn = clr.substr(dig, dig);\n  var blu = clr.substr(dig * 2);\n  if (dig === 1) {\n    red += red;\n    grn += grn;\n    blu += blu;\n  }\n  return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];\n}\n\nfunction rgba(rgbArray, opacity) {\n  if ( !rgbArray ) return \"rgb('0,0,0')\";\n\n  if (rgbArray.length == 4) {\n    rgbArray = angular.copy(rgbArray);\n    opacity ? rgbArray.pop() : opacity = rgbArray.pop();\n  }\n  return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ?\n    'rgba(' + rgbArray.join(',') + ',' + opacity + ')' :\n    'rgb(' + rgbArray.join(',') + ')';\n}\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.autocomplete\n */\n/*\n * @see js folder for autocomplete implementation\n */\nangular.module('material.components.autocomplete', [\n  'material.core',\n  'material.components.icon'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * @ngdoc module\n * @name material.components.backdrop\n * @description Backdrop\n */\n\n/**\n * @ngdoc directive\n * @name mdBackdrop\n * @module material.components.backdrop\n *\n * @restrict E\n *\n * @description\n * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.\n * Apply class `opaque` to make the backdrop use the theme backdrop color.\n *\n */\n\nangular.module('material.components.backdrop', [\n  'material.core'\n])\n  .directive('mdBackdrop', BackdropDirective);\n\nfunction BackdropDirective($mdTheming) {\n  return $mdTheming;\n}\nBackdropDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.bottomSheet\n * @description\n * BottomSheet\n */\nangular.module('material.components.bottomSheet', [\n  'material.core',\n  'material.components.backdrop'\n])\n  .directive('mdBottomSheet', MdBottomSheetDirective)\n  .provider('$mdBottomSheet', MdBottomSheetProvider);\n\nfunction MdBottomSheetDirective() {\n  return {\n    restrict: 'E'\n  };\n}\n\n/**\n * @ngdoc service\n * @name $mdBottomSheet\n * @module material.components.bottomSheet\n *\n * @description\n * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.\n *\n * ## Restrictions\n *\n * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.\n * - Add the `md-grid` class to the bottom sheet for a grid layout.\n * - Add the `md-list` class to the bottom sheet for a list layout.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div ng-controller=\"MyController\">\n *   <md-button ng-click=\"openBottomSheet()\">\n *     Open a Bottom Sheet!\n *   </md-button>\n * </div>\n * </hljs>\n * <hljs lang=\"js\">\n * var app = angular.module('app', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdBottomSheet) {\n *   $scope.openBottomSheet = function() {\n *     $mdBottomSheet.show({\n *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'\n *     });\n *   };\n * });\n * </hljs>\n */\n\n /**\n * @ngdoc method\n * @name $mdBottomSheet#show\n *\n * @description\n * Show a bottom sheet with the specified options.\n *\n * @param {object} options An options object, with the following properties:\n *\n *   - `templateUrl` - `{string=}`: The url of an html template file that will\n *   be used as the content of the bottom sheet. Restrictions: the template must\n *   have an outer `md-bottom-sheet` element.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n *   template string.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.\n *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n *   be used as names of values to inject into the controller. For example,\n *   `locals: {three: 3}` would inject `three` into the controller with the value\n *   of 3.\n *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n *   the location of the click will be used as the starting point for the opening animation\n *   of the the dialog.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n *   and the bottom sheet will not open until the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,\n *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.\n *   e.g. angular.element(document.getElementById('content')) or \"#content\"\n *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.\n *     Default true.\n *\n * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or\n * rejected with `$mdBottomSheet.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdBottomSheet#hide\n *\n * @description\n * Hide the existing bottom sheet and resolve the promise returned from\n * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if any).\n *\n * @param {*=} response An argument for the resolved promise.\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdBottomSheet#cancel\n *\n * @description\n * Hide the existing bottom sheet and reject the promise returned from\n * `$mdBottomSheet.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n *\n */\n\nfunction MdBottomSheetProvider($$interimElementProvider) {\n  // how fast we need to flick down to close the sheet, pixels/ms\n  var CLOSING_VELOCITY = 0.5;\n  var PADDING = 80; // same as css\n\n  bottomSheetDefaults.$inject = [\"$animate\", \"$mdConstant\", \"$mdUtil\", \"$timeout\", \"$compile\", \"$mdTheming\", \"$mdBottomSheet\", \"$rootElement\", \"$mdGesture\"];\n  return $$interimElementProvider('$mdBottomSheet')\n    .setDefaults({\n      methods: ['disableParentScroll', 'escapeToClose', 'targetEvent'],\n      options: bottomSheetDefaults\n    });\n\n  /* @ngInject */\n  function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $timeout, $compile, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {\n    var backdrop;\n\n    return {\n      themable: true,\n      targetEvent: null,\n      onShow: onShow,\n      onRemove: onRemove,\n      escapeToClose: true,\n      disableParentScroll: true\n    };\n\n\n    function onShow(scope, element, options) {\n\n      element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');\n\n      // Add a backdrop that will close on click\n      backdrop = $compile('<md-backdrop class=\"md-opaque md-bottom-sheet-backdrop\">')(scope);\n      backdrop.on('click', function() {\n        $timeout($mdBottomSheet.cancel);\n      });\n      $mdTheming.inherit(backdrop, options.parent);\n\n      $animate.enter(backdrop, options.parent, null);\n\n      var bottomSheet = new BottomSheet(element, options.parent);\n      options.bottomSheet = bottomSheet;\n\n      // Give up focus on calling item\n      options.targetEvent && angular.element(options.targetEvent.target).blur();\n      $mdTheming.inherit(bottomSheet.element, options.parent);\n\n      if (options.disableParentScroll) {\n        options.lastOverflow = options.parent.css('overflow');\n        options.parent.css('overflow', 'hidden');\n      }\n\n      return $animate.enter(bottomSheet.element, options.parent)\n        .then(function() {\n          var focusable = angular.element(\n            element[0].querySelector('button') ||\n            element[0].querySelector('a') ||\n            element[0].querySelector('[ng-click]')\n          );\n          focusable.focus();\n\n          if (options.escapeToClose) {\n            options.rootElementKeyupCallback = function(e) {\n              if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n                $timeout($mdBottomSheet.cancel);\n              }\n            };\n            $rootElement.on('keyup', options.rootElementKeyupCallback);\n          }\n        });\n\n    }\n\n    function onRemove(scope, element, options) {\n\n      var bottomSheet = options.bottomSheet;\n\n      $animate.leave(backdrop);\n      return $animate.leave(bottomSheet.element).then(function() {\n        if (options.disableParentScroll) {\n          options.parent.css('overflow', options.lastOverflow);\n          delete options.lastOverflow;\n        }\n\n        bottomSheet.cleanup();\n\n        // Restore focus\n        options.targetEvent && angular.element(options.targetEvent.target).focus();\n      });\n    }\n\n    /**\n     * BottomSheet class to apply bottom-sheet behavior to an element\n     */\n    function BottomSheet(element, parent) {\n      var deregister = $mdGesture.register(parent, 'drag', { horizontal: false });\n      parent.on('$md.dragstart', onDragStart)\n        .on('$md.drag', onDrag)\n        .on('$md.dragend', onDragEnd);\n\n      return {\n        element: element,\n        cleanup: function cleanup() {\n          deregister();\n          parent.off('$md.dragstart', onDragStart)\n            .off('$md.drag', onDrag)\n            .off('$md.dragend', onDragEnd);\n        }\n      };\n\n      function onDragStart(ev) {\n        // Disable transitions on transform so that it feels fast\n        element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');\n      }\n\n      function onDrag(ev) {\n        var transform = ev.pointer.distanceY;\n        if (transform < 5) {\n          // Slow down drag when trying to drag up, and stop after PADDING\n          transform = Math.max(-PADDING, transform / 2);\n        }\n        element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');\n      }\n\n      function onDragEnd(ev) {\n        if (ev.pointer.distanceY > 0 &&\n            (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {\n          var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;\n          var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);\n          element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');\n          $timeout($mdBottomSheet.cancel);\n        } else {\n          element.css($mdConstant.CSS.TRANSITION_DURATION, '');\n          element.css($mdConstant.CSS.TRANSFORM, '');\n        }\n      }\n    }\n\n  }\n\n}\nMdBottomSheetProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.button\n * @description\n *\n * Button\n */\nangular\n    .module('material.components.button', [ 'material.core' ])\n    .directive('mdButton', MdButtonDirective);\n\n/**\n * @ngdoc directive\n * @name mdButton\n * @module material.components.button\n *\n * @restrict E\n *\n * @description\n * `<md-button>` is a button directive with optional ink ripples (default enabled).\n *\n * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will\n * become a `<button>` element. As per the [Material Design specifications](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the FAB button background is filled with the accent color [by default]. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {boolean=} md-no-ink If present, disable ripple ink effects.\n * @param {expression=} ng-disabled En/Disable based on the expression\n * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`\n * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.\n * If no default text is found, a warning will be logged.\n *\n * @usage\n *\n * Regular buttons:\n *\n * <hljs lang=\"html\">\n *  <md-button> Flat Button </md-button>\n *  <md-button href=\"http://google.com\"> Flat link </md-button>\n *  <md-button class=\"md-raised\"> Raised Button </md-button>\n *  <md-button ng-disabled=\"true\"> Disabled Button </md-button>\n *  <md-button>\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *    Register Now\n *  </md-button>\n * </hljs>\n *\n * FAB buttons:\n *\n * <hljs lang=\"html\">\n *  <md-button class=\"md-fab\" aria-label=\"FAB\">\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *  </md-button>\n *  <!-- mini-FAB -->\n *  <md-button class=\"md-fab md-mini\" aria-label=\"Mini FAB\">\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *  </md-button>\n *  <!-- Button with SVG Icon -->\n *  <md-button class=\"md-icon-button\" aria-label=\"Custom Icon Button\">\n *    <md-icon md-svg-icon=\"path/to/your.svg\"></md-icon>\n *  </md-button>\n * </hljs>\n */\nfunction MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {\n\n  return {\n    restrict: 'EA',\n    replace: true,\n    transclude: true,\n    template: getTemplate,\n    link: postLink\n  };\n\n  function isAnchor(attr) {\n    return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);\n  }\n\n  function getTemplate(element, attr) {\n    return isAnchor(attr) ?\n           '<a class=\"md-button\" ng-transclude></a>' :\n           '<button class=\"md-button\" ng-transclude></button>';\n  }\n\n  function postLink(scope, element, attr) {\n    var node = element[0];\n    $mdTheming(element);\n    $mdButtonInkRipple.attach(scope, element);\n\n    var elementHasText = node.textContent.trim();\n    if (!elementHasText) {\n      $mdAria.expect(element, 'aria-label');\n    }\n\n    // For anchor elements, we have to set tabindex manually when the\n    // element is disabled\n    if (isAnchor(attr) && angular.isDefined(attr.ngDisabled) ) {\n      scope.$watch(attr.ngDisabled, function(isDisabled) {\n        element.attr('tabindex', isDisabled ? -1 : 0);\n      });\n    }\n\n    // disabling click event when disabled is true\n    element.on('click', function(e){\n      if (attr.disabled === true) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n    });\n\n    // restrict focus styles to the keyboard\n    scope.mouseActive = false;\n    element.on('mousedown', function() {\n        scope.mouseActive = true;\n        $timeout(function(){\n          scope.mouseActive = false;\n        }, 100);\n      })\n      .on('focus', function() {\n        if(scope.mouseActive === false) { element.addClass('md-focused'); }\n      })\n      .on('blur', function() { element.removeClass('md-focused'); });\n  }\n\n}\nMdButtonDirective.$inject = [\"$mdButtonInkRipple\", \"$mdTheming\", \"$mdAria\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.card\n *\n * @description\n * Card components.\n */\nangular.module('material.components.card', [\n  'material.core'\n])\n  .directive('mdCard', mdCardDirective);\n\n\n\n/**\n * @ngdoc directive\n * @name mdCard\n * @module material.components.card\n *\n * @restrict E\n *\n * @description\n * The `<md-card>` directive is a container element used within `<md-content>` containers.\n *\n * An image included as a direct descendant will fill the card's width, while the `<md-card-content>`\n * container will wrap text content and provide padding. An `<md-card-footer>` element can be\n * optionally included to put content flush against the bottom edge of the card.\n *\n * Action buttons can be included in an element with the `.md-actions` class, also used in `md-dialog`.\n * You can then position buttons using layout attributes.\n *\n * Cards have constant width and variable heights; where the maximum height is limited to what can\n * fit within a single view on a platform, but it can temporarily expand as needed.\n *\n * @usage\n * ###Card with optional footer\n * <hljs lang=\"html\">\n * <md-card>\n *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n *  <md-card-content>\n *    <h2>Card headline</h2>\n *    <p>Card content</p>\n *  </md-card-content>\n *  <md-card-footer>\n *    Card footer\n *  </md-card-footer>\n * </md-card>\n * </hljs>\n *\n * ###Card with actions\n * <hljs lang=\"html\">\n * <md-card>\n *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n *  <md-card-content>\n *    <h2>Card headline</h2>\n *    <p>Card content</p>\n *  </md-card-content>\n *  <div class=\"md-actions\" layout=\"row\" layout-align=\"end center\">\n *    <md-button>Action 1</md-button>\n *    <md-button>Action 2</md-button>\n *  </div>\n * </md-card>\n * </hljs>\n *\n */\nfunction mdCardDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    link: function($scope, $element, $attr) {\n      $mdTheming($element);\n    }\n  };\n}\nmdCardDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.checkbox\n * @description Checkbox module!\n */\nangular\n  .module('material.components.checkbox', ['material.core'])\n  .directive('mdCheckbox', MdCheckboxDirective);\n\n/**\n * @ngdoc directive\n * @name mdCheckbox\n * @module material.components.checkbox\n * @restrict E\n *\n * @description\n * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the checkbox is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects\n * @param {string=} aria-label Adds label to checkbox for accessibility.\n * Defaults to checkbox's text. If no default text is found, a warning will be logged.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-checkbox ng-model=\"isChecked\" aria-label=\"Finished?\">\n *   Finished ?\n * </md-checkbox>\n *\n * <md-checkbox md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n *   No Ink Effects\n * </md-checkbox>\n *\n * <md-checkbox ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n *   Disabled\n * </md-checkbox>\n *\n * </hljs>\n *\n */\nfunction MdCheckboxDirective(inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {\n  inputDirective = inputDirective[0];\n  var CHECKED_CSS = 'md-checked';\n\n  return {\n    restrict: 'E',\n    transclude: true,\n    require: '?ngModel',\n    priority:210, // Run before ngAria\n    template: \n      '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n        '<div class=\"md-icon\"></div>' +\n      '</div>' +\n      '<div ng-transclude class=\"md-label\"></div>',\n    compile: compile\n  };\n\n  // **********************************************************\n  // Private Methods\n  // **********************************************************\n\n  function compile (tElement, tAttrs) {\n\n    tAttrs.type = 'checkbox';\n    tAttrs.tabindex = tAttrs.tabindex || '0';\n    tElement.attr('role', tAttrs.type);\n\n    return function postLink(scope, element, attr, ngModelCtrl) {\n      ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();\n      $mdTheming(element);\n\n      if (attr.ngChecked) {\n        scope.$watch(\n            scope.$eval.bind(scope, attr.ngChecked),\n            ngModelCtrl.$setViewValue.bind(ngModelCtrl)\n        );\n      }\n      $$watchExpr('ngDisabled', 'tabindex', {\n        true: '-1',\n        false: attr.tabindex\n      });\n      $mdAria.expectWithText(element, 'aria-label');\n\n      // Reuse the original input[type=checkbox] directive from Angular core.\n      // This is a bit hacky as we need our own event listener and own render\n      // function.\n      inputDirective.link.pre(scope, {\n        on: angular.noop,\n        0: {}\n      }, attr, [ngModelCtrl]);\n\n      scope.mouseActive = false;\n      element.on('click', listener)\n        .on('keypress', keypressHandler)\n        .on('mousedown', function() {\n          scope.mouseActive = true;\n          $timeout(function(){\n            scope.mouseActive = false;\n          }, 100);\n        })\n        .on('focus', function() {\n          if(scope.mouseActive === false) { element.addClass('md-focused'); }\n        })\n        .on('blur', function() { element.removeClass('md-focused'); });\n\n      ngModelCtrl.$render = render;\n\n      function $$watchExpr(expr, htmlAttr, valueOpts) {\n        if (attr[expr]) {\n          scope.$watch(attr[expr], function(val) {\n            if (valueOpts[val]) {\n              element.attr(htmlAttr, valueOpts[val]);\n            }\n          });\n        }\n      }\n\n      function keypressHandler(ev) {\n        var keyCode = ev.which || ev.keyCode;\n        if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {\n          ev.preventDefault();\n          if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n          listener(ev);\n        }\n      }\n      function listener(ev) {\n        if (element[0].hasAttribute('disabled')) return;\n\n        scope.$apply(function() {\n          // Toggle the checkbox value...\n          var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;\n\n          ngModelCtrl.$setViewValue( viewValue, ev && ev.type);\n          ngModelCtrl.$render();\n        });\n      }\n\n      function render() {\n        if(ngModelCtrl.$viewValue) {\n          element.addClass(CHECKED_CSS);\n        } else {\n          element.removeClass(CHECKED_CSS);\n        }\n      }\n    };\n  }\n}\nMdCheckboxDirective.$inject = [\"inputDirective\", \"$mdInkRipple\", \"$mdAria\", \"$mdConstant\", \"$mdTheming\", \"$mdUtil\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.content\n *\n * @description\n * Scrollable content\n */\nangular.module('material.components.content', [\n  'material.core'\n])\n  .directive('mdContent', mdContentDirective);\n\n/**\n * @ngdoc directive\n * @name mdContent\n * @module material.components.content\n *\n * @restrict E\n *\n * @description\n * The `<md-content>` directive is a container element useful for scrollable content\n *\n * @usage\n *\n * - Add the `[layout-padding]` attribute to make the content padded.\n *\n * <hljs lang=\"html\">\n *  <md-content layout-padding>\n *      Lorem ipsum dolor sit amet, ne quod novum mei.\n *  </md-content>\n * </hljs>\n *\n */\n\nfunction mdContentDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    controller: ['$scope', '$element', ContentController],\n    link: function(scope, element, attr) {\n      var node = element[0];\n\n      $mdTheming(element);\n      scope.$broadcast('$mdContentLoaded', element);\n\n      iosScrollFix(element[0]);\n    }\n  };\n\n  function ContentController($scope, $element) {\n    this.$scope = $scope;\n    this.$element = $element;\n  }\n}\nmdContentDirective.$inject = [\"$mdTheming\"];\n\nfunction iosScrollFix(node) {\n  // IOS FIX:\n  // If we scroll where there is no more room for the webview to scroll,\n  // by default the webview itself will scroll up and down, this looks really\n  // bad.  So if we are scrolling to the very top or bottom, add/subtract one\n  angular.element(node).on('$md.pressdown', function(ev) {\n    // Only touch events\n    if (ev.pointer.type !== 't') return;\n    // Don't let a child content's touchstart ruin it for us.\n    if (ev.$materialScrollFixed) return;\n    ev.$materialScrollFixed = true;\n\n    if (node.scrollTop === 0) {\n      node.scrollTop = 1;\n    } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {\n      node.scrollTop -= 1;\n    }\n  });\n}\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.chips\n */\n/*\n * @see js folder for chips implementation\n */\nangular.module('material.components.chips', [\n  'material.core',\n  'material.components.autocomplete'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.dialog\n */\nangular.module('material.components.dialog', [\n  'material.core',\n  'material.components.backdrop'\n])\n  .directive('mdDialog', MdDialogDirective)\n  .provider('$mdDialog', MdDialogProvider);\n\nfunction MdDialogDirective($$rAF, $mdTheming) {\n  return {\n    restrict: 'E',\n    link: function(scope, element, attr) {\n      $mdTheming(element);\n      $$rAF(function() {\n        var content = element[0].querySelector('md-dialog-content');\n        if (content && content.scrollHeight > content.clientHeight) {\n          element.addClass('md-content-overflow');\n        }\n      });\n    }\n  };\n}\nMdDialogDirective.$inject = [\"$$rAF\", \"$mdTheming\"];\n\n/**\n * @ngdoc service\n * @name $mdDialog\n * @module material.components.dialog\n *\n * @description\n * `$mdDialog` opens a dialog over the app to inform users about critical information or require\n *  them to make decisions. There are two approaches for setup: a simple promise API\n *  and regular object syntax.\n *\n * ## Restrictions\n *\n * - The dialog is always given an isolate scope.\n * - The dialog's template must have an outer `<md-dialog>` element.\n *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use\n *   an element with class `md-actions` for the dialog's actions.\n * - Dialogs must cover the entire application to keep interactions inside of them.\n * Use the `parent` option to change where dialogs are appended.\n *\n * ## Sizing\n * - Complex dialogs can be sized with `flex=\"percentage\"`, i.e. `flex=\"66\"`.\n * - Default max-width is 80% of the `rootElement` or `parent`.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div  ng-app=\"demoApp\" ng-controller=\"EmployeeController\">\n *   <div>\n *     <md-button ng-click=\"showAlert()\" class=\"md-raised md-warn\">\n *       Employee Alert!\n *       </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"showDialog($event)\" class=\"md-raised\">\n *       Custom Dialog\n *       </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"closeAlert()\" ng-disabled=\"!hasAlert()\" class=\"md-raised\">\n *       Close Alert\n *     </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"showGreeting($event)\" class=\"md-raised md-primary\" >\n *       Greet Employee\n *       </md-button>\n *   </div>\n * </div>\n * </hljs>\n *\n * ### JavaScript: object syntax\n * <hljs lang=\"js\">\n * (function(angular, undefined){\n *   \"use strict\";\n *\n *   angular\n *    .module('demoApp', ['ngMaterial'])\n *    .controller('AppCtrl', AppController);\n *\n *   function AppController($scope, $mdDialog) {\n *     var alert;\n *     $scope.showAlert = showAlert;\n *     $scope.showDialog = showDialog;\n *     $scope.items = [1, 2, 3];\n *\n *     // Internal method\n *     function showAlert() {\n *       alert = $mdDialog.alert({\n *         title: 'Attention',\n *         content: 'This is an example of how easy dialogs can be!',\n *         ok: 'Close'\n *       });\n *\n *       $mdDialog\n *         .show( alert )\n *         .finally(function() {\n *           alert = undefined;\n *         });\n *     }\n *\n *     function showDialog($event) {\n *        var parentEl = angular.element(document.body);\n *        $mdDialog.show({\n *          parent: parentEl,\n *          targetEvent: $event,\n *          template:\n *            '<md-dialog aria-label=\"List dialog\">' +\n *            '  <md-dialog-content>'+\n *            '    <md-list>'+\n *            '      <md-list-item ng-repeat=\"item in items\">'+\n *            '       <p>Number {{item}}</p>' +\n *            '      </md-item>'+\n *            '    </md-list>'+\n *            '  </md-dialog-content>' +\n *            '  <div class=\"md-actions\">' +\n *            '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n *            '      Close Dialog' +\n *            '    </md-button>' +\n *            '  </div>' +\n *            '</md-dialog>',\n *          locals: {\n *            items: $scope.items\n *          },\n *          controller: DialogController\n *       });\n *       function DialogController($scope, $mdDialog, items) {\n *         $scope.items = items;\n *         $scope.closeDialog = function() {\n *           $mdDialog.hide();\n *         }\n *       }\n *     }\n *   }\n * })(angular);\n * </hljs>\n *\n * ### JavaScript: promise API syntax, custom dialog template\n * <hljs lang=\"js\">\n * (function(angular, undefined){\n *   \"use strict\";\n *\n *   angular\n *     .module('demoApp', ['ngMaterial'])\n *     .controller('EmployeeController', EmployeeEditor)\n *     .controller('GreetingController', GreetingController);\n *\n *   // Fictitious Employee Editor to show how to use simple and complex dialogs.\n *\n *   function EmployeeEditor($scope, $mdDialog) {\n *     var alert;\n *\n *     $scope.showAlert = showAlert;\n *     $scope.closeAlert = closeAlert;\n *     $scope.showGreeting = showCustomGreeting;\n *\n *     $scope.hasAlert = function() { return !!alert };\n *     $scope.userName = $scope.userName || 'Bobby';\n *\n *     // Dialog #1 - Show simple alert dialog and cache\n *     // reference to dialog instance\n *\n *     function showAlert() {\n *       alert = $mdDialog.alert()\n *         .title('Attention, ' + $scope.userName)\n *         .content('This is an example of how easy dialogs can be!')\n *         .ok('Close');\n *\n *       $mdDialog\n *           .show( alert )\n *           .finally(function() {\n *             alert = undefined;\n *           });\n *     }\n *\n *     // Close the specified dialog instance and resolve with 'finished' flag\n *     // Normally this is not needed, just use '$mdDialog.hide()' to close\n *     // the most recent dialog popup.\n *\n *     function closeAlert() {\n *       $mdDialog.hide( alert, \"finished\" );\n *       alert = undefined;\n *     }\n *\n *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.\n *\n *     function showCustomGreeting($event) {\n *         $mdDialog.show({\n *           targetEvent: $event,\n *           template:\n *             '<md-dialog>' +\n *\n *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +\n *\n *             '  <div class=\"md-actions\">' +\n *             '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n *             '      Close Greeting' +\n *             '    </md-button>' +\n *             '  </div>' +\n *             '</md-dialog>',\n *           controller: 'GreetingController',\n *           onComplete: afterShowAnimation,\n *           locals: { employee: $scope.userName }\n *         });\n *\n *         // When the 'enter' animation finishes...\n *\n *         function afterShowAnimation(scope, element, options) {\n *            // post-show code here: DOM element focus, etc.\n *         }\n *     }\n *\n *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog\n *     //             Here we used ng-controller=\"GreetingController as vm\" and\n *     //             $scope.vm === <controller instance>\n *\n *     function showCustomGreeting() {\n *\n *        $mdDialog.show({\n *           clickOutsideToClose: true,\n *\n *           scope: $scope,        // use parent scope in template\n *           preserveScope: true,  // do not forget this if use parent scope\n\n *           // Since GreetingController is instantiated with ControllerAs syntax\n *           // AND we are passing the parent '$scope' to the dialog, we MUST\n *           // use 'vm.<xxx>' in the template markup\n *\n *           template: '<md-dialog>' +\n *                     '  <md-dialog-content>' +\n *                     '     Hi There {{vm.employee}}' +\n *                     '  </md-dialog-content>' +\n *                     '</md-dialog>',\n *\n *           controller: function DialogController($scope, $mdDialog) {\n *             $scope.closeDialog = function() {\n *               $mdDialog.hide();\n *             }\n *           }\n *        });\n *     }\n *\n *   }\n *\n *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog\n *\n *   function GreetingController($scope, $mdDialog, employee) {\n *     // Assigned from construction <code>locals</code> options...\n *     $scope.employee = employee;\n *\n *     $scope.closeDialog = function() {\n *       // Easily hides most recent dialog shown...\n *       // no specific instance reference is needed.\n *       $mdDialog.hide();\n *     };\n *   }\n *\n * })(angular);\n * </hljs>\n */\n\n /**\n * @ngdoc method\n * @name $mdDialog#alert\n *\n * @description\n * Builds a preconfigured dialog with the specified message.\n *\n * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n *\n * - $mdDialogPreset#title(string) - sets title to string\n * - $mdDialogPreset#content(string) - sets content / message to string\n * - $mdDialogPreset#ok(string) - sets okay button text to string\n * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdDialog#confirm\n *\n * @description\n * Builds a preconfigured dialog with the specified message. You can call show and the promise returned\n * will be resolved only if the user clicks the confirm action on the dialog.\n *\n * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n *\n * Additionally, it supports the following methods:\n *\n * - $mdDialogPreset#title(string) - sets title to string\n * - $mdDialogPreset#content(string) - sets content / message to string\n * - $mdDialogPreset#ok(string) - sets okay button text to string\n * - $mdDialogPreset#cancel(string) - sets cancel button text to string\n * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#show\n *\n * @description\n * Show a dialog with the specified options.\n *\n * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and\n * `confirm()`, or an options object with the following properties:\n *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content\n *   of the dialog.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual template string.\n *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n *     the location of the click will be used as the starting point for the opening animation\n *     of the the dialog.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,\n *     it will create a new isolate scope.\n *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.\n *     Default true.\n *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.\n *     Default true.\n *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to\n *     close it. Default false.\n *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.\n *     Default true.\n *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if\n *     focusing some other way, as focus management is required for dialogs to be accessible.\n *     Defaults to true.\n *   - `controller` - `{string=}`: The controller to associate with the dialog. The controller\n *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.\n *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names\n *     of values to inject into the controller. For example, `locals: {three: 3}` would inject\n *     `three` into the controller, with the value 3. If `bindToController` is true, they will be\n *     copied to the controller instead.\n *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n *     These values will not be available until after initialization.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the\n *     dialog will not open until all of the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending\n *     to the root element of the application.\n *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is\n *     finished.\n *\n * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or\n * rejected with `$mdDialog.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#hide\n *\n * @description\n * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.\n *\n * @param {*=} response An argument for the resolved promise.\n *\n * @returns {promise} A promise that is resolved when the dialog has been closed.\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#cancel\n *\n * @description\n * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n *\n * @returns {promise} A promise that is resolved when the dialog has been closed.\n */\n\nfunction MdDialogProvider($$interimElementProvider) {\n\n  var alertDialogMethods = ['title', 'content', 'ariaLabel', 'ok'];\n\n  advancedDialogOptions.$inject = [\"$mdDialog\", \"$mdTheming\"];\n  dialogDefaultOptions.$inject = [\"$mdAria\", \"$document\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdDialog\", \"$timeout\", \"$rootElement\", \"$animate\", \"$$rAF\", \"$q\"];\n  return $$interimElementProvider('$mdDialog')\n    .setDefaults({\n      methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'parent'],\n      options: dialogDefaultOptions\n    })\n    .addPreset('alert', {\n      methods: ['title', 'content', 'ariaLabel', 'ok', 'theme'],\n      options: advancedDialogOptions\n    })\n    .addPreset('confirm', {\n      methods: ['title', 'content', 'ariaLabel', 'ok', 'cancel', 'theme'],\n      options: advancedDialogOptions\n    });\n\n  /* @ngInject */\n  function advancedDialogOptions($mdDialog, $mdTheming) {\n    return {\n      template: [\n        '<md-dialog md-theme=\"{{ dialog.theme }}\" aria-label=\"{{ dialog.ariaLabel }}\">',\n          '<md-dialog-content role=\"document\" tabIndex=\"-1\">',\n            '<h2 class=\"md-title\">{{ dialog.title }}</h2>',\n            '<p>{{ dialog.content }}</p>',\n          '</md-dialog-content>',\n          '<div class=\"md-actions\">',\n            '<md-button ng-if=\"dialog.$type == \\'confirm\\'\"' +\n                      ' ng-click=\"dialog.abort()\" class=\"md-primary\">',\n              '{{ dialog.cancel }}',\n            '</md-button>',\n            '<md-button ng-click=\"dialog.hide()\" class=\"md-primary\">',\n              '{{ dialog.ok }}',\n            '</md-button>',\n          '</div>',\n        '</md-dialog>'\n      ].join(''),\n      controller: function mdDialogCtrl() {\n        this.hide = function() {\n          $mdDialog.hide(true);\n        };\n        this.abort = function() {\n          $mdDialog.cancel();\n        };\n      },\n      controllerAs: 'dialog',\n      bindToController: true,\n      theme: $mdTheming.defaultTheme()\n    };\n  }\n\n  /* @ngInject */\n  function dialogDefaultOptions($mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $mdDialog, $timeout, $rootElement, $animate, $$rAF, $q) {\n    return {\n      hasBackdrop: true,\n      isolateScope: true,\n      onShow: onShow,\n      onRemove: onRemove,\n      clickOutsideToClose: false,\n      escapeToClose: true,\n      targetEvent: null,\n      focusOnOpen: true,\n      disableParentScroll: true,\n      transformTemplate: function(template) {\n        return '<div class=\"md-dialog-container\">' + template + '</div>';\n      }\n    };\n\n    function trapFocus(ev) {\n      var dialog = document.querySelector('md-dialog');\n\n      if (dialog && !dialog.contains(ev.target)) {\n        ev.stopImmediatePropagation();\n        dialog.focus();\n      }\n    }\n\n    // On show method for dialogs\n    function onShow(scope, element, options) {\n      angular.element($document[0].body).addClass('md-dialog-is-showing');\n      element = $mdUtil.extractElementByName(element, 'md-dialog');\n\n      // Incase the user provides a raw dom element, always wrap it in jqLite\n      options.parent = angular.element(options.parent);\n\n      options.popInTarget = angular.element((options.targetEvent || {}).target);\n      var closeButton = findCloseButton();\n\n      if (options.hasBackdrop) {\n        // Fix for IE 10\n        var computeFrom = (options.parent[0] == $document[0].body && $document[0].documentElement\n                           && $document[0].documentElement.scrollTop) ? angular.element($document[0].documentElement) : options.parent;\n        var parentOffset = computeFrom.prop('scrollTop');\n        options.backdrop = angular.element('<md-backdrop class=\"md-dialog-backdrop md-opaque\">');\n        options.backdrop.css('top', parentOffset +'px');\n        $mdTheming.inherit(options.backdrop, options.parent);\n        $animate.enter(options.backdrop, options.parent);\n        element.css('top', parentOffset +'px');\n      }\n\n      var role = 'dialog',\n          elementToFocus = closeButton;\n\n      if (options.$type === 'alert') {\n        role = 'alertdialog';\n        elementToFocus = element.find('md-dialog-content');\n      }\n\n      configureAria(element.find('md-dialog'), role, options);\n\n      document.addEventListener('focus', trapFocus, true);\n\n      if (options.disableParentScroll) {\n        options.lastOverflow = options.parent.css('overflow');\n        options.parent.css('overflow', 'hidden');\n      }\n\n      return dialogPopIn(\n        element,\n        options.parent,\n        options.popInTarget && options.popInTarget.length && options.popInTarget\n      )\n      .then(function() {\n\n        applyAriaToSiblings(element, true);\n\n        if (options.escapeToClose) {\n          options.rootElementKeyupCallback = function(e) {\n            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n              $timeout($mdDialog.cancel);\n            }\n          };\n          $rootElement.on('keyup', options.rootElementKeyupCallback);\n        }\n\n        if (options.clickOutsideToClose) {\n          options.dialogClickOutsideCallback = function(ev) {\n            // Only close if we click the flex container outside the backdrop\n            if (ev.target === element[0]) {\n              $timeout($mdDialog.cancel);\n            }\n          };\n          element.on('click', options.dialogClickOutsideCallback);\n        }\n\n        if (options.focusOnOpen) {\n          elementToFocus.focus();\n        }\n      });\n\n\n      function findCloseButton() {\n        //If no element with class dialog-close, try to find the last\n        //button child in md-actions and assume it is a close button\n        var closeButton = element[0].querySelector('.dialog-close');\n        if (!closeButton) {\n          var actionButtons = element[0].querySelectorAll('.md-actions button');\n          closeButton = actionButtons[ actionButtons.length - 1 ];\n        }\n        return angular.element(closeButton);\n      }\n\n    }\n\n    // On remove function for all dialogs\n    function onRemove(scope, element, options) {\n      angular.element($document[0].body).removeClass('md-dialog-is-showing');\n\n      if (options.backdrop) {\n        $animate.leave(options.backdrop);\n      }\n      if (options.disableParentScroll) {\n        options.parent.css('overflow', options.lastOverflow);\n        delete options.lastOverflow;\n      }\n      if (options.escapeToClose) {\n        $rootElement.off('keyup', options.rootElementKeyupCallback);\n      }\n      if (options.clickOutsideToClose) {\n        element.off('click', options.dialogClickOutsideCallback);\n      }\n\n      applyAriaToSiblings(element, false);\n\n      document.removeEventListener('focus', trapFocus, true);\n\n      return dialogPopOut(\n        element,\n        options.parent,\n        options.popInTarget && options.popInTarget.length && options.popInTarget\n      ).then(function() {\n        element.remove();\n        options.popInTarget && options.popInTarget.focus();\n      });\n\n    }\n\n    /**\n     * Inject ARIA-specific attributes appropriate for Dialogs\n     */\n    function configureAria(element, role, options) {\n\n      element.attr({\n        'role': role,\n        'tabIndex': '-1'\n      });\n\n      var dialogContent = element.find('md-dialog-content');\n      if (dialogContent.length === 0){\n        dialogContent = element;\n      }\n\n      var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());\n      dialogContent.attr('id', dialogId);\n      element.attr('aria-describedby', dialogId);\n\n      if (options.ariaLabel) {\n        $mdAria.expect(element, 'aria-label', options.ariaLabel);\n      }\n      else {\n        $mdAria.expectAsync(element, 'aria-label', function() {\n          var words = dialogContent.text().split(/\\s+/);\n          if (words.length > 3) words = words.slice(0,3).concat('...');\n          return words.join(' ');\n        });\n      }\n    }\n    /**\n     * Utility function to filter out raw DOM nodes\n     */\n    function isNodeOneOf(elem, nodeTypeArray) {\n      if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {\n        return true;\n      }\n    }\n    /**\n     * Walk DOM to apply or remove aria-hidden on sibling nodes\n     * and parent sibling nodes\n     *\n     * Prevents screen reader interaction behind modal window\n     * on swipe interfaces\n     */\n    function applyAriaToSiblings(element, value) {\n      var attribute = 'aria-hidden';\n\n      // get raw DOM node\n      element = element[0];\n\n      function walkDOM(element) {\n        while (element.parentNode) {\n          if (element === document.body) {\n            return;\n          }\n          var children = element.parentNode.children;\n          for (var i = 0; i < children.length; i++) {\n            // skip over child if it is an ascendant of the dialog\n            // or a script or style tag\n            if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {\n              children[i].setAttribute(attribute, value);\n            }\n          }\n\n          walkDOM(element = element.parentNode);\n        }\n      }\n      walkDOM(element);\n    }\n\n    function dialogPopIn(container, parentElement, clickElement) {\n      var dialogEl = container.find('md-dialog');\n\n      parentElement.append(container);\n      transformToClickElement(dialogEl, clickElement);\n\n      $$rAF(function() {\n        dialogEl.addClass('transition-in')\n          .css($mdConstant.CSS.TRANSFORM, '');\n      });\n\n      return $mdUtil.transitionEndPromise(dialogEl);\n    }\n\n    function dialogPopOut(container, parentElement, clickElement) {\n      var dialogEl = container.find('md-dialog');\n\n      dialogEl.addClass('transition-out').removeClass('transition-in');\n      transformToClickElement(dialogEl, clickElement);\n\n      return $mdUtil.transitionEndPromise(dialogEl);\n    }\n\n    function transformToClickElement(dialogEl, clickElement) {\n      if (clickElement) {\n        var clickRect = clickElement[0].getBoundingClientRect();\n        var dialogRect = dialogEl[0].getBoundingClientRect();\n\n        var scaleX = Math.min(0.5, clickRect.width / dialogRect.width);\n        var scaleY = Math.min(0.5, clickRect.height / dialogRect.height);\n\n        dialogEl.css($mdConstant.CSS.TRANSFORM, 'translate3d(' +\n          (-dialogRect.left + clickRect.left + clickRect.width/2 - dialogRect.width/2) + 'px,' +\n          (-dialogRect.top + clickRect.top + clickRect.height/2 - dialogRect.height/2) + 'px,' +\n          '0) scale(' + scaleX + ',' + scaleY + ')'\n        );\n      }\n    }\n\n    function dialogTransitionEnd(dialogEl) {\n      var deferred = $q.defer();\n      dialogEl.on($mdConstant.CSS.TRANSITIONEND, finished);\n      function finished(ev) {\n        //Make sure this transitionend didn't bubble up from a child\n        if (ev.target === dialogEl[0]) {\n          dialogEl.off($mdConstant.CSS.TRANSITIONEND, finished);\n          deferred.resolve();\n        }\n      }\n      return deferred.promise;\n    }\n\n  }\n}\nMdDialogProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  angular\n    .module('material.components.fabActions', ['material.core'])\n    .directive('mdFabActions', MdFabActionsDirective);\n\n  /**\n   * @ngdoc directive\n   * @name mdFabActions\n   * @module material.components.fabSpeedDial\n   *\n   * @restrict E\n   *\n   * @description\n   * The `<md-fab-actions>` directive is used inside of a `<md-fab-speed-dial>` or\n   * `<md-fab-toolbar>` directive to mark the an element (or elements) as the actions and setup the\n   * proper event listeners.\n   *\n   * @usage\n   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.\n   */\n  function MdFabActionsDirective() {\n    return {\n      restrict: 'E',\n\n      require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],\n\n      link: function(scope, element, attributes, controllers) {\n        // Grab whichever parent controller is used\n        var controller = controllers[0] || controllers[1];\n\n        // Make the children open/close their parent directive\n        if (controller) {\n          angular.forEach(element.children(), function(child) {\n            angular.element(child).on('focus', controller.open);\n            angular.element(child).on('blur', controller.close);\n          });\n        }\n\n        // After setting up the listeners, wrap every child in a new div and add a class that we can\n        // scale/fling independently\n        element.children().wrap('<div class=\"md-fab-action-item\">');\n      }\n    }\n  }\n\n})();\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.divider\n * @description Divider module!\n */\nangular.module('material.components.divider', [\n  'material.core'\n])\n  .directive('mdDivider', MdDividerDirective);\n\n/**\n * @ngdoc directive\n * @name mdDivider\n * @module material.components.divider\n * @restrict E\n *\n * @description\n * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.\n *\n * @param {boolean=} md-inset Add this attribute to activate the inset divider style.\n * @usage\n * <hljs lang=\"html\">\n * <md-divider></md-divider>\n *\n * <md-divider md-inset></md-divider>\n * </hljs>\n *\n */\nfunction MdDividerDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    link: $mdTheming\n  };\n}\nMdDividerDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  angular\n    .module('material.components.fabSpeedDial', [\n      'material.core',\n      'material.components.fabTrigger',\n      'material.components.fabActions'\n    ])\n    .directive('mdFabSpeedDial', MdFabSpeedDialDirective)\n    .animation('.md-fling', MdFabSpeedDialFlingAnimation)\n    .animation('.md-scale', MdFabSpeedDialScaleAnimation);\n\n  /**\n   * @ngdoc directive\n   * @name mdFabSpeedDial\n   * @module material.components.fabSpeedDial\n   *\n   * @restrict E\n   *\n   * @description\n   * The `<md-fab-speed-dial>` directive is used to present a series of popup elements (usually\n   * `<md-button>`s) for quick access to common actions.\n   *\n   * There are currently two animations available by applying one of the following classes to\n   * the component:\n   *\n   *  - `md-fling` - The speed dial items appear from underneath the trigger and move into their\n   *    appropriate positions.\n   *  - `md-scale` - The speed dial items appear in their proper places by scaling from 0% to 100%.\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   * <md-fab-speed-dial direction=\"up\" class=\"md-fling\">\n   *   <md-fab-trigger>\n   *     <md-button aria-label=\"Add...\"><md-icon icon=\"/img/icons/plus.svg\"></md-icon></md-button>\n   *   </md-fab-trigger>\n   *\n   *   <md-fab-actions>\n   *     <md-button aria-label=\"Add User\">\n   *       <md-icon icon=\"/img/icons/user.svg\"></md-icon>\n   *     </md-button>\n   *\n   *     <md-button aria-label=\"Add Group\">\n   *       <md-icon icon=\"/img/icons/group.svg\"></md-icon>\n   *     </md-button>\n   *   </md-fab-actions>\n   * </md-fab-speed-dial>\n   * </hljs>\n   *\n   * @param {string=} md-direction From which direction you would like the speed dial to appear\n   * relative to the trigger element.\n   * @param {expression=} md-open Programmatically control whether or not the speed-dial is visible.\n   */\n  function MdFabSpeedDialDirective() {\n    FabSpeedDialController.$inject = [\"$scope\", \"$element\", \"$animate\"];\n    return {\n      restrict: 'E',\n\n      scope: {\n        direction: '@?mdDirection',\n        isOpen: '=?mdOpen'\n      },\n\n      bindToController: true,\n      controller: FabSpeedDialController,\n      controllerAs: 'vm',\n\n      link: FabSpeedDialLink\n    };\n\n    function FabSpeedDialLink(scope, element) {\n      // Prepend an element to hold our CSS variables so we can use them in the animations below\n      element.prepend('<div class=\"md-css-variables\"></div>');\n    }\n\n    function FabSpeedDialController($scope, $element, $animate) {\n      var vm = this;\n\n      // Define our open/close functions\n      // Note: Used by fabTrigger and fabActions directives\n      vm.open = function() {\n        $scope.$apply('vm.isOpen = true');\n      };\n\n      vm.close = function() {\n        $scope.$apply('vm.isOpen = false');\n      };\n\n      setupDefaults();\n      setupListeners();\n      setupWatchers();\n\n      // Set our default variables\n      function setupDefaults() {\n        // Set the default direction to 'down' if none is specified\n        vm.direction = vm.direction || 'down';\n\n        // Set the default to be closed\n        vm.isOpen = vm.isOpen || false;\n      }\n\n      // Setup our event listeners\n      function setupListeners() {\n        $element.on('mouseenter', vm.open);\n        $element.on('mouseleave', vm.close);\n      }\n\n      // Setup our watchers\n      function setupWatchers() {\n        // Watch for changes to the direction and update classes/attributes\n        $scope.$watch('vm.direction', function(newDir, oldDir) {\n          // Add the appropriate classes so we can target the direction in the CSS\n          $animate.removeClass($element, 'md-' + oldDir);\n          $animate.addClass($element, 'md-' + newDir);\n        });\n\n\n        // Watch for changes to md-open\n        $scope.$watch('vm.isOpen', function(isOpen) {\n          var toAdd = isOpen ? 'md-is-open' : '';\n          var toRemove = isOpen ? '' : 'md-is-open';\n\n          $animate.setClass($element, toAdd, toRemove);\n        });\n      }\n    }\n  }\n\n  function MdFabSpeedDialFlingAnimation() {\n    function runAnimation(element) {\n      var el = element[0];\n      var ctrl = element.controller('mdFabSpeedDial');\n      var items = el.querySelectorAll('.md-fab-action-item');\n\n      // Grab our element which stores CSS variables\n      var variablesElement = el.querySelector('.md-css-variables');\n\n      // Setup JS variables based on our CSS variables\n      var startZIndex = variablesElement.style.zIndex;\n\n      // Always reset the items to their natural position/state\n      angular.forEach(items, function(item, index) {\n        var styles = item.style;\n\n        styles.transform = '';\n        styles.transitionDelay = '';\n        styles.opacity = 1;\n\n        // Make the items closest to the trigger have the highest z-index\n        item.style.zIndex = (items.length - index) + startZIndex;\n      });\n\n      // If the control is closed, hide the items behind the trigger\n      if (!ctrl.isOpen) {\n        angular.forEach(items, function(item, index) {\n          var newPosition, axis;\n\n          switch (ctrl.direction) {\n            case 'up':\n              newPosition = item.scrollHeight * (index + 1);\n              axis = 'Y';\n              break;\n            case 'down':\n              newPosition = -item.scrollHeight * (index + 1);\n              axis = 'Y';\n              break;\n            case 'left':\n              newPosition = item.scrollWidth * (index + 1);\n              axis = 'X';\n              break;\n            case 'right':\n              newPosition = -item.scrollWidth * (index + 1);\n              axis = 'X';\n              break;\n          }\n\n          item.style.transform = 'translate' + axis + '(' + newPosition + 'px)';\n        });\n      }\n    }\n\n    return {\n      addClass: function(element, className, done) {\n        if (element.hasClass('md-fling')) {\n          runAnimation(element);\n        }\n      },\n      removeClass: function(element, className, done) {\n        runAnimation(element);\n      }\n    }\n  }\n\n  function MdFabSpeedDialScaleAnimation() {\n    var delay = 65;\n\n    function runAnimation(element) {\n      var el = element[0];\n      var ctrl = element.controller('mdFabSpeedDial');\n      var items = el.querySelectorAll('.md-fab-action-item');\n\n      // Always reset the items to their natural position/state\n      angular.forEach(items, function(item, index) {\n        var styles = item.style,\n          offsetDelay = index * delay;\n\n        styles.opacity = ctrl.isOpen ? 1 : 0;\n        styles.transform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';\n        styles.transitionDelay = (ctrl.isOpen ?  offsetDelay : (items.length - offsetDelay)) + 'ms';\n      });\n    }\n\n    return {\n      addClass: function(element, className, done) {\n        runAnimation(element);\n      },\n\n      removeClass: function(element, className, done) {\n        runAnimation(element);\n      }\n    }\n  }\n})();\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  angular\n    .module('material.components.fabToolbar', [\n      'material.core',\n      'material.components.fabTrigger',\n      'material.components.fabActions'\n    ])\n    .directive('mdFabToolbar', MdFabToolbarDirective)\n    .animation('.md-fab-toolbar', MdFabToolbarAnimation);\n\n  /**\n   * @ngdoc directive\n   * @name mdFabToolbar\n   * @module material.components.fabToolbar\n   *\n   * @restrict E\n   *\n   * @description\n   *\n   * The `<md-fab-toolbar>` directive is used present a toolbar of elements (usually `<md-button>`s)\n   * for quick access to common actions when a floating action button is activated (via hover or\n   * keyboard navigation).\n   *\n   * @usage\n   *\n   * <hljs lang=\"html\">\n   * <md-fab-toolbar>\n   *   <md-fab-trigger>\n   *     <md-button aria-label=\"Add...\"><md-icon icon=\"/img/icons/plus.svg\"></md-icon></md-button>\n   *   </md-fab-trigger>\n   *\n   *   <md-fab-actions>\n   *     <md-button aria-label=\"Add User\">\n   *       <md-icon icon=\"/img/icons/user.svg\"></md-icon>\n   *     </md-button>\n   *\n   *     <md-button aria-label=\"Add Group\">\n   *       <md-icon icon=\"/img/icons/group.svg\"></md-icon>\n   *     </md-button>\n   *   </md-fab-actions>\n   * </md-fab-toolbar>\n   * </hljs>\n   *\n   * @param {expression=} md-open Programmatically control whether or not the toolbar is visible.\n   */\n  function MdFabToolbarDirective() {\n    FabToolbarController.$inject = [\"$scope\", \"$element\", \"$animate\"];\n    return {\n      restrict: 'E',\n      transclude: true,\n      template:\n        '<div class=\"md-fab-toolbar-wrapper\">' +\n        '  <div class=\"md-fab-toolbar-content\" ng-transclude></div>' +\n        '</div>',\n\n      scope: {\n        isOpen: '=?mdOpen'\n      },\n\n      bindToController: true,\n      controller: FabToolbarController,\n      controllerAs: 'vm',\n\n      link: link\n    };\n\n    function FabToolbarController($scope, $element, $animate) {\n      var vm = this;\n\n      // Set the default to be closed\n      vm.isOpen = vm.isOpen || false;\n\n      vm.open = function() {\n        vm.isOpen = true;\n        $scope.$apply();\n      };\n\n      vm.close = function() {\n        vm.isOpen = false;\n        $scope.$apply();\n      };\n\n      // Add our class so we can trigger the animation on start\n      $element.addClass('md-fab-toolbar');\n\n      // Setup some mouse events so the hover effect can be triggered\n      // anywhere over the toolbar\n      $element.on('mouseenter', vm.open);\n      $element.on('mouseleave', vm.close);\n\n      // Watch for changes to md-open and toggle our class\n      $scope.$watch('vm.isOpen', function(isOpen) {\n        var toAdd = isOpen ? 'md-is-open' : '';\n        var toRemove = isOpen ? '' : 'md-is-open';\n\n        $animate.setClass($element, toAdd, toRemove);\n      });\n    }\n\n    function link(scope, element, attributes) {\n      // Don't allow focus on the trigger\n      element.find('md-fab-trigger').find('button').attr('tabindex', '-1');\n\n      // Prepend the background element to the trigger's button\n      element.find('md-fab-trigger').find('button')\n        .prepend('<div class=\"md-fab-toolbar-background\"></div>');\n    }\n  }\n\n  function MdFabToolbarAnimation() {\n    var originalIconDelay;\n\n    function runAnimation(element, className, done) {\n      var el = element[0];\n      var ctrl = element.controller('mdFabToolbar');\n\n      // Grab the relevant child elements\n      var backgroundElement = el.querySelector('.md-fab-toolbar-background');\n      var triggerElement = el.querySelector('md-fab-trigger button');\n      var iconElement = el.querySelector('md-fab-trigger button md-icon');\n      var actions = element.find('md-fab-actions').children();\n\n      // If we have both elements, use them to position the new background\n      if (triggerElement && backgroundElement) {\n        // Get our variables\n        var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');\n        var width = el.offsetWidth;\n        var height = el.offsetHeight;\n\n        // Make a square\n        var scale = width * 2;\n\n        // Set some basic styles no matter what animation we're doing\n        backgroundElement.style.backgroundColor = color;\n        backgroundElement.style.borderRadius = width + 'px';\n\n        // If we're open\n        if (ctrl.isOpen) {\n\n          // Set the width/height to take up the full toolbar width\n          backgroundElement.style.width = scale + 'px';\n          backgroundElement.style.height = scale + 'px';\n\n          // Set the top/left to move up/left (or right) by the scale width/height\n          backgroundElement.style.top = -(scale / 2) + 'px';\n\n          if (element.hasClass('md-left')) {\n            backgroundElement.style.left = -(scale / 2) + 'px';\n            backgroundElement.style.right = null;\n          }\n\n          if (element.hasClass('md-right')) {\n            backgroundElement.style.right = -(scale / 2) + 'px';\n            backgroundElement.style.left = null;\n          }\n\n          // Set the next close animation to have the proper delays\n          backgroundElement.style.transitionDelay = '0ms';\n          iconElement.style.transitionDelay = '.3s';\n\n          // Apply a transition delay to actions\n          angular.forEach(actions, function(action, index) {\n            action.style.transitionDelay = (actions.length - index) * 25 + 'ms';\n          });\n        } else {\n          // Otherwise, set the width/height to the trigger's width/height\n          backgroundElement.style.width = triggerElement.offsetWidth + 'px';\n          backgroundElement.style.height = triggerElement.offsetHeight + 'px';\n\n          // Reset the position\n          backgroundElement.style.top = '0px';\n\n          if (element.hasClass('md-left')) {\n            backgroundElement.style.left = '0px';\n            backgroundElement.style.right = null;\n          }\n\n          if (element.hasClass('md-right')) {\n            backgroundElement.style.right = '0px';\n            backgroundElement.style.left = null;\n          }\n\n          // Set the next open animation to have the proper delays\n          backgroundElement.style.transitionDelay = '200ms';\n          iconElement.style.transitionDelay = '0ms';\n\n          // Apply a transition delay to actions\n          angular.forEach(actions, function(action, index) {\n            action.style.transitionDelay = (index * 25) + 'ms';\n          });\n        }\n      }\n    }\n\n    return {\n      addClass: function(element, className, done) {\n        runAnimation(element, className, done);\n      },\n\n      removeClass: function(element, className, done) {\n        runAnimation(element, className, done);\n      }\n    }\n  }\n})();\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.gridList\n */\nangular.module('material.components.gridList', ['material.core'])\n       .directive('mdGridList', GridListDirective)\n       .directive('mdGridTile', GridTileDirective)\n       .directive('mdGridTileFooter', GridTileCaptionDirective)\n       .directive('mdGridTileHeader', GridTileCaptionDirective)\n       .factory('$mdGridLayout', GridLayoutFactory);\n\n/**\n * @ngdoc directive\n * @name mdGridList\n * @module material.components.gridList\n * @restrict E\n * @description\n * Grid lists are an alternative to standard list views. Grid lists are distinct\n * from grids used for layouts and other visual presentations.\n *\n * A grid list is best suited to presenting a homogenous data type, typically\n * images, and is optimized for visual comprehension and differentiating between\n * like data types.\n *\n * A grid list is a continuous element consisting of tessellated, regular\n * subdivisions called cells that contain tiles (`md-grid-tile`).\n *\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png\"\n *    style=\"width: 300px; height: auto; margin-right: 16px;\" alt=\"Concept of grid explained visually\">\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png\"\n *    style=\"width: 300px; height: auto;\" alt=\"Grid concepts legend\">\n *\n * Cells are arrayed vertically and horizontally within the grid.\n *\n * Tiles hold content and can span one or more cells vertically or horizontally.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-list` directive supports \"responsive\" attributes, which allow\n * different `md-cols`, `md-gutter` and `md-row-height` values depending on the\n * currently matching media query (as defined in `$mdConstant.MEDIA`).\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-cols-lg=\"8\"`)\n *\n * @param {number} md-cols Number of columns in the grid.\n * @param {string} md-row-height One of\n * <ul>\n *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>\n *   <li>`{width}:{height}` - Ratio of width to height (eg.\n *   `md-row-height=\"16:9\"`)</li>\n *   <li>`\"fit\"` - Height will be determined by subdividing the available\n *   height by the number of rows</li>\n * </ul>\n * @param {string=} md-gutter The amount of space between tiles in CSS units\n *     (default 1px)\n * @param {expression=} md-on-layout Expression to evaluate after layout. Event\n *     object is available as `$event`, and contains performance information.\n *\n * @usage\n * Basic:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"5\" md-gutter=\"1em\" md-row-height=\"4:3\">\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fixed-height rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"200px\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fit rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"fit\" style=\"height: 400px;\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Using responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-list\n *     md-cols-sm=\"2\"\n *     md-cols-md=\"4\"\n *     md-cols-lg=\"8\"\n *     md-cols-gt-lg=\"12\"\n *     ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n */\nfunction GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {\n  return {\n    restrict: 'E',\n    controller: GridListController,\n    scope: {\n      mdOnLayout: '&'\n    },\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, ctrl) {\n    // Apply semantics\n    element.attr('role', 'list');\n\n    // Provide the controller with a way to trigger layouts.\n    ctrl.layoutDelegate = layoutDelegate;\n\n    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),\n        unwatchAttrs = watchMedia();\n      scope.$on('$destroy', unwatchMedia);\n\n    /**\n     * Watches for changes in media, invalidating layout as necessary.\n     */\n    function watchMedia() {\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia(mediaName); // initialize\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .addListener(invalidateLayout);\n      }\n      return $mdMedia.watchResponsiveAttributes(\n          ['md-cols', 'md-row-height'], attrs, layoutIfMediaMatch);\n    }\n\n    function unwatchMedia() {\n      ctrl.layoutDelegate = angular.noop;\n\n      unwatchAttrs();\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .removeListener(invalidateLayout);\n      }\n    }\n\n    /**\n     * Performs grid layout if the provided mediaName matches the currently\n     * active media type.\n     */\n    function layoutIfMediaMatch(mediaName) {\n      if (mediaName == null) {\n        // TODO(shyndman): It would be nice to only layout if we have\n        // instances of attributes using this media type\n        ctrl.invalidateLayout();\n      } else if ($mdMedia(mediaName)) {\n        ctrl.invalidateLayout();\n      }\n    }\n\n    var lastLayoutProps;\n\n    /**\n     * Invokes the layout engine, and uses its results to lay out our\n     * tile elements.\n     *\n     * @param {boolean} tilesInvalidated Whether tiles have been\n     *    added/removed/moved since the last layout. This is to avoid situations\n     *    where tiles are replaced with properties identical to their removed\n     *    counterparts.\n     */\n    function layoutDelegate(tilesInvalidated) {\n      var tiles = getTileElements();\n      var props = {\n        tileSpans: getTileSpans(tiles),\n        colCount: getColumnCount(),\n        rowMode: getRowMode(),\n        rowHeight: getRowHeight(),\n        gutter: getGutter()\n      };\n\n      if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {\n        return;\n      }\n\n      var performance =\n        $mdGridLayout(props.colCount, props.tileSpans, tiles)\n          .map(function(tilePositions, rowCount) {\n            return {\n              grid: {\n                element: element,\n                style: getGridStyle(props.colCount, rowCount,\n                    props.gutter, props.rowMode, props.rowHeight)\n              },\n              tiles: tilePositions.map(function(ps, i) {\n                return {\n                  element: angular.element(tiles[i]),\n                  style: getTileStyle(ps.position, ps.spans,\n                      props.colCount, props.rowCount,\n                      props.gutter, props.rowMode, props.rowHeight)\n                }\n              })\n            }\n          })\n          .reflow()\n          .performance();\n\n      // Report layout\n      scope.mdOnLayout({\n        $event: {\n          performance: performance\n        }\n      });\n\n      lastLayoutProps = props;\n    }\n\n    // Use $interpolate to do some simple string interpolation as a convenience.\n\n    var startSymbol = $interpolate.startSymbol();\n    var endSymbol = $interpolate.endSymbol();\n\n    // Returns an expression wrapped in the interpolator's start and end symbols.\n    function expr(exprStr) {\n      return startSymbol + exprStr + endSymbol;\n    }\n\n    // The amount of space a single 1x1 tile would take up (either width or height), used as\n    // a basis for other calculations. This consists of taking the base size percent (as would be\n    // if evenly dividing the size between cells), and then subtracting the size of one gutter.\n    // However, since there are no gutters on the edges, each tile only uses a fration\n    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per\n    // tile, and then breaking up the extra gutter on the edge evenly among the cells).\n    var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');\n\n    // The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n    // row/column (offset).\n    var POSITION  = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');\n\n    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.\n    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back\n    // in the space that the gutter would normally have used (which was already accounted for in\n    // the base unit calculation).\n    var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');\n\n    /**\n     * Gets the styles applied to a tile element described by the given parameters.\n     * @param {{row: number, col: number}} position The row and column indices of the tile.\n     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.\n     * @param {number} colCount The number of columns.\n     * @param {number} rowCount The number of rows.\n     * @param {string} gutter The amount of space between tiles. This will be something like\n     *     '5px' or '2em'.\n     * @param {string} rowMode The row height mode. Can be one of:\n     *     'fixed': all rows have a fixed size, given by rowHeight,\n     *     'ratio': row height defined as a ratio to width, or\n     *     'fit': fit to the grid-list element height, divinding evenly among rows.\n     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and\n     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).\n     * @returns {Object} Map of CSS properties to be applied to the style element. Will define\n     *     values for top, left, width, height, marginTop, and paddingTop.\n     */\n    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {\n      // TODO(shyndman): There are style caching opportunities here.\n\n      // Percent of the available horizontal space that one column takes up.\n      var hShare = (1 / colCount) * 100;\n\n      // Fraction of the gutter size that each column takes up.\n      var hGutterShare = (colCount - 1) / colCount;\n\n      // Base horizontal size of a column.\n      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});\n\n      // The width and horizontal position of each tile is always calculated the same way, but the\n      // height and vertical position depends on the rowMode.\n      var style = {\n        left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),\n        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),\n        // resets\n        paddingTop: '',\n        marginTop: '',\n        top: '',\n        height: ''\n      };\n\n      switch (rowMode) {\n        case 'fixed':\n          // In fixed mode, simply use the given rowHeight.\n          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });\n          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });\n          break;\n\n        case 'ratio':\n          // Percent of the available vertical space that one row takes up. Here, rowHeight holds\n          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.\n          var vShare = hShare / rowHeight;\n\n          // Base veritcal size of a row.\n          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          // padidngTop and marginTop are used to maintain the given aspect ratio, as\n          // a percentage-based value for these properties is applied to the *width* of the\n          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});\n          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });\n          break;\n\n        case 'fit':\n          // Fraction of the gutter size that each column takes up.\n          var vGutterShare = (rowCount - 1) / rowCount;\n\n          // Percent of the available vertical space that one row takes up.\n          var vShare = (1 / rowCount) * 100;\n\n          // Base vertical size of a row.\n          var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});\n\n          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n          break;\n      }\n\n      return style;\n    }\n\n    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {\n      var style = {\n        height: '',\n        paddingBottom: ''\n      };\n\n      switch(rowMode) {\n        case 'fixed':\n          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });\n          break;\n\n        case 'ratio':\n          // rowHeight is width / height\n          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,\n              hShare = (1 / colCount) * 100,\n              vShare = hShare * (1 / rowHeight),\n              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});\n          break;\n\n        case 'fit':\n          // noop, as the height is user set\n          break;\n      }\n\n      return style;\n    }\n\n    function getTileElements() {\n      return [].filter.call(element.children(), function(ele) {\n        return ele.tagName == 'MD-GRID-TILE';\n      });\n    }\n\n    /**\n     * Gets an array of objects containing the rowspan and colspan for each tile.\n     * @returns {Array<{row: number, col: number}>}\n     */\n    function getTileSpans(tileElements) {\n      return [].map.call(tileElements, function(ele) {\n        var ctrl = angular.element(ele).controller('mdGridTile');\n        return {\n          row: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,\n          col: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1\n        };\n      });\n    }\n\n    function getColumnCount() {\n      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);\n      if (isNaN(colCount)) {\n        throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';\n      }\n      return colCount;\n    }\n\n    function getGutter() {\n      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);\n    }\n\n    function getRowHeight() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      switch (getRowMode()) {\n        case 'fixed':\n          return applyDefaultUnit(rowHeight);\n        case 'ratio':\n          var whRatio = rowHeight.split(':');\n          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);\n        case 'fit':\n          return 0; // N/A\n      }\n    }\n\n    function getRowMode() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      if (rowHeight == 'fit') {\n        return 'fit';\n      } else if (rowHeight.indexOf(':') !== -1) {\n        return 'ratio';\n      } else {\n        return 'fixed';\n      }\n    }\n\n    function applyDefaultUnit(val) {\n      return /\\D$/.test(val) ? val : val + 'px';\n    }\n  }\n}\nGridListDirective.$inject = [\"$interpolate\", \"$mdConstant\", \"$mdGridLayout\", \"$mdMedia\"];\n\n/* @ngInject */\nfunction GridListController($timeout) {\n  this.layoutInvalidated = false;\n  this.tilesInvalidated = false;\n  this.$timeout_ = $timeout;\n  this.layoutDelegate = angular.noop;\n}\nGridListController.$inject = [\"$timeout\"];\n\nGridListController.prototype = {\n  invalidateTiles: function() {\n    this.tilesInvalidated = true;\n    this.invalidateLayout();\n  },\n\n  invalidateLayout: function() {\n    if (this.layoutInvalidated) {\n      return;\n    }\n    this.layoutInvalidated = true;\n    this.$timeout_(angular.bind(this, this.layout));\n  },\n\n  layout: function() {\n    try {\n      this.layoutDelegate(this.tilesInvalidated);\n    } finally {\n      this.layoutInvalidated = false;\n      this.tilesInvalidated = false;\n    }\n  }\n};\n\n\n/* @ngInject */\nfunction GridLayoutFactory($mdUtil) {\n  var defaultAnimator = GridTileAnimator;\n\n  /**\n   * Set the reflow animator callback\n   */\n  GridLayout.animateWith = function(customAnimator) {\n    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;\n  };\n\n  return GridLayout;\n\n  /**\n   * Publish layout function\n   */\n  function GridLayout(colCount, tileSpans) {\n      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;\n\n      layoutTime = $mdUtil.time(function() {\n        layoutInfo = calculateGridFor(colCount, tileSpans);\n      });\n\n      return self = {\n\n        /**\n         * An array of objects describing each tile's position in the grid.\n         */\n        layoutInfo: function() {\n          return layoutInfo;\n        },\n\n        /**\n         * Maps grid positioning to an element and a set of styles using the\n         * provided updateFn.\n         */\n        map: function(updateFn) {\n          mapTime = $mdUtil.time(function() {\n            var info = self.layoutInfo();\n            gridStyles = updateFn(info.positioning, info.rowCount);\n          });\n          return self;\n        },\n\n        /**\n         * Default animator simply sets the element.css( <styles> ). An alternate\n         * animator can be provided as an argument. The function has the following\n         * signature:\n         *\n         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)\n         */\n        reflow: function(animatorFn) {\n          reflowTime = $mdUtil.time(function() {\n            var animator = animatorFn || defaultAnimator;\n            animator(gridStyles.grid, gridStyles.tiles);\n          });\n          return self;\n        },\n\n        /**\n         * Timing for the most recent layout run.\n         */\n        performance: function() {\n          return {\n            tileCount: tileSpans.length,\n            layoutTime: layoutTime,\n            mapTime: mapTime,\n            reflowTime: reflowTime,\n            totalTime: layoutTime + mapTime + reflowTime\n          };\n        }\n      };\n    }\n\n  /**\n   * Default Gridlist animator simple sets the css for each element;\n   * NOTE: any transitions effects must be manually set in the CSS.\n   * e.g.\n   *\n   *  md-grid-tile {\n   *    transition: all 700ms ease-out 50ms;\n   *  }\n   *\n   */\n  function GridTileAnimator(grid, tiles) {\n    grid.element.css(grid.style);\n    tiles.forEach(function(t) {\n      t.element.css(t.style);\n    })\n  }\n\n  /**\n   * Calculates the positions of tiles.\n   *\n   * The algorithm works as follows:\n   *    An Array<Number> with length colCount (spaceTracker) keeps track of\n   *    available tiling positions, where elements of value 0 represents an\n   *    empty position. Space for a tile is reserved by finding a sequence of\n   *    0s with length <= than the tile's colspan. When such a space has been\n   *    found, the occupied tile positions are incremented by the tile's\n   *    rowspan value, as these positions have become unavailable for that\n   *    many rows.\n   *\n   *    If the end of a row has been reached without finding space for the\n   *    tile, spaceTracker's elements are each decremented by 1 to a minimum\n   *    of 0. Rows are searched in this fashion until space is found.\n   */\n  function calculateGridFor(colCount, tileSpans) {\n    var curCol = 0,\n        curRow = 0,\n        spaceTracker = newSpaceTracker();\n\n    return {\n      positioning: tileSpans.map(function(spans, i) {\n        return {\n          spans: spans,\n          position: reserveSpace(spans, i)\n        };\n      }),\n      rowCount: curRow + Math.max.apply(Math, spaceTracker)\n    };\n\n    function reserveSpace(spans, i) {\n      if (spans.col > colCount) {\n        throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +\n            '(' + spans.col + ') that exceeds the column count ' +\n            '(' + colCount + ')';\n      }\n\n      var start = 0,\n          end = 0;\n\n      // TODO(shyndman): This loop isn't strictly necessary if you can\n      // determine the minimum number of rows before a space opens up. To do\n      // this, recognize that you've iterated across an entire row looking for\n      // space, and if so fast-forward by the minimum rowSpan count. Repeat\n      // until the required space opens up.\n      while (end - start < spans.col) {\n        if (curCol >= colCount) {\n          nextRow();\n          continue;\n        }\n\n        start = spaceTracker.indexOf(0, curCol);\n        if (start === -1 || (end = findEnd(start + 1)) === -1) {\n          start = end = 0;\n          nextRow();\n          continue;\n        }\n\n        curCol = end + 1;\n      }\n\n      adjustRow(start, spans.col, spans.row);\n      curCol = start + spans.col;\n\n      return {\n        col: start,\n        row: curRow\n      };\n    }\n\n    function nextRow() {\n      curCol = 0;\n      curRow++;\n      adjustRow(0, colCount, -1); // Decrement row spans by one\n    }\n\n    function adjustRow(from, cols, by) {\n      for (var i = from; i < from + cols; i++) {\n        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);\n      }\n    }\n\n    function findEnd(start) {\n      var i;\n      for (i = start; i < spaceTracker.length; i++) {\n        if (spaceTracker[i] !== 0) {\n          return i;\n        }\n      }\n\n      if (i === spaceTracker.length) {\n        return i;\n      }\n    }\n\n    function newSpaceTracker() {\n      var tracker = [];\n      for (var i = 0; i < colCount; i++) {\n        tracker.push(0);\n      }\n      return tracker;\n    }\n  }\n}\nGridLayoutFactory.$inject = [\"$mdUtil\"];\n\n/**\n * @ngdoc directive\n * @name mdGridTile\n * @module material.components.gridList\n * @restrict E\n * @description\n * Tiles contain the content of an `md-grid-list`. They span one or more grid\n * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to\n * display secondary content.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-tile` directive supports \"responsive\" attributes, which allow\n * different `md-rowspan` and `md-colspan` values depending on the currently\n * matching media query (as defined in `$mdConstant.MEDIA`).\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-colspan-sm=\"4\"`)\n *\n * @param {number=} md-colspan The number of columns to span (default 1). Cannot\n *    exceed the number of columns in the grid. Supports interpolation.\n * @param {number=} md-rowspan The number of rows to span (default 1). Supports\n *     interpolation.\n *\n * @usage\n * With header:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-header>\n *     <h3>This is a header</h3>\n *   </md-grid-tile-header>\n * </md-grid-tile>\n * </hljs>\n *\n * With footer:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-footer>\n *     <h3>This is a footer</h3>\n *   </md-grid-tile-footer>\n * </md-grid-tile>\n * </hljs>\n *\n * Spanning multiple rows/columns:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"2\" md-rowspan=\"3\">\n * </md-grid-tile>\n * </hljs>\n *\n * Responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"1\" md-colspan-sm=\"3\" md-colspan-md=\"5\">\n * </md-grid-tile>\n * </hljs>\n */\nfunction GridTileDirective($mdMedia) {\n  return {\n    restrict: 'E',\n    require: '^mdGridList',\n    template: '<figure ng-transclude></figure>',\n    transclude: true,\n    scope: {},\n    // Simple controller that exposes attributes to the grid directive\n    controller: [\"$attrs\", function($attrs) {\n      this.$attrs = $attrs;\n    }],\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, gridCtrl) {\n    // Apply semantics\n    element.attr('role', 'listitem');\n\n    // If our colspan or rowspan changes, trigger a layout\n    var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'],\n        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));\n\n    // Tile registration/deregistration\n    gridCtrl.invalidateTiles();\n    scope.$on('$destroy', function() {\n      unwatchAttrs();\n      gridCtrl.invalidateLayout();\n    });\n\n    if (angular.isDefined(scope.$parent.$index)) {\n      scope.$watch(function() { return scope.$parent.$index; },\n        function indexChanged(newIdx, oldIdx) {\n          if (newIdx === oldIdx) {\n            return;\n          }\n          gridCtrl.invalidateTiles();\n        });\n    }\n  }\n}\nGridTileDirective.$inject = [\"$mdMedia\"];\n\n\nfunction GridTileCaptionDirective() {\n  return {\n    template: '<figcaption ng-transclude></figcaption>',\n    transclude: true\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  angular\n    .module('material.components.fabTrigger', [ 'material.core' ])\n    .directive('mdFabTrigger', MdFabTriggerDirective);\n\n  /**\n   * @ngdoc directive\n   * @name mdFabTrigger\n   * @module material.components.fabSpeedDial\n   *\n   * @restrict E\n   *\n   * @description\n   * The `<md-fab-trigger>` directive is used inside of a `<md-fab-speed-dial>` or\n   * `<md-fab-toolbar>` directive to mark the an element (or elements) as the trigger and setup the\n   * proper event listeners.\n   *\n   * @usage\n   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.\n   */\n  function MdFabTriggerDirective() {\n    return {\n      restrict: 'E',\n\n      require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],\n\n      link: function(scope, element, attributes, controllers) {\n        // Grab whichever parent controller is used\n        var controller = controllers[0] || controllers[1];\n\n        // Make the children open/close their parent directive\n        if (controller) {\n          angular.forEach(element.children(), function(child) {\n            angular.element(child).on('focus', controller.open);\n            angular.element(child).on('blur', controller.close);\n          });\n        }\n      }\n    }\n  }\n})();\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.icon\n * @description\n * Icon\n */\nangular.module('material.components.icon', [\n    'material.core'\n  ])\n  .directive('mdIcon', mdIconDirective);\n\n/**\n * @ngdoc directive\n * @name mdIcon\n * @module material.components.icon\n *\n * @restrict E\n *\n * @description\n * The `<md-icon>` directive is an markup element useful for showing an icon based on a font-icon\n * or a SVG. Icons are view-only elements that should not be used directly as buttons; instead nest a `<md-icon>`\n * inside a `md-button` to add hover and click features.\n *\n * When using SVGs, both external SVGs (via URLs) or sets of SVGs [from icon sets] can be\n * easily loaded and used.When use font-icons, developers must following three (3) simple steps:\n *\n * <ol>\n * <li>Load the font library. e.g.<br/>\n *    &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n *    rel=\"stylesheet\"&gt;\n * </li>\n * <li> Use either (a) font-icon class names or (b) font ligatures to render the font glyph by using its textual name</li>\n * <li> Use &lt;md-icon md-font-icon=\"classname\" /&gt; or <br/>\n *     use &lt;md-icon md-font-set=\"font library classname or alias\"&gt; textual_name &lt;/md-icon&gt; or <br/>\n *     use &lt;md-icon md-font-set=\"font library classname or alias\"&gt; numerical_character_reference &lt;/md-icon&gt;\n * </li>\n * </ol>\n *\n * Full details for these steps can be found:\n *\n * <ul>\n * <li>http://google.github.io/material-design-icons/</li>\n * <li>http://google.github.io/material-design-icons/#icon-font-for-the-web</li>\n * </ul>\n *\n * The Material Design icon style <code>.material-icons</code> and the icon font references are published in\n * Material Design Icons:\n *\n * <ul>\n * <li>http://www.google.com/design/icons/</li>\n * <li>https://www.google.com/design/icons/#ic_accessibility</li>\n * </ul>\n *\n * <h2 id=\"material_design_icons\">Material Design Icons</h2>\n * Using the Material Design Icon-Selector, developers can easily and quickly search for a Material Design font-icon and\n * determine its textual name and character reference code. Click on any icon to see the slide-up information\n * panel with details regarding a SVG download or information on the font-icon usage.\n *\n * <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\" style=\"border-bottom:none;\">\n * <img src=\"https://cloud.githubusercontent.com/assets/210413/7902490/fe8dd14c-0780-11e5-98fb-c821cc6475e6.png\"\n *      aria-label=\"Material Design Icon-Selector\" style=\"max-width:75%;padding-left:10%\">\n * </a>\n *\n * <span class=\"image_caption\">\n *  Click on the image above to link to the\n *  <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\">Material Design Icon-Selector</a>.\n * </span>\n *\n * @param {string} md-font-icon Name of CSS icon associated with the font-face will be used\n * to render the icon. Requires the fonts and the named CSS styles to be preloaded.\n * @param {string} md-font-set CSS style name associated with the font library; which will be assigned as\n * the class for the font-icon ligature. This value may also be an alias that is used to lookup the classname;\n * internally use `$mdIconProvider.fontSet(<alias>)` to determine the style name.\n * @param {string} md-svg-src URL [or expression ] used to load, cache, and display an external SVG.\n * @param {string} md-svg-icon Name used for lookup of the icon from the internal cache; interpolated strings or\n * expressions may also be used. Specific set names can be used with the syntax `<set name>:<icon name>`.<br/><br/>\n * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.\n * @param {string=} aria-label Labels icon for accessibility. If an empty string is provided, icon\n * will be hidden from accessibility layer with `aria-hidden=\"true\"`. If there's no aria-label on the icon\n * nor a label on the parent element, a warning will be logged to the console.\n *\n * @usage\n * When using SVGs:\n * <hljs lang=\"html\">\n *\n *  <!-- Icon ID; may contain optional icon set prefix; icons must registered using $mdIconProvider -->\n *  <md-icon md-svg-icon=\"social:android\"    aria-label=\"android \" ></md-icon>\n *\n *  <!-- Icon urls; may be preloaded in templateCache -->\n *  <md-icon md-svg-src=\"/android.svg\"       aria-label=\"android \" ></md-icon>\n *  <md-icon md-svg-src=\"{{ getAndroid() }}\" aria-label=\"android \" ></md-icon>\n *\n * </hljs>\n *\n * Use the <code>$mdIconProvider</code> to configure your application with\n * svg iconsets.\n *\n * <hljs lang=\"js\">\n *  angular.module('appSvgIconSets', ['ngMaterial'])\n *    .controller('DemoCtrl', function($scope) {})\n *    .config(function($mdIconProvider) {\n *      $mdIconProvider\n *         .iconSet('social', 'img/icons/sets/social-icons.svg', 24)\n *         .defaultIconSet('img/icons/sets/core-icons.svg', 24);\n *     });\n * </hljs>\n *\n *\n * When using Font Icons with classnames:\n * <hljs lang=\"html\">\n *\n *  <md-icon md-font-icon=\"android\" aria-label=\"android\" ></md-icon>\n *  <md-icon class=\"icon_home\"      aria-label=\"Home\"    ></md-icon>\n *\n * </hljs>\n *\n * When using Material Font Icons with ligatures:\n * <hljs lang=\"html\">\n *  <!-- For Material Design Icons -->\n *  <!-- The class '.material-icons' is auto-added. -->\n *  <md-icon> face </md-icon>\n *  <md-icon class=\"md-light md-48\"> face </md-icon>\n *  <md-icon md-font-set=\"material-icons\"> face </md-icon>\n *  <md-icon> #xE87C; </md-icon>\n * </hljs>\n *\n * When using other Font-Icon libraries:\n *\n * <hljs lang=\"js\">\n *  // Specify a font-icon style alias\n *  angular.config(function($mdIconProvider) {\n *    $mdIconProvider.fontSet('fa', 'fontawesome');\n *  });\n * </hljs>\n *\n * <hljs lang=\"html\">\n *  <md-icon md-font-set=\"fa\">email</md-icon>\n * </hljs>\n *\n */\nfunction mdIconDirective($mdIcon, $mdTheming, $mdAria, $interpolate ) {\n\n  return {\n    scope: {\n      fontSet : '@mdFontSet',\n      fontIcon: '@mdFontIcon',\n      svgIcon : '@mdSvgIcon',\n      svgSrc  : '@mdSvgSrc'\n    },\n    restrict: 'E',\n    link : postLink\n  };\n\n\n  /**\n   * Directive postLink\n   * Supports embedded SVGs, font-icons, & external SVGs\n   */\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n\n    prepareForFontIcon();\n\n    // If using a font-icon, then the textual name of the icon itself\n    // provides the aria-label.\n\n    var label = attr.alt || scope.fontIcon || scope.svgIcon || element.text();\n    var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');\n\n    if ( !attr['aria-label'] ) {\n\n      if (label != '' && !parentsHaveText() ) {\n\n        $mdAria.expect(element, 'aria-label', label);\n        $mdAria.expect(element, 'role', 'img');\n\n      } else if ( !element.text() ) {\n        // If not a font-icon with ligature, then\n        // hide from the accessibility layer.\n\n        $mdAria.expect(element, 'aria-hidden', 'true');\n      }\n    }\n\n    if (attrName) {\n      // Use either pre-configured SVG or URL source, respectively.\n      attr.$observe(attrName, function(attrVal) {\n\n        element.empty();\n        if (attrVal) {\n          $mdIcon(attrVal).then(function(svg) {\n            element.append(svg);\n          });\n        }\n\n      });\n    }\n\n    function parentsHaveText() {\n      var parent = element.parent();\n      if (parent.attr('aria-label') || parent.text()) {\n        return true;\n      }\n      else if(parent.parent().attr('aria-label') || parent.parent().text()) {\n        return true;\n      }\n      return false;\n    }\n\n    function prepareForFontIcon () {\n      if (!scope.svgIcon && !scope.svgSrc) {\n        if (scope.fontIcon) {\n          element.addClass('md-font');\n          element.addClass(scope.fontIcon);\n        } else {\n          element.addClass($mdIcon.fontSet(scope.fontSet));\n        }\n      }\n\n    }\n  }\n}\nmdIconDirective.$inject = [\"$mdIcon\", \"$mdTheming\", \"$mdAria\", \"$interpolate\"];\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n    .module('material.components.icon' )\n    .provider('$mdIcon', MdIconProvider);\n\n  /**\n    * @ngdoc service\n    * @name $mdIconProvider\n    * @module material.components.icon\n    *\n    * @description\n    * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow\n    * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`\n    * directives are compiled.\n    *\n    * If using font-icons, the developer is repsonsible for loading the fonts.\n    *\n    * If using SVGs, loading of the actual svg files are deferred to on-demand requests and are loaded\n    * internally by the `$mdIcon` service using the `$http` service. When an SVG is requested by name/ID,\n    * the `$mdIcon` service searches its registry for the associated source URL;\n    * that URL is used to on-demand load and parse the SVG dynamically.\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultFontSet( 'fontawesome' )\n    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons\n    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs\n    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n    *   });\n    * </hljs>\n    *\n    * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime\n    * **startup** process (shown below):\n    *\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Register a default set of SVG icon definitions\n    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')\n    *\n    *   })\n    *   .run(function($http, $templateCache){\n    *\n    *     // Pre-fetch icons sources by URL and cache in the $templateCache...\n    *     // subsequent $http calls will look there first.\n    *\n    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];\n    *\n    *     angular.forEach(urls, function(url) {\n    *       $http.get(url, {cache: $templateCache});\n    *     });\n    *\n    *   });\n    *\n    * </hljs>\n    *\n    * NOTE: the loaded SVG data is subsequently cached internally for future requests.\n    *\n    */\n\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#icon\n    *\n    * @description\n    * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.\n    * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`\n    *\n    * @param {string} id Icon name/id used to register the icon\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {number=} viewBoxSize Sets the width and height the icon's viewBox.\n    * It is ignored for icons with an existing viewBox. Default size is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n    *   });\n    * </hljs>\n    *\n    */\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#iconSet\n    *\n    * @description\n    * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition\n    * has an icon id. Individual icons can be subsequently retrieved from this cached set using\n    * `$mdIcon(<icon set name>:<icon name>)`\n    *\n    * @param {string} id Icon name/id used to register the iconset\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set. \n    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.\n    * Default value is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set\n    *   });\n    * </hljs>\n    *\n    */\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#defaultIconSet\n    *\n    * @description\n    * Register a source URL for the default 'named' set of icons. Unless explicitly registered,\n    * subsequent lookups of icons will failover to search this 'default' icon set.\n    * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`\n    *\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set. \n    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.\n    * Default value is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set\n    *   });\n    * </hljs>\n    *\n    */\n  /**\n   * @ngdoc method\n   * @name $mdIconProvider#defaultFontSet\n   *\n   * @description\n   * When using Font-Icons, Angular Material assumes the the Material Design icons will be used and automatically\n   * configures the default font-set == 'material-icons'. Note that the font-set references the font-icon library\n   * class style that should be applied to the `<md-icon>`.\n   *\n   * Configuring the default means that the attributes\n   * `md-font-set=\"material-icons\"` or `class=\"material-icons\"` do not need to be explicitly declared on the\n   * `<md-icon>` markup. For example:\n   *\n   *  `<md-icon> face </md-icon>`\n   *  will render as\n   *  `<span class=\"material-icons\"> face </span>`, and\n   *\n   *  `<md-icon md-font-set=\"fa\"> face </md-icon>`\n   *  will render as\n   *  `<span class=\"fa\"> face </span>`\n   *\n   * @param {string} name of the font-library style that should be applied to the md-icon DOM element\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   *   app.config(function($mdIconProvider) {\n   *     $mdIconProvider.defaultFontSet( 'fontawesome' );\n   *   });\n   * </hljs>\n   *\n   */\n\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#defaultViewBoxSize\n    *\n    * @description\n    * While `<md-icon />` markup can also be style with sizing CSS, this method configures\n    * the default width **and** height used for all icons; unless overridden by specific CSS.\n    * The default sizing is (24px, 24px).\n    * @param {number=} viewBoxSize Sets the width and height of the viewBox for an icon or an icon set.\n    * All icons in a set should be the same size. The default value is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultViewBoxSize(36)   // Register a default icon size (width == height)\n    *   });\n    * </hljs>\n    *\n    */\n\n var config = {\n   defaultViewBoxSize: 24,\n   defaultFontSet: 'material-icons',\n   fontSets : [ ]\n };\n\n function MdIconProvider() { }\n\n MdIconProvider.prototype = {\n   icon : function (id, url, viewBoxSize) {\n     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\n     config[id] = new ConfigurationItem(url, viewBoxSize );\n     return this;\n   },\n\n   iconSet : function (id, url, viewBoxSize) {\n     config[id] = new ConfigurationItem(url, viewBoxSize );\n     return this;\n   },\n\n   defaultIconSet : function (url, viewBoxSize) {\n     var setName = '$default';\n\n     if ( !config[setName] ) {\n       config[setName] = new ConfigurationItem(url, viewBoxSize );\n     }\n\n     config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;\n\n     return this;\n   },\n\n   defaultViewBoxSize : function (viewBoxSize) {\n     config.defaultViewBoxSize = viewBoxSize;\n     return this;\n   },\n   \n   /**\n    * Register an alias name associated with a font-icon library style ;\n    */\n   fontSet : function fontSet(alias, className) {\n    config.fontSets.push({\n      alias : alias,\n      fontSet : className || alias\n    });\n   },\n\n   /**\n    * Specify a default style name associated with a font-icon library\n    * fallback to Material Icons.\n    *\n    */\n   defaultFontSet : function defaultFontSet(className) {\n    config.defaultFontSet = !className ? '' : className;\n    return this;\n   },\n\n   defaultIconSize : function defaultIconSize(iconSize) {\n     config.defaultIconSize = iconSize;\n     return this;\n   },\n\n   preloadIcons: function ($templateCache) {\n     var iconProvider = this;\n     var svgRegistry = [\n       {\n         id : 'md-tabs-arrow',\n         url: 'md-tabs-arrow.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><polygon points=\"15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 \"/></g></svg>'\n       },\n       {\n         id : 'md-close',\n         url: 'md-close.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z\"/></g></svg>'\n       },\n       {\n         id:  'md-cancel',\n         url: 'md-cancel.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z\"/></g></svg>'\n       },\n       {\n         id:  'md-menu',\n         url: 'md-menu.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\"><path d=\"M 50 0 L 100 14 L 92 80 L 50 100 L 8 80 L 0 14 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 5 L 6 18 L 13.5 77 L 50 94 Z\" fill=\"#E42939\"></path><path d=\"M 50 5 L 94 18 L 86.5 77 L 50 94 Z\" fill=\"#B72833\"></path><path d=\"M 50 7 L 83 75 L 72 75 L 65 59 L 50 59 L 50 50 L 61 50 L 50 26 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 7 L 17 75 L 28 75 L 35 59 L 50 59 L 50 50 L 39 50 L 50 26 Z\" fill=\"#fff\"></path></svg>'\n       },\n       {\n         id:  'md-toggle-arrow',\n         url: 'md-toggle-arrow-svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 48 48\"><path d=\"M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z\"/><path d=\"M0 0h48v48h-48z\" fill=\"none\"/></svg>'\n       }\n     ];\n\n     svgRegistry.forEach(function(asset){\n       iconProvider.icon(asset.id,  asset.url);\n       $templateCache.put(asset.url, asset.svg);\n     });\n\n   },\n\n   $get : ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {\n     this.preloadIcons($templateCache);\n     return MdIconService(config, $http, $q, $log, $templateCache);\n   }]\n };\n\n   /**\n    *  Configuration item stored in the Icon registry; used for lookups\n    *  to load if not already cached in the `loaded` cache\n    */\n   function ConfigurationItem(url, viewBoxSize) {\n     this.url = url;\n     this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;\n   }\n\n /**\n  * @ngdoc service\n  * @name $mdIcon\n  * @module material.components.icon\n  *\n  * @description\n  * The `$mdIcon` service is a function used to lookup SVG icons.\n  *\n  * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element\n  * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is\n  * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.\n  *\n  * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured\n  * using the `$mdIconProvider`.\n  *\n  * @returns {obj} Clone of the initial SVG DOM element; which was created from the SVG markup in the SVG data file.\n  *\n  * @usage\n  * <hljs lang=\"js\">\n  * function SomeDirective($mdIcon) {\n  *\n  *   // See if the icon has already been loaded, if not\n  *   // then lookup the icon from the registry cache, load and cache\n  *   // it for future requests.\n  *   // NOTE: ID queries require configuration with $mdIconProvider\n  *\n  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });\n  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });\n  *\n  *   // Load and cache the external SVG using a URL\n  *\n  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {\n  *     element.append(iconEl);\n  *   });\n  * };\n  * </hljs>\n  *\n  * NOTE: The `<md-icon />  ` directive internally uses the `$mdIcon` service to query, loaded, and instantiate\n  * SVG DOM elements.\n  */\n function MdIconService(config, $http, $q, $log, $templateCache) {\n   var iconCache = {};\n   var urlRegex = /[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,4}\\b(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?/i;\n\n   Icon.prototype = { clone : cloneSVG, prepare: prepareAndStyle };\n   getIcon.fontSet = findRegisteredFontSet;\n\n   // Publish service...\n   return getIcon;\n\n   /**\n    * Actual $mdIcon service is essentially a lookup function\n    */\n   function getIcon(id) {\n     id = id || '';\n\n     // If already loaded and cached, use a clone of the cached icon.\n     // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.\n\n     if ( iconCache[id]         ) return $q.when( iconCache[id].clone() );\n     if ( urlRegex.test(id)     ) return loadByURL(id).then( cacheIcon(id) );\n     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\n     return loadByID(id)\n         .catch(loadFromIconSet)\n         .catch(announceIdNotFound)\n         .catch(announceNotFound)\n         .then( cacheIcon(id) );\n   }\n\n   /**\n    * Lookup registered fontSet style using its alias...\n    * If not found,\n    */\n   function findRegisteredFontSet(alias) {\n      var useDefault = angular.isUndefined(alias) || !(alias && alias.length);\n      if ( useDefault ) return config.defaultFontSet;\n\n      var result = alias;\n      angular.forEach(config.fontSets, function(it){\n        if ( it.alias == alias ) result = it.fontSet || result;\n      });\n\n      return result;\n   }\n\n   /**\n    * Prepare and cache the loaded icon for the specified `id`\n    */\n   function cacheIcon( id ) {\n\n     return function updateCache( icon ) {\n       iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);\n\n       return iconCache[id].clone();\n     };\n   }\n\n   /**\n    * Lookup the configuration in the registry, if !registered throw an error\n    * otherwise load the icon [on-demand] using the registered URL.\n    *\n    */\n   function loadByID(id) {\n     var iconConfig = config[id];\n\n     return !iconConfig ? $q.reject(id) : loadByURL(iconConfig.url).then(function(icon) {\n       return new Icon(icon, iconConfig);\n     });\n   }\n\n   /**\n    *    Loads the file as XML and uses querySelector( <id> ) to find\n    *    the desired node...\n    */\n   function loadFromIconSet(id) {\n     var setName = id.substring(0, id.lastIndexOf(':')) || '$default';\n     var iconSetConfig = config[setName];\n\n     return !iconSetConfig ? $q.reject(id) : loadByURL(iconSetConfig.url).then(extractFromSet);\n\n     function extractFromSet(set) {\n       var iconName = id.slice(id.lastIndexOf(':') + 1);\n       var icon = set.querySelector('#' + iconName);\n       return !icon ? $q.reject(id) : new Icon(icon, iconSetConfig);\n     }\n   }\n\n   /**\n    * Load the icon by URL (may use the $templateCache).\n    * Extract the data for later conversion to Icon\n    */\n   function loadByURL(url) {\n     return $http\n       .get(url, { cache: $templateCache })\n       .then(function(response) {\n         return angular.element('<div>').append(response.data).find('svg')[0];\n       });\n   }\n\n   /**\n    * User did not specify a URL and the ID has not been registered with the $mdIcon\n    * registry\n    */\n   function announceIdNotFound(id) {\n     var msg;\n\n     if (angular.isString(id)) {\n       msg = 'icon ' + id + ' not found';\n       $log.warn(msg);\n     }\n\n     return $q.reject(msg || id);\n   }\n\n   /**\n    * Catch HTTP or generic errors not related to incorrect icon IDs.\n    */\n   function announceNotFound(err) {\n     var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);\n     $log.warn(msg);\n\n     return $q.reject(msg);\n   }\n\n   /**\n    * Check target signature to see if it is an Icon instance.\n    */\n   function isIcon(target) {\n     return angular.isDefined(target.element) && angular.isDefined(target.config);\n   }\n\n   /**\n    *  Define the Icon class\n    */\n   function Icon(el, config) {\n     if (el.tagName != 'svg') {\n       el = angular.element('<svg xmlns=\"http://www.w3.org/2000/svg\">').append(el)[0];\n     }\n\n     // Inject the namespace if not available...\n     if ( !el.getAttribute('xmlns') ) {\n       el.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n     }\n\n     this.element = el;\n     this.config = config;\n     this.prepare();\n   }\n\n   /**\n    *  Prepare the DOM element that will be cached in the\n    *  loaded iconCache store.\n    */\n   function prepareAndStyle() {\n     var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;\n         angular.forEach({\n           'fit'   : '',\n           'height': '100%',\n           'width' : '100%',\n           'preserveAspectRatio': 'xMidYMid meet',\n           'viewBox' : this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize)\n         }, function(val, attr) {\n           this.element.setAttribute(attr, val);\n         }, this);\n\n         angular.forEach({\n           'pointer-events' : 'none',\n           'display' : 'block'\n         }, function(val, style) {\n           this.element.style[style] = val;\n         }, this);\n   }\n\n   /**\n    * Clone the Icon DOM element.\n    */\n   function cloneSVG(){\n     return this.element.cloneNode(true);\n   }\n\n }\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.input\n */\n\nangular.module('material.components.input', [\n  'material.core'\n])\n  .directive('mdInputContainer', mdInputContainerDirective)\n  .directive('label', labelDirective)\n  .directive('input', inputTextareaDirective)\n  .directive('textarea', inputTextareaDirective)\n  .directive('mdMaxlength', mdMaxlengthDirective)\n  .directive('placeholder', placeholderDirective);\n\n/**\n * @ngdoc directive\n * @name mdInputContainer\n * @module material.components.input\n *\n * @restrict E\n *\n * @description\n * `<md-input-container>` is the parent of any input or textarea element.\n *\n * Input and textarea elements will not behave properly unless the md-input-container\n * parent is provided.\n *\n * @param md-is-error {expression=} When the given expression evaluates to true, the input container will go into error state. Defaults to erroring if the input has been touched and is invalid.\n * @param md-no-float {boolean=} When present, placeholders will not be converted to floating labels\n *\n * @usage\n * <hljs lang=\"html\">\n *\n * <md-input-container>\n *   <label>Username</label>\n *   <input type=\"text\" ng-model=\"user.name\">\n * </md-input-container>\n *\n * <md-input-container>\n *   <label>Description</label>\n *   <textarea ng-model=\"user.description\"></textarea>\n * </md-input-container>\n *\n * </hljs>\n */\nfunction mdInputContainerDirective($mdTheming, $parse) {\n  ContainerCtrl.$inject = [\"$scope\", \"$element\", \"$attrs\"];\n  return {\n    restrict: 'E',\n    link: postLink,\n    controller: ContainerCtrl\n  };\n\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n  }\n  function ContainerCtrl($scope, $element, $attrs) {\n    var self = this;\n\n    self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);\n\n    self.delegateClick = function() {\n      self.input.focus();\n    };\n    self.element = $element;\n    self.setFocused = function(isFocused) {\n      $element.toggleClass('md-input-focused', !!isFocused);\n    };\n    self.setHasValue = function(hasValue) {\n      $element.toggleClass('md-input-has-value', !!hasValue);\n    };\n    self.setInvalid = function(isInvalid) {\n      $element.toggleClass('md-input-invalid', !!isInvalid);\n    };\n    $scope.$watch(function() {\n      return self.label && self.input;\n    }, function(hasLabelAndInput) {\n      if (hasLabelAndInput && !self.label.attr('for')) {\n        self.label.attr('for', self.input.attr('id'));\n      }\n    });\n  }\n}\nmdInputContainerDirective.$inject = [\"$mdTheming\", \"$parse\"];\n\nfunction labelDirective() {\n  return {\n    restrict: 'E',\n    require: '^?mdInputContainer',\n    link: function(scope, element, attr, containerCtrl) {\n      if (!containerCtrl || attr.mdNoFloat) return;\n\n      containerCtrl.label = element;\n      scope.$on('$destroy', function() {\n        containerCtrl.label = null;\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name mdInput\n * @restrict E\n * @module material.components.input\n *\n * @description\n * Use the `<input>` or the  `<textarea>` as a child of an `<md-input-container>`.\n *\n * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is specified, a character counter will be shown underneath the input.<br/><br/>\n * The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't want the counter text and only need \"plain\" validation, you can use the \"simple\" `ng-maxlength` or maxlength attributes.\n * @param {string=} aria-label Aria-label is required when no label is present.  A warning message will be logged in the console if not present.\n * @param {string=} placeholder An alternative approach to using aria-label when the label is not present.  The placeholder text is copied to the aria-label attribute.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-input-container>\n *   <label>Color</label>\n *   <input type=\"text\" ng-model=\"color\" required md-maxlength=\"10\">\n * </md-input-container>\n * </hljs>\n * <h3>With Errors</h3>\n *\n * <hljs lang=\"html\">\n * <form name=\"userForm\">\n *   <md-input-container>\n *     <label>Last Name</label>\n *     <input name=\"lastName\" ng-model=\"lastName\" required md-maxlength=\"10\" minlength=\"4\">\n *     <div ng-messages=\"userForm.lastName.$error\" ng-show=\"userForm.lastName.$dirty\">\n *       <div ng-message=\"required\">This is required!</div>\n *       <div ng-message=\"md-maxlength\">That's too long!</div>\n *       <div ng-message=\"minlength\">That's too short!</div>\n *     </div>\n *   </md-input-container>\n *   <md-input-container>\n *     <label>Biography</label>\n *     <textarea name=\"bio\" ng-model=\"biography\" required md-maxlength=\"150\"></textarea>\n *     <div ng-messages=\"userForm.bio.$error\" ng-show=\"userForm.bio.$dirty\">\n *       <div ng-message=\"required\">This is required!</div>\n *       <div ng-message=\"md-maxlength\">That's too long!</div>\n *     </div>\n *   </md-input-container>\n *   <md-input-container>\n *     <input aria-label='title' ng-model='title'>\n *   </md-input-container>\n *   <md-input-container>\n *     <input placeholder='title' ng-model='title'>\n *   </md-input-container>\n * </form>\n * </hljs>\n *\n * Requires [ngMessages](https://docs.angularjs.org/api/ngMessages).\n * Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).\n *\n */\n\nfunction inputTextareaDirective($mdUtil, $window, $mdAria) {\n  return {\n    restrict: 'E',\n    require: ['^?mdInputContainer', '?ngModel'],\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrls) {\n\n    var containerCtrl = ctrls[0];\n    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n    var isReadonly = angular.isDefined(attr.readonly);\n\n    if ( !containerCtrl ) return;\n    if (containerCtrl.input) {\n      throw new Error(\"<md-input-container> can only have *one* <input> or <textarea> child element!\");\n    }\n    containerCtrl.input = element;\n\n    if(!containerCtrl.label) {\n      $mdAria.expect(element, 'aria-label', element.attr('placeholder'));\n    }\n\n    element.addClass('md-input');\n    if (!element.attr('id')) {\n      element.attr('id', 'input_' + $mdUtil.nextUid());\n    }\n\n    if (element[0].tagName.toLowerCase() === 'textarea') {\n      setupTextarea();\n    }\n\n    var isErrorGetter = containerCtrl.isErrorGetter || function() {\n      return ngModelCtrl.$invalid && ngModelCtrl.$touched;\n    };\n    scope.$watch(isErrorGetter, containerCtrl.setInvalid);\n\n    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);\n    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);\n\n    element.on('input', inputCheckValue);\n\n    if (!isReadonly) {\n      element\n        .on('focus', function(ev) {\n          containerCtrl.setFocused(true);\n        })\n        .on('blur', function(ev) {\n          containerCtrl.setFocused(false);\n          inputCheckValue();\n        });\n\n    }\n\n    //ngModelCtrl.$setTouched();\n    //if( ngModelCtrl.$invalid ) containerCtrl.setInvalid();\n\n    scope.$on('$destroy', function() {\n      containerCtrl.setFocused(false);\n      containerCtrl.setHasValue(false);\n      containerCtrl.input = null;\n    });\n\n    /**\n     *\n     */\n    function ngModelPipelineCheckValue(arg) {\n      containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));\n      return arg;\n    }\n    function inputCheckValue() {\n      // An input's value counts if its length > 0,\n      // or if the input's validity state says it has bad input (eg string in a number input)\n      containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity||{}).badInput);\n    }\n\n    function setupTextarea() {\n      var node = element[0];\n      var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);\n\n      function pipelineListener(value) {\n        onChangeTextarea();\n        return value;\n      }\n\n      if (ngModelCtrl) {\n        ngModelCtrl.$formatters.push(pipelineListener);\n        ngModelCtrl.$viewChangeListeners.push(pipelineListener);\n      } else {\n        onChangeTextarea();\n      }\n      element.on('keydown input', onChangeTextarea);\n      element.on('scroll', onScroll);\n      angular.element($window).on('resize', onChangeTextarea);\n\n      scope.$on('$destroy', function() {\n        angular.element($window).off('resize', onChangeTextarea);\n      });\n\n      function growTextarea() {\n        node.style.height = \"auto\";\n        node.scrollTop = 0;\n        var height = getHeight();\n        if (height) node.style.height = height + 'px';\n      }\n\n      function getHeight () {\n        var line = node.scrollHeight - node.offsetHeight;\n        return node.offsetHeight + (line > 0 ? line : 0);\n      }\n\n      function onScroll(e) {\n        node.scrollTop = 0;\n        // for smooth new line adding\n        var line = node.scrollHeight - node.offsetHeight;\n        var height = node.offsetHeight + line;\n        node.style.height = height + 'px';\n      }\n    }\n  }\n}\ninputTextareaDirective.$inject = [\"$mdUtil\", \"$window\", \"$mdAria\"];\n\nfunction mdMaxlengthDirective($animate) {\n  return {\n    restrict: 'A',\n    require: ['ngModel', '^mdInputContainer'],\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrls) {\n    var maxlength;\n    var ngModelCtrl = ctrls[0];\n    var containerCtrl = ctrls[1];\n    var charCountEl = angular.element('<div class=\"md-char-counter\">');\n\n    // Stop model from trimming. This makes it so whitespace\n    // over the maxlength still counts as invalid.\n    attr.$set('ngTrim', 'false');\n    containerCtrl.element.append(charCountEl);\n\n    ngModelCtrl.$formatters.push(renderCharCount);\n    ngModelCtrl.$viewChangeListeners.push(renderCharCount);\n    element.on('input keydown', function() {\n      renderCharCount(); //make sure it's called with no args\n    });\n\n    scope.$watch(attr.mdMaxlength, function(value) {\n      maxlength = value;\n      if (angular.isNumber(value) && value > 0) {\n        if (!charCountEl.parent().length) {\n          $animate.enter(charCountEl, containerCtrl.element,\n                         angular.element(containerCtrl.element[0].lastElementChild));\n        }\n        renderCharCount();\n      } else {\n        $animate.leave(charCountEl);\n      }\n    });\n\n    ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {\n      if (!angular.isNumber(maxlength) || maxlength < 0) {\n        return true;\n      }\n      return ( modelValue || element.val() || viewValue || '' ).length <= maxlength;\n    };\n\n    function renderCharCount(value) {\n      charCountEl.text( ( element.val() || value || '' ).length + '/' + maxlength );\n      return value;\n    }\n  }\n}\nmdMaxlengthDirective.$inject = [\"$animate\"];\n\nfunction placeholderDirective($log) {\n  var blackListElements = ['MD-SELECT'];\n  return {\n    restrict: 'A',\n    require: '^^?mdInputContainer',\n    priority: 200,\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, inputContainer) {\n    if (!inputContainer) return;\n    if (blackListElements.indexOf(element[0].nodeName) != -1) return;\n    if (angular.isDefined(inputContainer.element.attr('md-no-float'))) return;\n\n    var placeholderText = attr.placeholder;\n    element.removeAttr('placeholder');\n\n    if ( inputContainer.element.find('label').length == 0 ) {\n      var placeholder = '<label ng-click=\"delegateClick()\">' + placeholderText + '</label>';\n\n      inputContainer.element.addClass('md-icon-float');\n      inputContainer.element.prepend(placeholder);\n    } else {\n      $log.warn(\"The placeholder='\" + placeholderText + \"' will be ignored since this md-input-container has a child label element.\");\n    }\n\n  }\n}\nplaceholderDirective.$inject = [\"$log\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.list\n * @description\n * List module\n */\nangular.module('material.components.list', [\n  'material.core'\n])\n  .controller('MdListController', MdListController)\n  .directive('mdList', mdListDirective)\n  .directive('mdListItem', mdListItemDirective);\n\n/**\n * @ngdoc directive\n * @name mdList\n * @module material.components.list\n *\n * @restrict E\n *\n * @description\n * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-list>\n *   <md-list-item class=\"md-2-line\" ng-repeat=\"item in todos\">\n *     <md-checkbox ng-model=\"item.done\"></md-checkbox>\n *     <div class=\"md-list-item-text\">\n *       <h3>{{item.title}}</h3>\n *       <p>{{item.description}}</p>\n *     </div>\n *   </md-list-item>\n * </md-list>\n * </hljs>\n */\n\nfunction mdListDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    compile: function(tEl) {\n      tEl[0].setAttribute('role', 'list');\n      return $mdTheming;\n    }\n  };\n}\nmdListDirective.$inject = [\"$mdTheming\"];\n/**\n * @ngdoc directive\n * @name mdListItem\n * @module material.components.list\n *\n * @restrict E\n *\n * @description\n * The `<md-list-item>` directive is a container intended for row items in a `<md-list>` container.\n *\n * @usage\n * <hljs lang=\"html\">\n *  <md-list>\n *    <md-list-item>\n *            Item content in list\n *    </md-list-item>\n *  </md-list>\n * </hljs>\n *\n */\nfunction mdListItemDirective($mdAria, $mdConstant, $timeout) {\n  var proxiedTypes = ['md-checkbox', 'md-switch'];\n  return {\n    restrict: 'E',\n    controller: 'MdListController',\n    compile: function(tEl, tAttrs) {\n      // Check for proxy controls (no ng-click on parent, and a control inside)\n      var secondaryItem = tEl[0].querySelector('.md-secondary');\n      var hasProxiedElement;\n      var proxyElement;\n\n      tEl[0].setAttribute('role', 'listitem');\n\n      if (!tAttrs.ngClick) {\n        for (var i = 0, type; type = proxiedTypes[i]; ++i) {\n          if (proxyElement = tEl[0].querySelector(type)) {\n            hasProxiedElement = true;\n            break;\n          }\n        }\n        if (hasProxiedElement) {\n          wrapIn('div');\n        } else if (!tEl[0].querySelector('md-button')) {\n          tEl.addClass('md-no-proxy');\n        }\n      } else {\n        wrapIn('button');\n      }\n      setupToggleAria();\n\n\n      function setupToggleAria() {\n        var toggleTypes = ['md-switch', 'md-checkbox'];\n        var toggle;\n\n        for (var i = 0, toggleType; toggleType = toggleTypes[i]; ++i) {\n          if (toggle = tEl.find(toggleType)[0]) {\n            if (!toggle.hasAttribute('aria-label')) {\n              var p = tEl.find('p')[0];\n              if (!p) return;\n              toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);\n            }\n          }\n        }\n      }\n\n      function wrapIn(type) {\n        var container;\n        if (type == 'div') {\n          container = angular.element('<div class=\"md-no-style md-list-item-inner\">');\n          container.append(tEl.contents());\n          tEl.addClass('md-proxy-focus');\n        } else {\n          container = angular.element('<md-button class=\"md-no-style\"><div class=\"md-list-item-inner\"></div></md-button>');\n          var copiedAttrs = ['ng-click', 'aria-label', 'ng-disabled'];\n          angular.forEach(copiedAttrs, function(attr) {\n            if (tEl[0].hasAttribute(attr)) {\n              container[0].setAttribute(attr, tEl[0].getAttribute(attr));\n              tEl[0].removeAttribute(attr);\n            }\n          });\n          container.children().eq(0).append(tEl.contents());\n        }\n\n        tEl[0].setAttribute('tabindex', '-1');\n        tEl.append(container);\n\n        if (secondaryItem && secondaryItem.hasAttribute('ng-click')) {\n          $mdAria.expect(secondaryItem, 'aria-label');\n          var buttonWrapper = angular.element('<md-button class=\"md-secondary-container md-icon-button\">');\n          buttonWrapper.attr('ng-click', secondaryItem.getAttribute('ng-click'));\n          secondaryItem.removeAttribute('ng-click');\n          secondaryItem.setAttribute('tabindex', '-1');\n          secondaryItem.classList.remove('md-secondary');\n          buttonWrapper.append(secondaryItem);\n          secondaryItem = buttonWrapper[0];\n        }\n\n        // Check for a secondary item and move it outside\n        if ( secondaryItem && (\n          secondaryItem.hasAttribute('ng-click') ||\n            ( tAttrs.ngClick &&\n             isProxiedElement(secondaryItem) )\n        )) {\n          tEl.addClass('md-with-secondary');\n          tEl.append(secondaryItem);\n        }\n      }\n\n      function isProxiedElement(el) {\n        return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;\n      }\n\n      return postLink;\n\n      function postLink($scope, $element, $attr, ctrl) {\n\n        var proxies    = [],\n            firstChild = $element[0].firstElementChild,\n            hasClick   = firstChild && firstChild.hasAttribute('ng-click');\n\n        computeProxies();\n        computeClickable();\n\n        if ($element.hasClass('md-proxy-focus') && proxies.length) {\n          angular.forEach(proxies, function(proxy) {\n            proxy = angular.element(proxy);\n\n            $scope.mouseActive = false;\n            proxy.on('mousedown', function() {\n              $scope.mouseActive = true;\n              $timeout(function(){\n                $scope.mouseActive = false;\n              }, 100);\n            })\n            .on('focus', function() {\n              if ($scope.mouseActive === false) { $element.addClass('md-focused'); }\n              proxy.on('blur', function proxyOnBlur() {\n                $element.removeClass('md-focused');\n                proxy.off('blur', proxyOnBlur);\n              });\n            });\n          });\n        }\n\n        function computeProxies() {\n          var children = $element.children();\n          if (children.length && !children[0].hasAttribute('ng-click')) {\n            angular.forEach(proxiedTypes, function(type) {\n              angular.forEach(firstChild.querySelectorAll(type), function(child) {\n                proxies.push(child);\n              });\n            });\n          }\n        }\n        function computeClickable() {\n          if (proxies.length || hasClick) {\n            $element.addClass('md-clickable');\n\n            ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));\n          }\n        }\n\n        if (!hasClick && !proxies.length) {\n          firstChild && firstChild.addEventListener('keypress', function(e) {\n            if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA') {\n              var keyCode = e.which || e.keyCode;\n              if (keyCode == $mdConstant.KEY_CODE.SPACE) {\n                if (firstChild) {\n                  firstChild.click();\n                  e.preventDefault();\n                  e.stopPropagation();\n                }\n              }\n            }\n          });\n        }\n\n        $element.off('click');\n        $element.off('keypress');\n\n        if (proxies.length && firstChild) {\n          $element.children().eq(0).on('click', function(e) {\n            if (firstChild.contains(e.target)) {\n              angular.forEach(proxies, function(proxy) {\n                if (e.target !== proxy && !proxy.contains(e.target)) {\n                  angular.element(proxy).triggerHandler('click');\n                }\n              });\n            }\n          });\n        }\n      }\n    }\n  };\n}\nmdListItemDirective.$inject = [\"$mdAria\", \"$mdConstant\", \"$timeout\"];\n\n/*\n * @private\n * @ngdoc controller\n * @name MdListController\n * @module material.components.list\n *\n */\nfunction MdListController($scope, $element, $mdListInkRipple) {\n  var ctrl = this;\n  ctrl.attachRipple = attachRipple;\n\n  function attachRipple (scope, element) {\n    var options = {};\n    $mdListInkRipple.attach(scope, element, options);\n  }\n}\nMdListController.$inject = [\"$scope\", \"$element\", \"$mdListInkRipple\"];\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.menu\n */\n\nangular.module('material.components.menu', [\n  'material.core',\n  'material.components.backdrop'\n])\n.directive('mdMenu', MenuDirective)\n.controller('mdMenuCtrl', MenuController);\n\n/**\n * @ngdoc directive\n * @name mdMenu\n * @module material.components.menu\n * @restrict E\n * @description\n *\n * Menus are elements that open when clicked. They are useful for displaying\n * additional options within the context of an action.\n *\n * Every `md-menu` must specify exactly two child elements. The first element is what is\n * left in the DOM and is used to open the menu. This element is called the trigger element.\n * The trigger element's scope has access to `$mdOpenMenu()`\n * which it may call to open the menu.\n *\n * The second element is the `md-menu-content` element which represents the\n * contents of the menu when it is open. Typically this will contain `md-menu-item`s,\n * but you can do custom content as well.\n *\n * <hljs lang=\"html\">\n * <md-menu>\n *  <!-- Trigger element is a md-button with an icon -->\n *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\" aria-label=\"Open sample menu\">\n *    <md-icon md-svg-icon=\"call:phone\"></md-icon>\n *  </md-button>\n *  <md-menu-content>\n *    <md-menu-item><md-button ng-click=\"doSomething()\">Do Something</md-button></md-menu-item>\n *  </md-menu-content>\n * </md-menu>\n * </hljs>\n\n * ## Sizing Menus\n *\n * The width of the menu when it is open may be specified by specifying a `width`\n * attribute on the `md-menu-content` element.\n * See the [Material Design Spec](http://www.google.com/design/spec/components/menus.html#menus-specs)\n * for more information.\n *\n *\n * ## Aligning Menus\n *\n * When a menu opens, it is important that the content aligns with the trigger element.\n * Failure to align menus can result in jarring experiences for users as content\n * suddenly shifts. To help with this, `md-menu` provides serveral APIs to help\n * with alignment.\n *\n * ### Target Mode\n *\n * By default, `md-menu` will attempt to align the `md-menu-content` by aligning\n * designated child elements in both the trigger and the menu content.\n *\n * To specify the alignment element in the `trigger` you can use the `md-menu-origin`\n * attribute on a child element. If no `md-menu-origin` is specified, the `md-menu`\n * will be used as the origin element.\n *\n * Similarly, the `md-menu-content` may specify a `md-menu-align-target` for a\n * `md-menu-item` to specify the node that it should try and align with.\n *\n * In this example code, we specify an icon to be our origin element, and an\n * icon in our menu content to be our alignment target. This ensures that both\n * icons are aligned when the menu opens.\n *\n * <hljs lang=\"html\">\n * <md-menu>\n *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\" aria-label=\"Open some menu\">\n *    <md-icon md-menu-origin md-svg-icon=\"call:phone\"></md-icon>\n *  </md-button>\n *  <md-menu-content>\n *    <md-menu-item>\n *      <md-button ng-click=\"doSomething()\" aria-label=\"Do something\">\n *        <md-icon md-menu-align-target md-svg-icon=\"call:phone\"></md-icon>\n *        Do Something\n *      </md-button>\n *    </md-menu-item>\n *  </md-menu-content>\n * </md-menu>\n * </hljs>\n *\n * Sometimes we want to specify alignment on the right side of an element, for example\n * if we have a menu on the right side a toolbar, we want to right align our menu content.\n *\n * We can specify the origin by using the `md-position-mode` attribute on both\n * the `x` and `y` axis. Right now only the `x-axis` has more than one option.\n * You may specify the default mode of `target target` or\n * `target-right target` to specify a right-oriented alignment target. See the\n * position section of the demos for more examples.\n *\n * ### Menu Offsets\n *\n * It is sometimes unavoidable to need to have a deeper level of control for\n * the positioning of a menu to ensure perfect alignment. `md-menu` provides\n * the `md-offset` attribute to allow pixel level specificty of adjusting the\n * exact positioning.\n *\n * This offset is provided in the format of `x y` or `n` where `n` will be used\n * in both the `x` and `y` axis.\n *\n * For example, to move a menu by `2px` from the top, we can use:\n * <hljs lang=\"html\">\n * <md-menu md-offset=\"2 0\">\n *   <!-- menu-content -->\n * </md-menu>\n * </hljs>\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-menu>\n *  <md-button ng-click=\"$mdOpenMenu()\" class=\"md-icon-button\">\n *    <md-icon md-svg-icon=\"call:phone\"></md-icon>\n *  </md-button>\n *  <md-menu-content>\n *    <md-menu-item><md-button ng-click=\"doSomething()\">Do Something</md-button></md-menu-item>\n *  </md-menu-content>\n * </md-menu>\n * </hljs>\n *\n * @param {string} md-position-mode The position mode in the form of\n             `x`, `y`. Default value is `target`,`target`. Right now the `x` axis\n             also suppports `target-right`.\n * @param {string} md-offset An offset to apply to the dropdown after positioning\n             `x`, `y`. Default value is `0`,`0`.\n *\n */\n\nfunction MenuDirective($mdMenu) {\n  return {\n    restrict: 'E',\n    require: 'mdMenu',\n    controller: 'mdMenuCtrl', // empty function to be built by link\n    scope: true,\n    compile: compile\n  };\n\n  function compile(templateElement) {\n    templateElement.addClass('md-menu');\n    var triggerElement = templateElement.children()[0];\n    if (!triggerElement.hasAttribute('ng-click')) {\n      triggerElement = triggerElement.querySelector('[ng-click]');\n    }\n    triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');\n    if (templateElement.children().length != 2) {\n      throw Error('Invalid HTML for md-menu. Expected two children elements.');\n    }\n    return link;\n  }\n\n  function link(scope, element, attrs, mdMenuCtrl) {\n\n    // Move everything into a md-menu-container and pass it to the controller\n    var menuContainer = angular.element(\n      '<div class=\"md-open-menu-container md-whiteframe-z2\"></div>'\n    );\n    var menuContents = element.children()[1];\n    menuContainer.append(menuContents);\n    mdMenuCtrl.init(menuContainer);\n\n    scope.$on('$destroy', function() {\n      if (mdMenuCtrl.isOpen) {\n        menuContainer.remove();\n        mdMenuCtrl.close();\n      }\n    });\n\n  }\n}\nMenuDirective.$inject = [\"$mdMenu\"];\n\nfunction MenuController($mdMenu, $attrs, $element, $scope) {\n\n  var menuContainer;\n  var ctrl = this;\n  var triggerElement;\n\n  // Called by our linking fn to provide access to the menu-content\n  // element removed during link\n  this.init = function(setMenuContainer) {\n    menuContainer = setMenuContainer;\n    triggerElement = $element[0].querySelector('[ng-click]');\n  };\n\n  // Uses the $mdMenu interim element service to open the menu contents\n  this.open = function openMenu() {\n    ctrl.isOpen = true;\n    triggerElement.setAttribute('aria-expanded', 'true');\n    $mdMenu.show({\n      mdMenuCtrl: ctrl,\n      element: menuContainer,\n      target: $element[0]\n    });\n  };\n  // Expose a open function to the child scope for html to use\n  $scope.$mdOpenMenu = this.open;\n\n  // Use the $mdMenu interim element service to close the menu contents\n  this.close = function closeMenu(skipFocus) {\n    ctrl.isOpen = false;\n    triggerElement.setAttribute('aria-expanded', 'false');\n    $mdMenu.hide();\n\n    if (!skipFocus) {\n      $element.children()[0].focus();\n    }\n  };\n\n  // Build a nice object out of our string attribute which specifies the\n  // target mode for left and top positioning\n  this.positionMode = function() {\n    var attachment = ($attrs.mdPositionMode || 'target').split(' ');\n\n    // If attachment is a single item, duplicate it for our second value.\n    // ie. 'target' -> 'target target'\n    if (attachment.length == 1) {\n      attachment.push(attachment[0]);\n    }\n\n    return {\n      left: attachment[0],\n      top: attachment[1]\n    };\n  };\n\n  // Build a nice object out of our string attribute which specifies\n  // the offset of top and left in pixels.\n  this.offsets = function() {\n    var offsets = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);\n    if (offsets.length == 2) {\n      return {\n        left: offsets[0],\n        top: offsets[1]\n      };\n    } else if (offsets.length == 1) {\n      return {\n        top: offsets[0],\n        left: offsets[0]\n      };\n    } else {\n      throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');\n    }\n  };\n}\nMenuController.$inject = [\"$mdMenu\", \"$attrs\", \"$element\", \"$scope\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.components.menu')\n.provider('$mdMenu', MenuProvider);\n\n/*\n * Interim element provider for the menu.\n * Handles behavior for a menu while it is open, including:\n *    - handling animating the menu opening/closing\n *    - handling key/mouse events on the menu element\n *    - handling enabling/disabling scroll while the menu is open\n *    - handling redrawing during resizes and orientation changes\n *\n */\n\nfunction MenuProvider($$interimElementProvider) {\n  var MENU_EDGE_MARGIN = 8;\n\n  menuDefaultOptions.$inject = [\"$$rAF\", \"$window\", \"$mdUtil\", \"$mdTheming\", \"$timeout\", \"$mdConstant\", \"$document\"];\n  return $$interimElementProvider('$mdMenu')\n    .setDefaults({\n      methods: ['target'],\n      options: menuDefaultOptions\n    });\n\n  /* @ngInject */\n  function menuDefaultOptions($$rAF, $window, $mdUtil, $mdTheming, $timeout, $mdConstant, $document) {\n    return {\n      parent: 'body',\n      onShow: onShow,\n      onRemove: onRemove,\n      hasBackdrop: true,\n      disableParentScroll: true,\n      skipCompile: true,\n      themable: true\n    };\n\n    /**\n     * Boilerplate interimElement onShow function\n     * Handles inserting the menu into the DOM, positioning it, and wiring up\n     * various interaction events\n     */\n    function onShow(scope, element, opts) {\n\n      // Sanitize and set defaults on opts\n      buildOpts(opts);\n\n      // Wire up theming on our menu element\n      $mdTheming.inherit(opts.menuContentEl, opts.target);\n\n      // Register various listeners to move menu on resize/orientation change\n      handleResizing();\n\n      // Disable scrolling\n      if (opts.disableParentScroll) {\n        opts.restoreScroll = $mdUtil.disableScrollAround(opts.element);\n      }\n\n      // Only activate click listeners after a short time to stop accidental double taps/clicks\n      // from clicking the wrong item\n      $timeout(activateInteraction, 75, false);\n\n      if (opts.backdrop) {\n        $mdTheming.inherit(opts.backdrop, opts.parent);\n        opts.parent.append(opts.backdrop);\n      }\n      showMenu();\n\n      // Return the promise for when our menu is done animating in\n      return $mdUtil.transitionEndPromise(element, {timeout: 350});\n\n      /** Check for valid opts and set some sane defaults */\n      function buildOpts() {\n        if (!opts.target) {\n          throw Error(\n            '$mdMenu.show() expected a target to animate from in options.target'\n          );\n        }\n        angular.extend(opts, {\n          alreadyOpen: false,\n          isRemoved: false,\n          target: angular.element(opts.target), //make sure it's not a naked dom node\n          parent: angular.element(opts.parent),\n          menuContentEl: angular.element(element[0].querySelector('md-menu-content')),\n          backdrop: opts.hasBackdrop && angular.element('<md-backdrop class=\"md-menu-backdrop md-click-catcher\">')\n        });\n      }\n\n      /** Wireup various resize listeners for screen changes */\n      function handleResizing() {\n        opts.resizeFn = function() {\n          positionMenu(element, opts);\n        };\n        angular.element($window).on('resize', opts.resizeFn);\n        angular.element($window).on('orientationchange', opts.resizeFn);\n      }\n\n      /**\n       * Place the menu into the DOM and call positioning related functions\n       */\n      function showMenu() {\n        opts.parent.append(element);\n\n        element.removeClass('md-leave');\n        // Kick off our animation/positioning but first, wait a few frames\n        // so all of our computed positions/sizes are accurate\n        $$rAF(function() {\n          $$rAF(function() {\n            positionMenu(element, opts);\n            // Wait a frame before fading in menu (md-active) so that we don't trigger\n            // transitions on the menu position changing\n            $$rAF(function() {\n              element.addClass('md-active');\n              opts.alreadyOpen = true;\n              element[0].style[$mdConstant.CSS.TRANSFORM] = '';\n            });\n          });\n        });\n      }\n\n\n      /**\n       * Activate interaction on the menu. Wire up keyboard listerns for\n       * clicks, keypresses, backdrop closing, etc.\n       */\n      function activateInteraction() {\n        element.addClass('md-clickable');\n\n        // close on backdrop click\n        opts.backdrop && opts.backdrop.on('click', function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          opts.mdMenuCtrl.close(true);\n        });\n\n        // Wire up keyboard listeners.\n        // Close on escape, focus next item on down arrow, focus prev item on up\n        opts.menuContentEl.on('keydown', function(ev) {\n          scope.$apply(function() {\n            switch (ev.keyCode) {\n              case $mdConstant.KEY_CODE.ESCAPE: opts.mdMenuCtrl.close(); break;\n              case $mdConstant.KEY_CODE.UP_ARROW: focusMenuItem(ev, opts.menuContentEl, opts, -1); break;\n              case $mdConstant.KEY_CODE.DOWN_ARROW: focusMenuItem(ev, opts.menuContentEl, opts, 1); break;\n            }\n          });\n        });\n\n        // Close menu on menu item click, if said menu-item is not disabled\n        opts.menuContentEl.on('click', function(e) {\n          var target = e.target;\n          // Traverse up the event until we get to the menuContentEl to see if\n          // there is an ng-click and that the ng-click is not disabled\n          do {\n            if (target && target.hasAttribute('ng-click')) {\n              if (!target.hasAttribute('disabled')) {\n                close();\n              }\n              break;\n            }\n          } while ((target = target.parentNode) && target != opts.menuContentEl)\n\n          function close() {\n            scope.$apply(function() {\n              opts.mdMenuCtrl.close();\n            });\n          }\n        });\n\n        // kick off initial focus in the menu on the first element\n        var focusTarget = opts.menuContentEl[0].querySelector('[md-menu-focus-target]');\n        if (!focusTarget) focusTarget = opts.menuContentEl[0].firstElementChild.firstElementChild;\n        focusTarget.focus();\n      }\n    }\n\n    /**\n      * Takes a keypress event and focuses the next/previous menu\n      * item from the emitting element\n      * @param {event} e - The origin keypress event\n      * @param {angular.element} menuEl - The menu element\n      * @param {object} opts - The interim element options for the mdMenu\n      * @param {number} direction - The direction to move in (+1 = next, -1 = prev)\n      */\n    function focusMenuItem(e, menuEl, opts, direction) {\n      var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');\n\n      var items = $mdUtil.nodesToArray(menuEl[0].children);\n      var currentIndex = items.indexOf(currentItem);\n\n      // Traverse through our elements in the specified direction (+/-1) and try to\n      // focus them until we find one that accepts focus\n      for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {\n        var focusTarget = items[i].firstElementChild || items[i];\n        var didFocus = attemptFocus(focusTarget);\n        if (didFocus) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Attempts to focus an element. Checks whether that element is the currently\n     * focused element after attempting.\n     * @param {HTMLElement} el - the element to attempt focus on\n     * @returns {bool} - whether the element was successfully focused\n     */\n    function attemptFocus(el) {\n      if (el && el.getAttribute('tabindex') != -1) {\n        el.focus();\n        if ($document[0].activeElement == el) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Boilerplate interimElement onRemove function\n     * Handles removing the menu from the DOM, cleaning up the element\n     * and removing various listeners\n     */\n    function onRemove(scope, element, opts) {\n      opts.isRemoved = true;\n      element.addClass('md-leave')\n        .removeClass('md-clickable');\n\n      // Disable resizing handlers\n      angular.element($window).off('resize', opts.resizeFn);\n      angular.element($window).off('orientationchange', opts.resizeFn);\n      opts.resizeFn = undefined;\n\n      // Wait for animate out, then remove from the DOM\n      return $mdUtil.transitionEndPromise(element, { timeout: 350 }).then(function() {\n        element.removeClass('md-active');\n        opts.backdrop && opts.backdrop.remove();\n        if (element[0].parentNode === opts.parent[0]) {\n          opts.parent[0].removeChild(element[0]);\n        }\n        opts.restoreScroll && opts.restoreScroll();\n      });\n    }\n\n    /**\n     * Computes menu position and sets the style on the menu container\n     * @param {HTMLElement} el - the menu container element\n     * @param {object} opts - the interim element options object\n     */\n    function positionMenu(el, opts) {\n      if (opts.isRemoved) return;\n\n      var containerNode = el[0],\n          openMenuNode = el[0].firstElementChild,\n          openMenuNodeRect = openMenuNode.getBoundingClientRect(),\n          boundryNode = opts.parent[0],\n          boundryNodeRect = boundryNode.getBoundingClientRect();\n\n      var originNode = opts.target[0].querySelector('[md-menu-origin]') || opts.target[0],\n          originNodeRect = originNode.getBoundingClientRect();\n\n\n      var bounds = {\n        left: boundryNodeRect.left + MENU_EDGE_MARGIN,\n        top: boundryNodeRect.top + MENU_EDGE_MARGIN,\n        bottom: boundryNodeRect.bottom - MENU_EDGE_MARGIN,\n        right: boundryNodeRect.right - MENU_EDGE_MARGIN\n      };\n\n\n      var alignTarget, alignTargetRect, existingOffsets;\n      var positionMode = opts.mdMenuCtrl.positionMode();\n\n      if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {\n        // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child\n        alignTarget = openMenuNode.firstElementChild.firstElementChild || openMenuNode.firstElementChild;\n        alignTarget = alignTarget.querySelector('[md-menu-align-target]') || alignTarget;\n        alignTargetRect = alignTarget.getBoundingClientRect();\n\n        existingOffsets = {\n          top: parseFloat(containerNode.style.top || 0),\n          left: parseFloat(containerNode.style.left || 0)\n        };\n      }\n\n      var position = { };\n      var transformOrigin = 'top ';\n\n      switch (positionMode.top) {\n        case 'target':\n          position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;\n          break;\n        // Future support for mdMenuBar\n        // case 'top':\n        //   position.top = originNodeRect.top;\n        //   break;\n        // case 'bottom':\n        //   position.top = originNodeRect.top + originNodeRect.height;\n        //   break;\n        default:\n          throw new Error('Invalid target mode \"' + positionMode.top + '\" specified for md-menu on Y axis.');\n      }\n\n      switch (positionMode.left) {\n        case 'target':\n          position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;\n          transformOrigin += 'left';\n          break;\n        case 'target-right':\n          position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);\n          transformOrigin += 'right';\n          break;\n        // Future support for mdMenuBar\n        // case 'left':\n        //   position.left = originNodeRect.left;\n        //   transformOrigin += 'left';\n        //   break;\n        // case 'right':\n        //   position.left = originNodeRect.right - containerNode.offsetWidth;\n        //   transformOrigin += 'right';\n        //   break;\n        default:\n          throw new Error('Invalid target mode \"' + positionMode.left + '\" specified for md-menu on X axis.');\n      }\n\n      var offsets = opts.mdMenuCtrl.offsets();\n      position.top += offsets.top;\n      position.left += offsets.left;\n\n      clamp(position);\n\n      el.css({\n        top: position.top + 'px',\n        left: position.left + 'px'\n      });\n\n      containerNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;\n\n      // Animate a scale out if we aren't just repositioning\n      if (!opts.alreadyOpen) {\n        containerNode.style[$mdConstant.CSS.TRANSFORM] = 'scale(' +\n          Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0) + ',' +\n          Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0) +\n        ')';\n      }\n\n      /**\n       * Clamps the repositioning of the menu within the confines of\n       * bounding element (often the screen/body)\n       */\n      function clamp(pos) {\n        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);\n        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);\n      }\n    }\n  }\n}\nMenuProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.progressCircular\n * @description Circular Progress module!\n */\nangular.module('material.components.progressCircular', [\n  'material.core'\n])\n  .directive('mdProgressCircular', MdProgressCircularDirective);\n\n/**\n * @ngdoc directive\n * @name mdProgressCircular\n * @module material.components.progressCircular\n * @restrict E\n *\n* @description\n * The circular progress directive is used to make loading content in your app as delightful and\n * painless as possible by minimizing the amount of visual change a user sees before they can view\n * and interact with content.\n *\n * For operations where the percentage of the operation completed can be determined, use a\n * determinate indicator. They give users a quick sense of how long an operation will take.\n *\n * For operations where the user is asked to wait a moment while something finishes up, and it’s\n * not necessary to expose what's happening behind the scenes and how long it will take, use an\n * indeterminate indicator.\n *\n * @param {string} md-mode Select from one of two modes: determinate and indeterminate.\n * @param {number=} value In determinate mode, this number represents the percentage of the\n *     circular progress. Default: 0\n * @param {number=} md-diameter This specifies the diamter of the circular progress. Default: 48\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-progress-circular md-mode=\"determinate\" value=\"...\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"determinate\" ng-value=\"...\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"determinate\" value=\"...\" md-diameter=\"100\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n * </hljs>\n */\nfunction MdProgressCircularDirective($mdConstant, $mdTheming) {\n  return {\n    restrict: 'E',\n    template:\n        // The progress 'circle' is composed of two half-circles: the left side and the right\n        // side. Each side has CSS applied to 'fill-in' the half-circle to the appropriate progress.\n        '<div class=\"md-spinner-wrapper\">' +\n          '<div class=\"md-inner\">' +\n            '<div class=\"md-gap\"></div>' +\n            '<div class=\"md-left\">' +\n              '<div class=\"md-half-circle\"></div>' +\n            '</div>' +\n            '<div class=\"md-right\">' +\n              '<div class=\"md-half-circle\"></div>' +\n            '</div>' +\n          '</div>' +\n        '</div>',\n    compile: compile\n  };\n\n  function compile(tElement) {\n    // The javascript in this file is mainly responsible for setting the correct aria attributes.\n    // The animation of the progress spinner is done entirely with just CSS.\n    tElement.attr('aria-valuemin', 0);\n    tElement.attr('aria-valuemax', 100);\n    tElement.attr('role', 'progressbar');\n\n    return postLink;\n  }\n\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n    var circle = element[0];\n\n    // Scale the progress circle based on the default diameter.\n    var diameter = attr.mdDiameter || 48;\n    var scale = diameter / 48;\n    circle.style[$mdConstant.CSS.TRANSFORM] = 'scale(' + scale + ')';\n\n    attr.$observe('value', function(value) {\n      var percentValue = clamp(value);\n      element.attr('aria-valuenow', percentValue);\n    });\n  }\n\n  /**\n   * Clamps the value to be between 0 and 100.\n   * @param {number} value The value to clamp.\n   * @returns {number}\n   */\n  function clamp(value) {\n    return Math.max(0, Math.min(value || 0, 100));\n  }\n}\nMdProgressCircularDirective.$inject = [\"$mdConstant\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.progressLinear\n * @description Linear Progress module!\n */\nangular.module('material.components.progressLinear', [\n  'material.core'\n])\n  .directive('mdProgressLinear', MdProgressLinearDirective);\n\n/**\n * @ngdoc directive\n * @name mdProgressLinear\n * @module material.components.progressLinear\n * @restrict E\n *\n * @description\n * The linear progress directive is used to make loading content in your app as delightful and painless as possible by minimizing the amount of visual change a user sees before they can view and interact with content. Each operation should only be represented by one activity indicator—for example, one refresh operation should not display both a refresh bar and an activity circle.\n *\n * For operations where the percentage of the operation completed can be determined, use a determinate indicator. They give users a quick sense of how long an operation will take.\n *\n * For operations where the user is asked to wait a moment while something finishes up, and it’s not necessary to expose what's happening behind the scenes and how long it will take, use an indeterminate indicator.\n *\n * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.\n * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0\n * @param {number=} md-buffer-value In the buffer mode, this number represents the precentage of the secondary progress bar. Default: 0\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-progress-linear md-mode=\"determinate\" value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"determinate\" ng-value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"indeterminate\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"buffer\" value=\"...\" md-buffer-value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"query\"></md-progress-linear>\n * </hljs>\n */\nfunction MdProgressLinearDirective($$rAF, $mdConstant, $mdTheming) {\n\n  return {\n    restrict: 'E',\n    template: '<div class=\"md-container\">' +\n      '<div class=\"md-dashed\"></div>' +\n      '<div class=\"md-bar md-bar1\"></div>' +\n      '<div class=\"md-bar md-bar2\"></div>' +\n      '</div>',\n    compile: compile\n  };\n  \n  function compile(tElement, tAttrs, transclude) {\n    tElement.attr('aria-valuemin', 0);\n    tElement.attr('aria-valuemax', 100);\n    tElement.attr('role', 'progressbar');\n\n    return postLink;\n  }\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n    var bar1Style = element[0].querySelector('.md-bar1').style,\n      bar2Style = element[0].querySelector('.md-bar2').style,\n      container = angular.element(element[0].querySelector('.md-container'));\n\n    attr.$observe('value', function(value) {\n      if (attr.mdMode == 'query') {\n        return;\n      }\n\n      var clamped = clamp(value);\n      element.attr('aria-valuenow', clamped);\n      bar2Style[$mdConstant.CSS.TRANSFORM] = transforms[clamped];\n    });\n\n    attr.$observe('mdBufferValue', function(value) {\n      bar1Style[$mdConstant.CSS.TRANSFORM] = transforms[clamp(value)];\n    });\n\n    $$rAF(function() {\n      container.addClass('md-ready');\n    });\n  }\n\n  function clamp(value) {\n    if (value > 100) {\n      return 100;\n    }\n\n    if (value < 0) {\n      return 0;\n    }\n\n    return Math.ceil(value || 0);\n  }\n}\nMdProgressLinearDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdTheming\"];\n\n\n// **********************************************************\n// Private Methods\n// **********************************************************\nvar transforms = (function() {\n  var values = new Array(101);\n  for(var i = 0; i < 101; i++){\n    values[i] = makeTransform(i);\n  }\n\n  return values;\n\n  function makeTransform(value){\n    var scale = value/100;\n    var translateX = (value-100)/2;\n    return 'translateX(' + translateX.toString() + '%) scale(' + scale.toString() + ', 1)';\n  }\n})();\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.radioButton\n * @description radioButton module!\n */\nangular.module('material.components.radioButton', [\n  'material.core'\n])\n  .directive('mdRadioGroup', mdRadioGroupDirective)\n  .directive('mdRadioButton', mdRadioButtonDirective);\n\n/**\n * @ngdoc directive\n * @module material.components.radioButton\n * @name mdRadioGroup\n *\n * @restrict E\n *\n * @description\n * The `<md-radio-group>` directive identifies a grouping\n * container for the 1..n grouped radio buttons; specified using nested\n * `<md-radio-button>` tags.\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the radio button is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently\n * than the native `<input type='radio'>` controls. Whereas the native controls\n * force the user to tab through all the radio buttons, `<md-radio-group>`\n * is focusable, and by default the `<md-radio-button>`s are not.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-radio-group ng-model=\"selected\">\n *\n *   <md-radio-button\n *        ng-repeat=\"d in colorOptions\"\n *        ng-value=\"d.value\" aria-label=\"{{ d.label }}\">\n *\n *          {{ d.label }}\n *\n *   </md-radio-button>\n *\n * </md-radio-group>\n * </hljs>\n *\n */\nfunction mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {\n  RadioGroupController.prototype = createRadioGroupControllerProto();\n\n  return {\n    restrict: 'E',\n    controller: ['$element', RadioGroupController],\n    require: ['mdRadioGroup', '?ngModel'],\n    link: { pre: linkRadioGroup }\n  };\n\n  function linkRadioGroup(scope, element, attr, ctrls) {\n    $mdTheming(element);\n    var rgCtrl = ctrls[0];\n    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n\n    function setFocus() {\n      if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n    }\n\n    function keydownListener(ev) {\n      var keyCode = ev.which || ev.keyCode;\n      switch(keyCode) {\n        case $mdConstant.KEY_CODE.LEFT_ARROW:\n        case $mdConstant.KEY_CODE.UP_ARROW:\n          ev.preventDefault();\n          rgCtrl.selectPrevious();\n          setFocus();\n          break;\n\n        case $mdConstant.KEY_CODE.RIGHT_ARROW:\n        case $mdConstant.KEY_CODE.DOWN_ARROW:\n          ev.preventDefault();\n          rgCtrl.selectNext();\n          setFocus();\n          break;\n\n        case $mdConstant.KEY_CODE.ENTER:\n          var form = angular.element($mdUtil.getClosest(element[0], 'form'));\n          if (form.length > 0) {\n            form.triggerHandler('submit');\n          }\n          break;\n      }\n    }\n\n    rgCtrl.init(ngModelCtrl);\n\n    scope.mouseActive = false;\n    element.attr({\n              'role': 'radiogroup',\n              'tabIndex': element.attr('tabindex') || '0'\n            })\n            .on('keydown', keydownListener)\n            .on('mousedown', function(event) {\n              scope.mouseActive = true;\n              $timeout(function() {\n                scope.mouseActive = false;\n              }, 100);\n            })\n            .on('focus', function() {\n              if(scope.mouseActive === false) { rgCtrl.$element.addClass('md-focused'); }\n            })\n            .on('blur', function() { rgCtrl.$element.removeClass('md-focused'); });\n  }\n\n  function RadioGroupController($element) {\n    this._radioButtonRenderFns = [];\n    this.$element = $element;\n  }\n\n  function createRadioGroupControllerProto() {\n    return {\n      init: function(ngModelCtrl) {\n        this._ngModelCtrl = ngModelCtrl;\n        this._ngModelCtrl.$render = angular.bind(this, this.render);\n      },\n      add: function(rbRender) {\n        this._radioButtonRenderFns.push(rbRender);\n      },\n      remove: function(rbRender) {\n        var index = this._radioButtonRenderFns.indexOf(rbRender);\n        if (index !== -1) {\n          this._radioButtonRenderFns.splice(index, 1);\n        }\n      },\n      render: function() {\n        this._radioButtonRenderFns.forEach(function(rbRender) {\n          rbRender();\n        });\n      },\n      setViewValue: function(value, eventType) {\n        this._ngModelCtrl.$setViewValue(value, eventType);\n        // update the other radio buttons as well\n        this.render();\n      },\n      getViewValue: function() {\n        return this._ngModelCtrl.$viewValue;\n      },\n      selectNext: function() {\n        return changeSelectedButton(this.$element, 1);\n      },\n      selectPrevious: function() {\n        return changeSelectedButton(this.$element, -1);\n      },\n      setActiveDescendant: function (radioId) {\n        this.$element.attr('aria-activedescendant', radioId);\n      }\n    };\n  }\n  /**\n   * Change the radio group's selected button by a given increment.\n   * If no button is selected, select the first button.\n   */\n  function changeSelectedButton(parent, increment) {\n    // Coerce all child radio buttons into an array, then wrap then in an iterator\n    var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);\n\n    if (buttons.count()) {\n      var validate = function (button) {\n        // If disabled, then NOT valid\n        return !angular.element(button).attr(\"disabled\");\n      };\n      var selected = parent[0].querySelector('md-radio-button.md-checked');\n      var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();\n      // Activate radioButton's click listener (triggerHandler won't create a real click event)\n      angular.element(target).triggerHandler('click');\n\n\n    }\n  }\n\n}\nmdRadioGroupDirective.$inject = [\"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$timeout\"];\n\n/**\n * @ngdoc directive\n * @module material.components.radioButton\n * @name mdRadioButton\n *\n * @restrict E\n *\n * @description\n * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.\n *\n * While similar to the `<input type=\"radio\" ng-model=\"\" value=\"\">` directive,\n * the `<md-radio-button>` directive provides ink effects, ARIA support, and\n * supports use within named radio groups.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n * @param {string} ngValue Angular expression which sets the value to which the expression should\n *    be set when selected.*\n * @param {string} value The value to which the expression should be set when selected.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} aria-label Adds label to radio button for accessibility.\n * Defaults to radio button's text. If no text content is available, a warning will be logged.\n *\n * @usage\n * <hljs lang=\"html\">\n *\n * <md-radio-button value=\"1\" aria-label=\"Label 1\">\n *   Label 1\n * </md-radio-button>\n *\n * <md-radio-button ng-model=\"color\" ng-value=\"specialValue\" aria-label=\"Green\">\n *   Green\n * </md-radio-button>\n *\n * </hljs>\n *\n */\nfunction mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {\n\n  var CHECKED_CSS = 'md-checked';\n\n  return {\n    restrict: 'E',\n    require: '^mdRadioGroup',\n    transclude: true,\n    template: '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n                '<div class=\"md-off\"></div>' +\n                '<div class=\"md-on\"></div>' +\n              '</div>' +\n              '<div ng-transclude class=\"md-label\"></div>',\n    link: link\n  };\n\n  function link(scope, element, attr, rgCtrl) {\n    var lastChecked;\n\n    $mdTheming(element);\n    configureAria(element, scope);\n\n    rgCtrl.add(render);\n    attr.$observe('value', render);\n\n    element\n      .on('click', listener)\n      .on('$destroy', function() {\n        rgCtrl.remove(render);\n      });\n\n    function listener(ev) {\n      if (element[0].hasAttribute('disabled')) return;\n\n      scope.$apply(function() {\n        rgCtrl.setViewValue(attr.value, ev && ev.type);\n      });\n    }\n\n    function render() {\n      var checked = (rgCtrl.getViewValue() == attr.value);\n      if (checked === lastChecked) {\n        return;\n      }\n      lastChecked = checked;\n      element.attr('aria-checked', checked);\n      if (checked) {\n        element.addClass(CHECKED_CSS);\n        rgCtrl.setActiveDescendant(element.attr('id'));\n      } else {\n        element.removeClass(CHECKED_CSS);\n      }\n    }\n    /**\n     * Inject ARIA-specific attributes appropriate for each radio button\n     */\n    function configureAria( element, scope ){\n      scope.ariaId = buildAriaID();\n\n      element.attr({\n        'id' :  scope.ariaId,\n        'role' : 'radio',\n        'aria-checked' : 'false'\n      });\n\n      $mdAria.expectWithText(element, 'aria-label');\n\n      /**\n       * Build a unique ID for each radio button that will be used with aria-activedescendant.\n       * Preserve existing ID if already specified.\n       * @returns {*|string}\n       */\n      function buildAriaID() {\n        return attr.id || ( 'radio' + \"_\" + $mdUtil.nextUid() );\n      }\n    }\n  }\n}\nmdRadioButtonDirective.$inject = [\"$mdAria\", \"$mdUtil\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.select\n */\n\n/***************************************************\n\n### TODO ###\n**DOCUMENTATION AND DEMOS**\n\n- [ ] ng-model with child mdOptions (basic)\n- [ ] ng-model=\"foo\" ng-model-options=\"{ trackBy: '$value.id' }\" for objects\n- [ ] mdOption with value\n- [ ] Usage with input inside\n\n### TODO - POST RC1 ###\n- [ ] Abstract placement logic in $mdSelect service to $mdMenu service\n\n***************************************************/\n\nvar SELECT_EDGE_MARGIN = 8;\nvar selectNextId = 0;\n\nangular.module('material.components.select', [\n  'material.core',\n  'material.components.backdrop'\n])\n.directive('mdSelect', SelectDirective)\n.directive('mdSelectMenu', SelectMenuDirective)\n.directive('mdOption', OptionDirective)\n.directive('mdOptgroup', OptgroupDirective)\n.provider('$mdSelect', SelectProvider);\n\n\n/**\n * @ngdoc directive\n * @name mdSelect\n * @restrict E\n * @module material.components.select\n *\n * @description Displays a select box, bound to an ng-model.\n *\n * @param {expression} ng-model The model!\n * @param {expression=} md-on-close expression to be evaluated when the select is closed\n * @param {boolean=} multiple Whether it's multiple.\n * @param {string=} placeholder Placeholder hint text.\n * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or\n * explicit label is present.\n *\n * @usage\n * With a placeholder (label and aria-label are added dynamically)\n * <hljs lang=\"html\">\n *   <md-select\n *     ng-model=\"someModel\"\n *     placeholder=\"Select a state\">\n *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n *   </md-select>\n * </hljs>\n *\n * With an explicit label\n * <hljs lang=\"html\">\n *   <md-select\n *     ng-model=\"someModel\">\n *     <md-select-label>Select a state</md-select-label>\n *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n *   </md-select>\n * </hljs>\n */\nfunction SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $interpolate, $compile, $parse) {\n  return {\n    restrict: 'E',\n    require: ['mdSelect', 'ngModel', '?^form'],\n    compile: compile,\n    controller: function() { } // empty placeholder controller to be initialized in link\n  };\n\n  function compile(element, attr) {\n    // The user is allowed to provide a label for the select as md-select-label child\n    var labelEl = element.find('md-select-label').remove();\n\n    // If not provided, we automatically make one\n    if (!labelEl.length) {\n      labelEl = angular.element('<md-select-label><span></span></md-select-label>');\n    } else {\n      if (!labelEl[0].firstElementChild) {\n        var spanWrapper = angular.element('<span>');\n        spanWrapper.append(labelEl.contents());\n        labelEl.append(spanWrapper);\n      }\n    }\n    labelEl.append('<span class=\"md-select-icon\" aria-hidden=\"true\"></span>');\n    labelEl.addClass('md-select-label');\n    if (!labelEl[0].hasAttribute('id')) {\n      labelEl.attr('id', 'select_label_' + $mdUtil.nextUid());\n    }\n\n    // There's got to be an md-content inside. If there's not one, let's add it.\n    if (!element.find('md-content').length) {\n      element.append( angular.element('<md-content>').append(element.contents()) );\n    }\n\n    // Add progress spinner for md-options-loading\n    if (attr.mdOnOpen) {\n      element.find('md-content').prepend(\n        angular.element('<md-progress-circular>')\n               .attr('md-mode', 'indeterminate')\n               .attr('ng-hide', '$$loadingAsyncDone')\n               .wrap('<div>')\n               .parent()\n      );\n    }\n\n    if (attr.name) {\n      var autofillClone = angular.element('<select class=\"md-visually-hidden\">');\n      autofillClone.attr({\n        'name': '.' + attr.name,\n        'ng-model': attr.ngModel,\n        'aria-hidden': 'true',\n        'tabindex': '-1'\n      });\n      var opts = element.find('md-option');\n      angular.forEach(opts, function(el) {\n        var newEl = angular.element('<option>' + el.innerHTML + '</option>');\n        if (el.hasAttribute('ng-value')) newEl.attr('ng-value', el.getAttribute('ng-value'));\n        else if (el.hasAttribute('value')) newEl.attr('value', el.getAttribute('value'));\n        autofillClone.append(newEl);\n      });\n\n      element.parent().append(autofillClone);\n    }\n\n    // Use everything that's left inside element.contents() as the contents of the menu\n    var selectTemplate = '<div class=\"md-select-menu-container\">' +\n        '<md-select-menu ' +\n        (angular.isDefined(attr.multiple) ? 'multiple' : '') + '>' +\n          element.html() +\n        '</md-select-menu></div>';\n\n    element.empty().append(labelEl);\n\n    attr.tabindex = attr.tabindex || '0';\n\n    return function postLink(scope, element, attr, ctrls) {\n      var isOpen;\n      var isDisabled;\n\n      var mdSelectCtrl = ctrls[0];\n      var ngModel = ctrls[1];\n      var formCtrl = ctrls[2];\n\n      var labelEl = element.find('md-select-label');\n      var customLabel = labelEl.text().length !== 0;\n      var selectContainer, selectScope, selectMenuCtrl;\n      createSelect();\n\n      $mdTheming(element);\n\n      if (attr.name && formCtrl) {\n        var selectEl = element.parent()[0].querySelector('select[name=\".' + attr.name + '\"]');\n        formCtrl.$removeControl(angular.element(selectEl).controller());\n      }\n\n      var originalRender = ngModel.$render;\n      ngModel.$render = function() {\n        originalRender();\n        syncLabelText();\n      };\n\n      mdSelectCtrl.setLabelText = function(text) {\n        if (customLabel) return; // Assume that user is handling it on their own\n        mdSelectCtrl.setIsPlaceholder(!text);\n        text = text || attr.placeholder || '';\n        var target = customLabel ? labelEl : labelEl.children().eq(0);\n        target.text(text);\n      };\n\n      mdSelectCtrl.setIsPlaceholder = function(val) {\n        val ? labelEl.addClass('md-placeholder') : labelEl.removeClass('md-placeholder');\n      };\n\n      mdSelectCtrl.triggerClose = function() {\n        $parse(attr.mdOnClose)(scope);\n      };\n\n      scope.$$postDigest(function() {\n        setAriaLabel();\n        syncLabelText();\n      });\n\n      function setAriaLabel() {\n        var labelText = element.attr('placeholder');\n        if (!labelText) {\n          labelText = element.find('md-select-label').text();\n        }\n        $mdAria.expect(element, 'aria-label', labelText);\n      }\n\n      function syncLabelText() {\n        if (selectContainer) {\n          selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');\n          mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());\n        }\n      }\n\n      var deregisterWatcher;\n      attr.$observe('ngMultiple', function(val) {\n        if (deregisterWatcher) deregisterWatcher();\n        var parser = $parse(val);\n        deregisterWatcher = scope.$watch(function() { return parser(scope); }, function(multiple, prevVal) {\n          if (multiple === undefined && prevVal === undefined) return; // assume compiler did a good job\n          if (multiple) {\n            element.attr('multiple', 'multiple');\n          } else {\n            element.removeAttr('multiple');\n          }\n          if (selectContainer) {\n            selectMenuCtrl.setMultiple(multiple);\n            originalRender = ngModel.$render;\n            ngModel.$render = function() {\n              originalRender();\n              syncLabelText();\n            };\n            selectMenuCtrl.refreshViewValue();\n            ngModel.$render();\n          }\n        });\n      });\n\n      attr.$observe('disabled', function(disabled) {\n        if (typeof disabled == \"string\") {\n          disabled = true;\n        }\n        // Prevent click event being registered twice\n        if (isDisabled !== undefined && isDisabled === disabled) {\n          return;\n        }\n        isDisabled = disabled;\n        if (disabled) {\n          element.attr({'tabindex': -1, 'aria-disabled': 'true'});\n          element.off('click', openSelect);\n          element.off('keydown', handleKeypress);\n        } else {\n          element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n          element.on('click', openSelect);\n          element.on('keydown', handleKeypress);\n        }\n      });\n\n      if (!attr.disabled && !attr.ngDisabled) {\n        element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n        element.on('click', openSelect);\n        element.on('keydown', handleKeypress);\n      }\n\n      var ariaAttrs = {\n        role: 'combobox',\n        'aria-expanded': 'false'\n      };\n      if (!element[0].hasAttribute('id')) {\n        ariaAttrs.id = 'select_' + $mdUtil.nextUid();\n      }\n      element.attr(ariaAttrs);\n\n      scope.$on('$destroy', function() {\n        if (isOpen) {\n          $mdSelect.cancel().then(function() {\n            selectContainer.remove();\n          });\n        } else {\n          selectContainer.remove();\n        }\n      });\n\n\n      // Create a fake select to find out the label value\n      function createSelect() {\n        selectContainer = angular.element(selectTemplate);\n        var selectEl = selectContainer.find('md-select-menu');\n        selectEl.data('$ngModelController', ngModel);\n        selectEl.data('$mdSelectController', mdSelectCtrl);\n        selectScope = scope.$new();\n        selectContainer = $compile(selectContainer)(selectScope);\n        selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');\n      }\n\n      function handleKeypress(e) {\n        var allowedCodes = [32, 13, 38, 40];\n        if (allowedCodes.indexOf(e.keyCode) != -1 ) {\n          // prevent page scrolling on interaction\n          e.preventDefault();\n          openSelect(e);\n        } else {\n          if (e.keyCode <= 90 && e.keyCode >= 31) {\n            e.preventDefault();\n            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);\n            if (!node) return;\n            var optionCtrl = angular.element(node).controller('mdOption');\n            if (!selectMenuCtrl.isMultiple) {\n              selectMenuCtrl.deselect( Object.keys(selectMenuCtrl.selected)[0] );\n            }\n            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n            selectMenuCtrl.refreshViewValue();\n            ngModel.$render();\n          }\n        }\n      }\n\n      function openSelect() {\n        scope.$evalAsync(function() {\n          isOpen = true;\n          $mdSelect.show({\n            scope: selectScope,\n            preserveScope: true,\n            skipCompile: true,\n            element: selectContainer,\n            target: element[0],\n            hasBackdrop: true,\n            loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false,\n          }).then(function(selectedText) {\n            isOpen = false;\n          });\n        });\n      }\n    };\n  }\n}\nSelectDirective.$inject = [\"$mdSelect\", \"$mdUtil\", \"$mdTheming\", \"$mdAria\", \"$interpolate\", \"$compile\", \"$parse\"];\n\nfunction SelectMenuDirective($parse, $mdUtil, $mdTheming) {\n\n  SelectMenuController.$inject = [\"$scope\", \"$attrs\", \"$element\"];\n  return {\n    restrict: 'E',\n    require: ['mdSelectMenu', '?ngModel'],\n    controller: SelectMenuController,\n    link: { pre: preLink }\n  };\n\n  // We use preLink instead of postLink to ensure that the select is initialized before\n  // its child options run postLink.\n  function preLink(scope, element, attr, ctrls) {\n    var selectCtrl = ctrls[0];\n    var ngModel = ctrls[1];\n\n    $mdTheming(element);\n    element.on('click', clickListener);\n    element.on('keypress', keyListener);\n    if (ngModel) selectCtrl.init(ngModel);\n    configureAria();\n\n    function configureAria() {\n      element.attr({\n        'id': 'select_menu_' + $mdUtil.nextUid(),\n        'role': 'listbox',\n        'aria-multiselectable': (selectCtrl.isMultiple ? 'true' : 'false')\n      });\n    }\n\n    function keyListener(e) {\n      if (e.keyCode == 13 || e.keyCode == 32) {\n        clickListener(e);\n      }\n    }\n\n    function clickListener(ev) {\n      var option = $mdUtil.getClosest(ev.target, 'md-option');\n      var optionCtrl = option && angular.element(option).data('$mdOptionController');\n      if (!option || !optionCtrl) return;\n\n      var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);\n      var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);\n\n      scope.$apply(function() {\n        if (selectCtrl.isMultiple) {\n          if (isSelected) {\n            selectCtrl.deselect(optionHashKey);\n          } else {\n            selectCtrl.select(optionHashKey, optionCtrl.value);\n          }\n        } else {\n          if (!isSelected) {\n            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n            selectCtrl.select( optionHashKey, optionCtrl.value );\n          }\n        }\n        selectCtrl.refreshViewValue();\n      });\n    }\n  }\n\n\n\n  function SelectMenuController($scope, $attrs, $element) {\n    var self = this;\n    self.isMultiple = angular.isDefined($attrs.multiple);\n    // selected is an object with keys matching all of the selected options' hashed values\n    self.selected = {};\n    // options is an object with keys matching every option's hash value,\n    // and values matching every option's controller.\n    self.options = {};\n\n    $scope.$watch(function() { return self.options; }, function() {\n      self.ngModel.$render();\n    }, true);\n\n    var deregisterCollectionWatch;\n    self.setMultiple = function(isMultiple) {\n      var ngModel = self.ngModel;\n      self.isMultiple = isMultiple;\n      if (deregisterCollectionWatch) deregisterCollectionWatch();\n\n      if (self.isMultiple) {\n        ngModel.$validators['md-multiple'] = validateArray;\n        ngModel.$render = renderMultiple;\n\n        // watchCollection on the model because by default ngModel only watches the model's\n        // reference. This allowed the developer to also push and pop from their array.\n        $scope.$watchCollection($attrs.ngModel, function(value) {\n          if (validateArray(value)) renderMultiple(value);\n        });\n      } else {\n        delete ngModel.$validators['md-multiple'];\n        ngModel.$render = renderSingular;\n      }\n\n      function validateArray(modelValue, viewValue) {\n        // If a value is truthy but not an array, reject it.\n        // If value is undefined/falsy, accept that it's an empty array.\n        return angular.isArray(modelValue || viewValue || []);\n      }\n    };\n\n    var searchStr = '';\n    var clearSearchTimeout, optNodes, optText;\n    var CLEAR_SEARCH_AFTER = 300;\n    self.optNodeForKeyboardSearch = function(e) {\n      clearSearchTimeout && clearTimeout(clearSearchTimeout);\n      clearSearchTimeout = setTimeout(function() {\n        clearSearchTimeout = undefined;\n        searchStr = '';\n        optText = undefined;\n        optNodes = undefined;\n      }, CLEAR_SEARCH_AFTER);\n      searchStr += String.fromCharCode(e.keyCode);\n      var search = new RegExp('^' + searchStr, 'i');\n      if (!optNodes) {\n        optNodes = $element.find('md-option');\n        optText = new Array(optNodes.length);\n        angular.forEach(optNodes, function(el, i) {\n          optText[i] = el.textContent.trim();\n        });\n      }\n      for (var i = 0; i < optText.length; ++i) {\n        if (search.test(optText[i])) {\n          return optNodes[i];\n        }\n      }\n    };\n\n\n    self.init = function(ngModel) {\n      self.ngModel = ngModel;\n\n      // Allow users to provide `ng-model=\"foo\" ng-model-options=\"{trackBy: 'foo.id'}\"` so\n      // that we can properly compare objects set on the model to the available options\n      if (ngModel.$options && ngModel.$options.trackBy) {\n        var trackByLocals = {};\n        var trackByParsed = $parse(ngModel.$options.trackBy);\n        self.hashGetter = function(value, valueScope) {\n          trackByLocals.$value = value;\n          return trackByParsed(valueScope || $scope, trackByLocals);\n        };\n      // If the user doesn't provide a trackBy, we automatically generate an id for every\n      // value passed in\n      } else {\n        self.hashGetter = function getHashValue(value) {\n          if (angular.isObject(value)) {\n            return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));\n          }\n          return value;\n        };\n      }\n      self.setMultiple(self.isMultiple);\n    };\n\n    self.selectedLabels = function() {\n      var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));\n      if (selectedOptionEls.length) {\n        return selectedOptionEls.map(function(el) { return el.textContent; }).join(', ');\n      } else {\n        return '';\n      }\n    };\n\n    self.select = function(hashKey, hashedValue) {\n      var option = self.options[hashKey];\n      option && option.setSelected(true);\n      self.selected[hashKey] = hashedValue;\n    };\n    self.deselect = function(hashKey) {\n      var option = self.options[hashKey];\n      option && option.setSelected(false);\n      delete self.selected[hashKey];\n    };\n\n    self.addOption = function(hashKey, optionCtrl) {\n      if (angular.isDefined(self.options[hashKey])) {\n        throw new Error('Duplicate md-option values are not allowed in a select. ' +\n                        'Duplicate value \"' + optionCtrl.value + '\" found.');\n      }\n      self.options[hashKey] = optionCtrl;\n\n      // If this option's value was already in our ngModel, go ahead and select it.\n      if (angular.isDefined(self.selected[hashKey])) {\n        self.select(hashKey, optionCtrl.value);\n        self.refreshViewValue();\n      }\n    };\n    self.removeOption = function(hashKey) {\n      delete self.options[hashKey];\n      // Don't deselect an option when it's removed - the user's ngModel should be allowed\n      // to have values that do not match a currently available option.\n    };\n\n    self.refreshViewValue = function() {\n      var values = [];\n      var option;\n      for (var hashKey in self.selected) {\n         // If this hashKey has an associated option, push that option's value to the model.\n         if ((option = self.options[hashKey])) {\n           values.push(option.value);\n         } else {\n           // Otherwise, the given hashKey has no associated option, and we got it\n           // from an ngModel value at an earlier time. Push the unhashed value of\n           // this hashKey to the model.\n           // This allows the developer to put a value in the model that doesn't yet have\n           // an associated option.\n           values.push(self.selected[hashKey]);\n         }\n      }\n      self.ngModel.$setViewValue(self.isMultiple ? values : values[0]);\n    };\n\n    function renderMultiple() {\n      var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue;\n      if (!angular.isArray(newSelectedValues)) return;\n\n      var oldSelected = Object.keys(self.selected);\n\n      var newSelectedHashes = newSelectedValues.map(self.hashGetter);\n      var deselected = oldSelected.filter(function(hash) {\n        return newSelectedHashes.indexOf(hash) === -1;\n      });\n\n      deselected.forEach(self.deselect);\n      newSelectedHashes.forEach(function(hashKey, i) {\n        self.select(hashKey, newSelectedValues[i]);\n      });\n    }\n    function renderSingular() {\n      var value = self.ngModel.$viewValue || self.ngModel.$modelValue;\n      Object.keys(self.selected).forEach(self.deselect);\n      self.select( self.hashGetter(value), value );\n    }\n  }\n\n}\nSelectMenuDirective.$inject = [\"$parse\", \"$mdUtil\", \"$mdTheming\"];\n\nfunction OptionDirective($mdButtonInkRipple, $mdUtil) {\n\n  OptionController.$inject = [\"$element\"];\n  return {\n    restrict: 'E',\n    require: ['mdOption', '^^mdSelectMenu'],\n    controller: OptionController,\n    compile: compile\n  };\n\n  function compile(element, attr) {\n    // Manual transclusion to avoid the extra inner <span> that ng-transclude generates\n    element.append( angular.element('<div class=\"md-text\">').append(element.contents()) );\n\n    element.attr('tabindex', attr.tabindex || '0');\n    return postLink;\n  }\n\n  function postLink(scope, element, attr, ctrls) {\n    var optionCtrl = ctrls[0];\n    var selectCtrl = ctrls[1];\n\n    if (angular.isDefined(attr.ngValue)) {\n      scope.$watch(attr.ngValue, setOptionValue);\n    } else if (angular.isDefined(attr.value)) {\n      setOptionValue(attr.value);\n    } else {\n      scope.$watch(function() { return element.text(); }, setOptionValue);\n    }\n\n    scope.$$postDigest(function() {\n      attr.$observe('selected', function(selected) {\n        if (!angular.isDefined(selected)) return;\n        if (selected) {\n          if (!selectCtrl.isMultiple) {\n            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n          }\n          selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n        } else {\n          selectCtrl.deselect(optionCtrl.hashKey);\n        }\n        selectCtrl.refreshViewValue();\n        selectCtrl.ngModel.$render();\n      });\n    });\n\n    $mdButtonInkRipple.attach(scope, element);\n    configureAria();\n\n    function setOptionValue(newValue, oldValue) {\n      var oldHashKey = selectCtrl.hashGetter(oldValue, scope);\n      var newHashKey = selectCtrl.hashGetter(newValue, scope);\n\n      optionCtrl.hashKey = newHashKey;\n      optionCtrl.value = newValue;\n\n      selectCtrl.removeOption(oldHashKey, optionCtrl);\n      selectCtrl.addOption(newHashKey, optionCtrl);\n    }\n\n    scope.$on('$destroy', function() {\n      selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);\n    });\n\n    function configureAria() {\n      var ariaAttrs = {\n        'role': 'option',\n        'aria-selected': 'false'\n      };\n\n      if (!element[0].hasAttribute('id')) {\n        ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();\n      }\n      element.attr(ariaAttrs);\n    }\n  }\n\n  function OptionController($element) {\n    this.selected = false;\n    this.setSelected = function(isSelected) {\n      if (isSelected && !this.selected) {\n        $element.attr({\n          'selected': 'selected',\n          'aria-selected': 'true'\n        });\n      } else if (!isSelected && this.selected) {\n        $element.removeAttr('selected');\n        $element.attr('aria-selected', 'false');\n      }\n      this.selected = isSelected;\n    };\n  }\n\n}\nOptionDirective.$inject = [\"$mdButtonInkRipple\", \"$mdUtil\"];\n\nfunction OptgroupDirective() {\n  return {\n    restrict: 'E',\n    compile: compile\n  };\n  function compile(el, attrs) {\n    var labelElement = el.find('label');\n    if (!labelElement.length) {\n      labelElement = angular.element('<label>');\n      el.prepend(labelElement);\n    }\n    if (attrs.label) labelElement.text(attrs.label);\n  }\n}\n\nfunction SelectProvider($$interimElementProvider) {\n  selectDefaultOptions.$inject = [\"$mdSelect\", \"$mdConstant\", \"$$rAF\", \"$mdUtil\", \"$mdTheming\", \"$timeout\", \"$window\"];\n  return $$interimElementProvider('$mdSelect')\n    .setDefaults({\n      methods: ['target'],\n      options: selectDefaultOptions\n    });\n\n  /* @ngInject */\n  function selectDefaultOptions($mdSelect, $mdConstant, $$rAF, $mdUtil, $mdTheming, $timeout, $window ) {\n    return {\n      parent: 'body',\n      onShow: onShow,\n      onRemove: onRemove,\n      hasBackdrop: true,\n      disableParentScroll: true,\n      themable: true\n    };\n\n    function onShow(scope, element, opts) {\n      if (!opts.target) {\n        throw new Error('$mdSelect.show() expected a target element in options.target but got ' +\n                        '\"' + opts.target + '\"!');\n      }\n\n      angular.extend(opts, {\n        isRemoved: false,\n        target: angular.element(opts.target), //make sure it's not a naked dom node\n        parent: angular.element(opts.parent),\n        selectEl: element.find('md-select-menu'),\n        contentEl: element.find('md-content'),\n        backdrop: opts.hasBackdrop && angular.element('<md-backdrop class=\"md-select-backdrop md-click-catcher\">')\n      });\n\n      opts.resizeFn = function() {\n        $$rAF(function() {\n          $$rAF(function() {\n            animateSelect(scope, element, opts);\n          });\n        });\n      };\n\n      angular.element($window).on('resize', opts.resizeFn);\n      angular.element($window).on('orientationchange', opts.resizeFn);\n\n\n      configureAria();\n\n      element.removeClass('md-leave');\n\n      var optionNodes = opts.selectEl[0].getElementsByTagName('md-option');\n\n      if (opts.loadingAsync && opts.loadingAsync.then) {\n        opts.loadingAsync.then(function() {\n          scope.$$loadingAsyncDone = true;\n          // Give ourselves two frames for the progress loader to clear out.\n          $$rAF(function() {\n            $$rAF(function() {\n              // Don't go forward if the select has been removed in this time...\n              if (opts.isRemoved) return;\n              animateSelect(scope, element, opts);\n            });\n          });\n        });\n      } else if (opts.loadingAsync) {\n        scope.$$loadingAsyncDone = true;\n      }\n\n      if (opts.disableParentScroll && !$mdUtil.getClosest(opts.target, 'MD-DIALOG')) {\n        opts.restoreScroll = $mdUtil.disableScrollAround(opts.element);\n      } else {\n        opts.disableParentScroll = false;\n      }\n      // Only activate click listeners after a short time to stop accidental double taps/clicks\n      // from clicking the wrong item\n      $timeout(activateInteraction, 75, false);\n\n      if (opts.backdrop) {\n        $mdTheming.inherit(opts.backdrop, opts.parent);\n        opts.parent.append(opts.backdrop);\n      }\n      opts.parent.append(element);\n\n      // Give the select a frame to 'initialize' in the DOM,\n      // so we can read its height/width/position\n      $$rAF(function() {\n        $$rAF(function() {\n          if (opts.isRemoved) return;\n          animateSelect(scope, element, opts);\n        });\n      });\n\n      return $mdUtil.transitionEndPromise(opts.selectEl, {timeout: 350});\n\n      function configureAria() {\n        opts.target.attr('aria-expanded', 'true');\n      }\n\n      function activateInteraction() {\n        if (opts.isRemoved) return;\n        var selectCtrl = opts.selectEl.controller('mdSelectMenu') || {};\n        element.addClass('md-clickable');\n\n        opts.backdrop && opts.backdrop.on('click', function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          opts.restoreFocus = false;\n          scope.$apply($mdSelect.cancel);\n        });\n\n        // Escape to close\n        opts.selectEl.on('keydown', function(ev) {\n          switch (ev.keyCode) {\n            case $mdConstant.KEY_CODE.SPACE:\n            case $mdConstant.KEY_CODE.ENTER:\n              var option = $mdUtil.getClosest(ev.target, 'md-option');\n              if (option) {\n                opts.selectEl.triggerHandler({\n                  type: 'click',\n                  target: option\n                });\n                ev.preventDefault();\n              }\n              break;\n            case $mdConstant.KEY_CODE.TAB:\n            case $mdConstant.KEY_CODE.ESCAPE:\n              ev.preventDefault();\n              opts.restoreFocus = true;\n              scope.$apply($mdSelect.cancel);\n          }\n        });\n\n        // Cycling of options, and closing on enter\n        opts.selectEl.on('keydown', function(ev) {\n          switch (ev.keyCode) {\n            case $mdConstant.KEY_CODE.UP_ARROW: return focusPrevOption();\n            case $mdConstant.KEY_CODE.DOWN_ARROW: return focusNextOption();\n            default:\n              if (ev.keyCode >= 31 && ev.keyCode <= 90) {\n                var optNode = opts.selectEl.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);\n                optNode && optNode.focus();\n              }\n          }\n        });\n\n\n        function focusOption(direction) {\n          var optionsArray = $mdUtil.nodesToArray(optionNodes);\n          var index = optionsArray.indexOf(opts.focusedNode);\n          if (index === -1) {\n            // We lost the previously focused element, reset to first option\n            index = 0;\n          } else if (direction === 'next' && index < optionsArray.length - 1) {\n            index++;\n          } else if (direction === 'prev' && index > 0) {\n            index--;\n          }\n          var newOption = opts.focusedNode = optionsArray[index];\n          newOption && newOption.focus();\n        }\n        function focusNextOption() {\n          focusOption('next');\n        }\n        function focusPrevOption() {\n          focusOption('prev');\n        }\n\n        opts.selectEl.on('click', checkCloseMenu);\n        opts.selectEl.on('keydown', function(e) {\n          if (e.keyCode == 32 || e.keyCode == 13) {\n            checkCloseMenu();\n          }\n        });\n\n        function checkCloseMenu() {\n          if (!selectCtrl.isMultiple) {\n            opts.restoreFocus = true;\n            scope.$evalAsync(function() {\n              $mdSelect.hide(selectCtrl.ngModel.$viewValue);\n            });\n          }\n        }\n      }\n\n    }\n\n    function onRemove(scope, element, opts) {\n      opts.isRemoved = true;\n      element.addClass('md-leave')\n        .removeClass('md-clickable');\n      opts.target.attr('aria-expanded', 'false');\n\n\n      angular.element($window).off('resize', opts.resizeFn);\n      angular.element($window).off('orientationchange', opts.resizefn);\n      opts.resizeFn = undefined;\n\n      var mdSelect = opts.selectEl.controller('mdSelect');\n      if (mdSelect) {\n        mdSelect.setLabelText(opts.selectEl.controller('mdSelectMenu').selectedLabels());\n      }\n\n      return $mdUtil.transitionEndPromise(element, { timeout: 350 }).then(function() {\n        element.removeClass('md-active');\n        opts.backdrop && opts.backdrop.remove();\n        if (element[0].parentNode === opts.parent[0]) {\n          opts.parent[0].removeChild(element[0]); // use browser to avoid $destroy event\n        }\n        if (opts.disableParentScroll) {\n          opts.restoreScroll();\n        }\n        if (opts.restoreFocus) opts.target.focus();\n        mdSelect && mdSelect.triggerClose();\n      });\n    }\n\n    function animateSelect(scope, element, opts) {\n      var containerNode = element[0],\n          targetNode = opts.target[0].firstElementChild.firstElementChild, // target the first span, functioning as the label\n          parentNode = opts.parent[0],\n          selectNode = opts.selectEl[0],\n          contentNode = opts.contentEl[0],\n          parentRect = parentNode.getBoundingClientRect(),\n          targetRect = targetNode.getBoundingClientRect(),\n          shouldOpenAroundTarget = false,\n          bounds = {\n            left: parentRect.left + SELECT_EDGE_MARGIN,\n            top: SELECT_EDGE_MARGIN,\n            bottom: parentRect.height - SELECT_EDGE_MARGIN,\n            right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)\n          },\n          spaceAvailable = {\n            top: targetRect.top - bounds.top,\n            left: targetRect.left - bounds.left,\n            right: bounds.right - (targetRect.left + targetRect.width),\n            bottom: bounds.bottom - (targetRect.top + targetRect.height)\n          },\n          maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,\n          isScrollable = contentNode.scrollHeight > contentNode.offsetHeight,\n          selectedNode = selectNode.querySelector('md-option[selected]'),\n          optionNodes = selectNode.getElementsByTagName('md-option'),\n          optgroupNodes = selectNode.getElementsByTagName('md-optgroup');\n\n\n      var centeredNode;\n      // If a selected node, center around that\n      if (selectedNode) {\n        centeredNode = selectedNode;\n      // If there are option groups, center around the first option group\n      } else if (optgroupNodes.length) {\n        centeredNode = optgroupNodes[0];\n      // Otherwise, center around the first optionNode\n      } else if (optionNodes.length){\n        centeredNode = optionNodes[0];\n      // In case there are no options, center on whatever's in there... (eg progress indicator)\n      } else {\n        centeredNode = contentNode.firstElementChild || contentNode;\n      }\n\n      if (contentNode.offsetWidth > maxWidth) {\n        contentNode.style['max-width'] = maxWidth + 'px';\n      }\n      if (shouldOpenAroundTarget) {\n        contentNode.style['min-width'] = targetRect.width + 'px';\n      }\n\n      // Remove padding before we compute the position of the menu\n      if (isScrollable) {\n        selectNode.classList.add('md-overflow');\n      }\n\n      // Get the selectMenuRect *after* max-width is possibly set above\n      var selectMenuRect = selectNode.getBoundingClientRect();\n      var centeredRect = getOffsetRect(centeredNode);\n\n      if (centeredNode) {\n        var centeredStyle = $window.getComputedStyle(centeredNode);\n        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;\n        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;\n      }\n\n      var focusedNode = centeredNode;\n      if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {\n        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;\n      }\n\n      if (isScrollable) {\n        var scrollBuffer = contentNode.offsetHeight / 2;\n        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;\n\n        if (spaceAvailable.top < scrollBuffer) {\n          contentNode.scrollTop = Math.min(\n            centeredRect.top,\n            contentNode.scrollTop + scrollBuffer - spaceAvailable.top\n          );\n        } else if (spaceAvailable.bottom < scrollBuffer) {\n          contentNode.scrollTop = Math.max(\n            centeredRect.top + centeredRect.height - selectMenuRect.height,\n            contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom\n          );\n        }\n      }\n\n      var left, top, transformOrigin;\n      if (shouldOpenAroundTarget) {\n        left = targetRect.left;\n        top = targetRect.top + targetRect.height;\n        transformOrigin = '50% 0';\n        if (top + selectMenuRect.height > bounds.bottom) {\n          top = targetRect.top - selectMenuRect.height;\n          transformOrigin = '50% 100%';\n        }\n      } else {\n        left = targetRect.left + centeredRect.left - centeredRect.paddingLeft;\n        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -\n          centeredRect.top + contentNode.scrollTop);\n\n\n        transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' +\n        (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';\n\n        containerNode.style.minWidth = targetRect.width + centeredRect.paddingLeft +\n          centeredRect.paddingRight + 'px';\n      }\n\n      // Keep left and top within the window\n      var containerRect = containerNode.getBoundingClientRect();\n      containerNode.style.left = clamp(bounds.left, left, bounds.right - containerRect.width) + 'px';\n      containerNode.style.top = clamp(bounds.top, top, bounds.bottom - containerRect.height) + 'px';\n      selectNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;\n\n      selectNode.style[$mdConstant.CSS.TRANSFORM] = 'scale(' +\n        Math.min(targetRect.width / selectMenuRect.width, 1.0) + ',' +\n        Math.min(targetRect.height / selectMenuRect.height, 1.0) +\n      ')';\n\n\n      $$rAF(function() {\n        element.addClass('md-active');\n        selectNode.style[$mdConstant.CSS.TRANSFORM] = '';\n        if (focusedNode) {\n          opts.focusedNode = focusedNode;\n          focusedNode.focus();\n        }\n      });\n    }\n\n  }\n\n  function clamp(min, n, max) {\n    return Math.max(min, Math.min(n, max));\n  }\n\n  function getOffsetRect(node) {\n    return node ? {\n      left: node.offsetLeft,\n      top: node.offsetTop,\n      width: node.offsetWidth,\n      height: node.offsetHeight\n    } : { left: 0, top: 0, width: 0, height: 0 };\n  }\n}\nSelectProvider.$inject = [\"$$interimElementProvider\"];\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.sidenav\n *\n * @description\n * A Sidenav QP component.\n */\nangular.module('material.components.sidenav', [\n    'material.core',\n    'material.components.backdrop'\n  ])\n  .factory('$mdSidenav', SidenavService )\n  .directive('mdSidenav', SidenavDirective)\n  .directive('mdSidenavFocus', SidenavFocusDirective)\n  .controller('$mdSidenavController', SidenavController);\n\n\n/**\n * @private\n * @ngdoc service\n * @name $mdSidenav\n * @module material.components.sidenav\n *\n * @description\n * `$mdSidenav` makes it easy to interact with multiple sidenavs\n * in an app.\n *\n * @usage\n * <hljs lang=\"js\">\n * // Async lookup for sidenav instance; will resolve when the instance is available\n * $mdSidenav(componentId).then(function(instance) {\n *   $log.debug( componentId + \"is now ready\" );\n * });\n * // Async toggle the given sidenav;\n * // when instance is known ready and lazy lookup is not needed.\n * $mdSidenav(componentId)\n *    .toggle()\n *    .then(function(){\n *      $log.debug('toggled');\n *    });\n * // Async open the given sidenav\n * $mdSidenav(componentId)\n *    .open()\n *    .then(function(){\n *      $log.debug('opened');\n *    });\n * // Async close the given sidenav\n * $mdSidenav(componentId)\n *    .close()\n *    .then(function(){\n *      $log.debug('closed');\n *    });\n * // Sync check to see if the specified sidenav is set to be open\n * $mdSidenav(componentId).isOpen();\n * // Sync check to whether given sidenav is locked open\n * // If this is true, the sidenav will be open regardless of close()\n * $mdSidenav(componentId).isLockedOpen();\n * </hljs>\n */\nfunction SidenavService($mdComponentRegistry, $q) {\n  return function(handle) {\n\n    // Lookup the controller instance for the specified sidNav instance\n    var self;\n    var errorMsg = \"SideNav '\" + handle + \"' is not available!\";\n    var instance = $mdComponentRegistry.get(handle);\n\n    if(!instance) {\n      $mdComponentRegistry.notFoundError(handle);\n    }\n\n    return self = {\n      // -----------------\n      // Sync methods\n      // -----------------\n      isOpen: function() {\n        return instance && instance.isOpen();\n      },\n      isLockedOpen: function() {\n        return instance && instance.isLockedOpen();\n      },\n      // -----------------\n      // Async methods\n      // -----------------\n      toggle: function() {\n        return instance ? instance.toggle() : $q.reject(errorMsg);\n      },\n      open: function() {\n        return instance ? instance.open() : $q.reject(errorMsg);\n      },\n      close: function() {\n        return instance ? instance.close() : $q.reject(errorMsg);\n      },\n      then : function( callbackFn ) {\n        var promise = instance ? $q.when(instance) : waitForInstance();\n        return promise.then( callbackFn || angular.noop );\n      }\n    };\n\n    /**\n     * Deferred lookup of component instance using $component registry\n     */\n    function waitForInstance() {\n      return $mdComponentRegistry\n                .when(handle)\n                .then(function( it ){\n                  instance = it;\n                  return it;\n                });\n    }\n  };\n}\nSidenavService.$inject = [\"$mdComponentRegistry\", \"$q\"];\n/**\n * @ngdoc directive\n * @name mdSidenavFocus\n * @module material.components.sidenav\n *\n * @restrict A\n *\n * @description\n * `$mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.\n * This is completely optional, as the sidenav itself is focused by default.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-sidenav>\n *   <form>\n *     <md-input-container>\n *       <label for=\"testInput\">Label</label>\n *       <input id=\"testInput\" type=\"text\" md-sidenav-focus>\n *     </md-input-container>\n *   </form>\n * </md-sidenav>\n * </hljs>\n **/\nfunction SidenavFocusDirective() {\n  return {\n    restrict: 'A',\n    require: '^mdSidenav',\n    link: function(scope, element, attr, sidenavCtrl) {\n      sidenavCtrl.focusElement(element);\n    }\n  };\n}\n/**\n * @ngdoc directive\n * @name mdSidenav\n * @module material.components.sidenav\n * @restrict E\n *\n * @description\n *\n * A Sidenav component that can be opened and closed programatically.\n *\n * By default, upon opening it will slide out on top of the main content area.\n *\n * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.\n * It can be overridden with the `md-sidenav-focus` directive on the child element you want focused.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div layout=\"row\" ng-controller=\"MyController\">\n *   <md-sidenav md-component-id=\"left\" class=\"md-sidenav-left\">\n *     Left Nav!\n *   </md-sidenav>\n *\n *   <md-content>\n *     Center Content\n *     <md-button ng-click=\"openLeftMenu()\">\n *       Open Left Menu\n *     </md-button>\n *   </md-content>\n *\n *   <md-sidenav md-component-id=\"right\"\n *     md-is-locked-open=\"$mdMedia('min-width: 333px')\"\n *     class=\"md-sidenav-right\">\n *     <form>\n *       <md-input-container>\n *         <label for=\"testInput\">Test input</label>\n *         <input id=\"testInput\" type=\"text\"\n *                ng-model=\"data\" md-sidenav-focus>\n *       </md-input-container>\n *     </form>\n *   </md-sidenav>\n * </div>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * var app = angular.module('myApp', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdSidenav) {\n *   $scope.openLeftMenu = function() {\n *     $mdSidenav('left').toggle();\n *   };\n * });\n * </hljs>\n *\n * @param {expression=} md-is-open A model bound to whether the sidenav is opened.\n * @param {string=} md-component-id componentId to use with $mdSidenav service.\n * @param {expression=} md-is-locked-open When this expression evalutes to true,\n * the sidenav 'locks open': it falls into the content's flow instead\n * of appearing over it. This overrides the `is-open` attribute.\n *\n * The $mdMedia() service is exposed to the is-locked-open attribute, which\n * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.\n * Examples:\n *\n *   - `<md-sidenav md-is-locked-open=\"shouldLockOpen\"></md-sidenav>`\n *   - `<md-sidenav md-is-locked-open=\"$mdMedia('min-width: 1000px')\"></md-sidenav>`\n *   - `<md-sidenav md-is-locked-open=\"$mdMedia('sm')\"></md-sidenav>` (locks open on small screens)\n */\nfunction SidenavDirective($timeout, $animate, $parse, $log, $mdMedia, $mdConstant, $compile, $mdTheming, $q, $document) {\n  return {\n    restrict: 'E',\n    scope: {\n      isOpen: '=?mdIsOpen'\n    },\n    controller: '$mdSidenavController',\n    compile: function(element) {\n      element.addClass('md-closed');\n      element.attr('tabIndex', '-1');\n      return postLink;\n    }\n  };\n\n  /**\n   * Directive Post Link function...\n   */\n  function postLink(scope, element, attr, sidenavCtrl) {\n    var lastParentOverFlow;\n    var triggeringElement = null;\n    var promise = $q.when(true);\n\n    var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);\n    var isLocked = function() {\n      return isLockedOpenParsed(scope.$parent, {\n        $media: function(arg) {\n          $log.warn(\"$media is deprecated for is-locked-open. Use $mdMedia instead.\");\n          return $mdMedia(arg);\n        },\n        $mdMedia: $mdMedia\n      });\n    };\n    var backdrop = $compile(\n      '<md-backdrop class=\"md-sidenav-backdrop md-opaque ng-enter\">'\n    )(scope);\n\n    element.on('$destroy', sidenavCtrl.destroy);\n    $mdTheming.inherit(backdrop, element);\n\n    scope.$watch(isLocked, updateIsLocked);\n    scope.$watch('isOpen', updateIsOpen);\n\n\n    // Publish special accessor for the Controller instance\n    sidenavCtrl.$toggleOpen = toggleOpen;\n    sidenavCtrl.focusElement( sidenavCtrl.focusElement() || element );\n\n    /**\n     * Toggle the DOM classes to indicate `locked`\n     * @param isLocked\n     */\n    function updateIsLocked(isLocked, oldValue) {\n      scope.isLockedOpen = isLocked;\n      if (isLocked === oldValue) {\n        element.toggleClass('md-locked-open', !!isLocked);\n      } else {\n        $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');\n      }\n      backdrop.toggleClass('md-locked-open', !!isLocked);\n    }\n\n    /**\n     * Toggle the SideNav view and attach/detach listeners\n     * @param isOpen\n     */\n    function updateIsOpen(isOpen) {\n      var parent = element.parent();\n\n      parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);\n      backdrop[isOpen ? 'on' : 'off']('click', close);\n\n      if ( isOpen ) {\n        // Capture upon opening..\n        triggeringElement = $document[0].activeElement;\n      }\n      var focusEl = sidenavCtrl.focusElement();\n\n      disableParentScroll(isOpen);\n\n      return promise = $q.all([\n                isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop),\n                $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')\n              ])\n              .then(function() {\n                // Perform focus when animations are ALL done...\n                if (scope.isOpen) {\n                  focusEl && focusEl.focus();\n                }\n              });\n    }\n\n    /**\n     * Prevent parent scrolling (when the SideNav is open)\n     */\n    function disableParentScroll(disabled) {\n      var parent = element.parent();\n      if ( disabled ) {\n        lastParentOverFlow = parent.css('overflow');\n        parent.css('overflow', 'hidden');\n      } else if (angular.isDefined(lastParentOverFlow)) {\n        parent.css('overflow', lastParentOverFlow);\n        lastParentOverFlow = undefined;\n      }\n    }\n\n    /**\n     * Toggle the sideNav view and publish a promise to be resolved when\n     * the view animation finishes.\n     *\n     * @param isOpen\n     * @returns {*}\n     */\n    function toggleOpen( isOpen ) {\n      if (scope.isOpen == isOpen ) {\n\n        return $q.when(true);\n\n      } else {\n        var deferred = $q.defer();\n\n        // Toggle value to force an async `updateIsOpen()` to run\n        scope.isOpen = isOpen;\n\n        $timeout(function() {\n\n          // When the current `updateIsOpen()` animation finishes\n          promise.then(function(result) {\n\n            if ( !scope.isOpen ) {\n              // reset focus to originating element (if available) upon close\n              triggeringElement && triggeringElement.focus();\n              triggeringElement = null;\n            }\n\n            deferred.resolve(result);\n          });\n\n        },0,false);\n\n        return deferred.promise;\n      }\n    }\n\n    /**\n     * Auto-close sideNav when the `escape` key is pressed.\n     * @param evt\n     */\n    function onKeyDown(ev) {\n      var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);\n      return isEscape ? close(ev) : $q.when(true);\n    }\n\n    /**\n     * With backdrop `clicks` or `escape` key-press, immediately\n     * apply the CSS close transition... Then notify the controller\n     * to close() and perform its own actions.\n     */\n    function close(ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      return sidenavCtrl.close();\n    }\n\n  }\n}\nSidenavDirective.$inject = [\"$timeout\", \"$animate\", \"$parse\", \"$log\", \"$mdMedia\", \"$mdConstant\", \"$compile\", \"$mdTheming\", \"$q\", \"$document\"];\n\n/*\n * @private\n * @ngdoc controller\n * @name SidenavController\n * @module material.components.sidenav\n *\n */\nfunction SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {\n\n  var self = this,\n      focusElement;\n\n  // Use Default internal method until overridden by directive postLink\n\n  // Synchronous getters\n  self.isOpen = function() { return !!$scope.isOpen; };\n  self.isLockedOpen = function() { return !!$scope.isLockedOpen; };\n\n  // Async actions\n  self.open   = function() { return self.$toggleOpen( true );  };\n  self.close  = function() { return self.$toggleOpen( false ); };\n  self.toggle = function() { return self.$toggleOpen( !$scope.isOpen );  };\n  self.focusElement = function(el) {\n    if ( angular.isDefined(el) ) {\n      focusElement = el;\n    }\n    return focusElement;\n  };\n\n  self.$toggleOpen = function() { return $q.when($scope.isOpen); };\n\n  self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);\n}\nSidenavController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$mdComponentRegistry\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n  /**\n   * @ngdoc module\n   * @name material.components.slider\n   */\n  angular.module('material.components.slider', [\n    'material.core'\n  ])\n  .directive('mdSlider', SliderDirective);\n\n/**\n * @ngdoc directive\n * @name mdSlider\n * @module material.components.slider\n * @restrict E\n * @description\n * The `<md-slider>` component allows the user to choose from a range of\n * values.\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the slider is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * It has two modes: 'normal' mode, where the user slides between a wide range\n * of values, and 'discrete' mode, where the user slides between only a few\n * select values.\n *\n * To enable discrete mode, add the `md-discrete` attribute to a slider,\n * and use the `step` attribute to change the distance between\n * values the user is allowed to pick.\n *\n * @usage\n * <h4>Normal Mode</h4>\n * <hljs lang=\"html\">\n * <md-slider ng-model=\"myValue\" min=\"5\" max=\"500\">\n * </md-slider>\n * </hljs>\n * <h4>Discrete Mode</h4>\n * <hljs lang=\"html\">\n * <md-slider md-discrete ng-model=\"myDiscreteValue\" step=\"10\" min=\"10\" max=\"130\">\n * </md-slider>\n * </hljs>\n *\n * @param {boolean=} md-discrete Whether to enable discrete mode.\n * @param {number=} step The distance between values the user is allowed to pick. Default 1.\n * @param {number=} min The minimum value the user is allowed to pick. Default 0.\n * @param {number=} max The maximum value the user is allowed to pick. Default 100.\n */\nfunction SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse) {\n  return {\n    scope: {},\n    require: '?ngModel',\n    template:\n      '<div class=\"md-slider-wrapper\">\\\n        <div class=\"md-track-container\">\\\n          <div class=\"md-track\"></div>\\\n          <div class=\"md-track md-track-fill\"></div>\\\n          <div class=\"md-track-ticks\"></div>\\\n        </div>\\\n        <div class=\"md-thumb-container\">\\\n          <div class=\"md-thumb\"></div>\\\n          <div class=\"md-focus-thumb\"></div>\\\n          <div class=\"md-focus-ring\"></div>\\\n          <div class=\"md-sign\">\\\n            <span class=\"md-thumb-text\"></span>\\\n          </div>\\\n          <div class=\"md-disabled-thumb\"></div>\\\n        </div>\\\n      </div>',\n    compile: compile\n  };\n\n  // **********************************************************\n  // Private Methods\n  // **********************************************************\n\n  function compile (tElement, tAttrs) {\n    tElement.attr({\n      tabIndex: 0,\n      role: 'slider'\n    });\n\n    $mdAria.expect(tElement, 'aria-label');\n\n    return postLink;\n  }\n\n  function postLink(scope, element, attr, ngModelCtrl) {\n    $mdTheming(element);\n    ngModelCtrl = ngModelCtrl || {\n      // Mock ngModelController if it doesn't exist to give us\n      // the minimum functionality needed\n      $setViewValue: function(val) {\n        this.$viewValue = val;\n        this.$viewChangeListeners.forEach(function(cb) { cb(); });\n      },\n      $parsers: [],\n      $formatters: [],\n      $viewChangeListeners: []\n    };\n\n    var isDisabledParsed = attr.ngDisabled && $parse(attr.ngDisabled);\n    var isDisabledGetter = isDisabledParsed ?\n      function() { return isDisabledParsed(scope.$parent); } :\n      angular.noop;\n    var thumb = angular.element(element[0].querySelector('.md-thumb'));\n    var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));\n    var thumbContainer = thumb.parent();\n    var trackContainer = angular.element(element[0].querySelector('.md-track-container'));\n    var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));\n    var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));\n    var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);\n\n    // Default values, overridable by attrs\n    angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);\n    angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);\n    angular.isDefined(attr.step)? attr.$observe('step', updateStep) : updateStep(1);\n\n    // We have to manually stop the $watch on ngDisabled because it exists\n    // on the parent scope, and won't be automatically destroyed when\n    // the component is destroyed.\n    var stopDisabledWatch = angular.noop;\n    if (attr.ngDisabled) {\n      stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);\n    }\n\n    $mdGesture.register(element, 'drag');\n\n    element\n      .on('keydown', keydownListener)\n      .on('$md.pressdown', onPressDown)\n      .on('$md.pressup', onPressUp)\n      .on('$md.dragstart', onDragStart)\n      .on('$md.drag', onDrag)\n      .on('$md.dragend', onDragEnd);\n\n    // On resize, recalculate the slider's dimensions and re-render\n    function updateAll() {\n      refreshSliderDimensions();\n      ngModelRender();\n      redrawTicks();\n    }\n    setTimeout(updateAll);\n\n    var debouncedUpdateAll = $$rAF.throttle(updateAll);\n    angular.element($window).on('resize', debouncedUpdateAll);\n\n    scope.$on('$destroy', function() {\n      angular.element($window).off('resize', debouncedUpdateAll);\n      stopDisabledWatch();\n    });\n\n    ngModelCtrl.$render = ngModelRender;\n    ngModelCtrl.$viewChangeListeners.push(ngModelRender);\n    ngModelCtrl.$formatters.push(minMaxValidator);\n    ngModelCtrl.$formatters.push(stepValidator);\n\n    /**\n     * Attributes\n     */\n    var min;\n    var max;\n    var step;\n    function updateMin(value) {\n      min = parseFloat(value);\n      element.attr('aria-valuemin', value);\n      updateAll();\n    }\n    function updateMax(value) {\n      max = parseFloat(value);\n      element.attr('aria-valuemax', value);\n      updateAll();\n    }\n    function updateStep(value) {\n      step = parseFloat(value);\n      redrawTicks();\n    }\n    function updateAriaDisabled(isDisabled) {\n      element.attr('aria-disabled', !!isDisabled);\n    }\n\n    // Draw the ticks with canvas.\n    // The alternative to drawing ticks with canvas is to draw one element for each tick,\n    // which could quickly become a performance bottleneck.\n    var tickCanvas, tickCtx;\n    function redrawTicks() {\n      if (!angular.isDefined(attr.mdDiscrete)) return;\n\n      var numSteps = Math.floor( (max - min) / step );\n      if (!tickCanvas) {\n        var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);\n        tickCanvas = angular.element('<canvas style=\"position:absolute;\">');\n        tickCtx = tickCanvas[0].getContext('2d');\n        tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';\n        tickContainer.append(tickCanvas);\n      }\n      var dimensions = getSliderDimensions();\n      tickCanvas[0].width = dimensions.width;\n      tickCanvas[0].height = dimensions.height;\n\n      var distance;\n      for (var i = 0; i <= numSteps; i++) {\n        distance = Math.floor(dimensions.width * (i / numSteps));\n        tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);\n      }\n    }\n\n\n    /**\n     * Refreshing Dimensions\n     */\n    var sliderDimensions = {};\n    refreshSliderDimensions();\n    function refreshSliderDimensions() {\n      sliderDimensions = trackContainer[0].getBoundingClientRect();\n    }\n    function getSliderDimensions() {\n      throttledRefreshDimensions();\n      return sliderDimensions;\n    }\n\n    /**\n     * left/right arrow listener\n     */\n    function keydownListener(ev) {\n      if(element[0].hasAttribute('disabled')) {\n        return;\n      }\n\n      var changeAmount;\n      if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {\n        changeAmount = -step;\n      } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {\n        changeAmount = step;\n      }\n      if (changeAmount) {\n        if (ev.metaKey || ev.ctrlKey || ev.altKey) {\n          changeAmount *= 4;\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n        scope.$evalAsync(function() {\n          setModelValue(ngModelCtrl.$viewValue + changeAmount);\n        });\n      }\n    }\n\n    /**\n     * ngModel setters and validators\n     */\n    function setModelValue(value) {\n      ngModelCtrl.$setViewValue( minMaxValidator(stepValidator(value)) );\n    }\n    function ngModelRender() {\n      if (isNaN(ngModelCtrl.$viewValue)) {\n        ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;\n      }\n\n      var percent = (ngModelCtrl.$viewValue - min) / (max - min);\n      scope.modelValue = ngModelCtrl.$viewValue;\n      element.attr('aria-valuenow', ngModelCtrl.$viewValue);\n      setSliderPercent(percent);\n      thumbText.text( ngModelCtrl.$viewValue );\n    }\n\n    function minMaxValidator(value) {\n      if (angular.isNumber(value)) {\n        return Math.max(min, Math.min(max, value));\n      }\n    }\n    function stepValidator(value) {\n      if (angular.isNumber(value)) {\n        var formattedValue = (Math.round(value / step) * step);\n        // Format to 3 digits after the decimal point - fixes #2015.\n        return (Math.round(formattedValue * 1000) / 1000);\n      }\n    }\n\n    /**\n     * @param percent 0-1\n     */\n    function setSliderPercent(percent) {\n      activeTrack.css('width', (percent * 100) + '%');\n      thumbContainer.css(\n        'left',\n        (percent * 100) + '%'\n      );\n      element.toggleClass('md-min', percent === 0);\n    }\n\n\n    /**\n     * Slide listeners\n     */\n    var isDragging = false;\n    var isDiscrete = angular.isDefined(attr.mdDiscrete);\n\n    function onPressDown(ev) {\n      if (isDisabledGetter()) return;\n\n      element.addClass('active');\n      element[0].focus();\n      refreshSliderDimensions();\n\n      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      scope.$apply(function() {\n        setModelValue( closestVal );\n        setSliderPercent( valueToPercent(closestVal));\n      });\n    }\n    function onPressUp(ev) {\n      if (isDisabledGetter()) return;\n\n      element.removeClass('dragging active');\n\n      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      scope.$apply(function() {\n        setModelValue(closestVal);\n        ngModelRender();\n      });\n    }\n    function onDragStart(ev) {\n      if (isDisabledGetter()) return;\n      isDragging = true;\n      ev.stopPropagation();\n\n      element.addClass('dragging');\n      setSliderFromEvent(ev);\n    }\n    function onDrag(ev) {\n      if (!isDragging) return;\n      ev.stopPropagation();\n      setSliderFromEvent(ev);\n    }\n    function onDragEnd(ev) {\n      if (!isDragging) return;\n      ev.stopPropagation();\n      isDragging = false;\n    }\n\n    function setSliderFromEvent(ev) {\n      // While panning discrete, update only the\n      // visual positioning but not the model value.\n      if ( isDiscrete ) adjustThumbPosition( ev.pointer.x );\n      else              doSlide( ev.pointer.x );\n    }\n\n    /**\n     * Slide the UI by changing the model value\n     * @param x\n     */\n    function doSlide( x ) {\n      scope.$evalAsync( function() {\n        setModelValue( percentToValue( positionToPercent(x) ));\n      });\n    }\n\n    /**\n     * Slide the UI without changing the model (while dragging/panning)\n     * @param x\n     */\n    function adjustThumbPosition( x ) {\n      var exactVal = percentToValue( positionToPercent( x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      setSliderPercent( positionToPercent(x) );\n      thumbText.text( closestVal );\n    }\n\n    /**\n     * Convert horizontal position on slider to percentage value of offset from beginning...\n     * @param x\n     * @returns {number}\n     */\n    function positionToPercent( x ) {\n      return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));\n    }\n\n    /**\n     * Convert percentage offset on slide to equivalent model value\n     * @param percent\n     * @returns {*}\n     */\n    function percentToValue( percent ) {\n      return (min + percent * (max - min));\n    }\n\n    function valueToPercent( val ) {\n      return (val - min)/(max - min);\n    }\n  }\n}\nSliderDirective.$inject = [\"$$rAF\", \"$window\", \"$mdAria\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdGesture\", \"$parse\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.subheader\n * @description\n * SubHeader module\n *\n *  Subheaders are special list tiles that delineate distinct sections of a\n *  list or grid list and are typically related to the current filtering or\n *  sorting criteria. Subheader tiles are either displayed inline with tiles or\n *  can be associated with content, for example, in an adjacent column.\n *\n *  Upon scrolling, subheaders remain pinned to the top of the screen and remain\n *  pinned until pushed on or off screen by the next subheader. @see [Material\n *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)\n *\n *  > To improve the visual grouping of content, use the system color for your subheaders.\n *\n */\nangular.module('material.components.subheader', [\n  'material.core',\n  'material.components.sticky'\n])\n  .directive('mdSubheader', MdSubheaderDirective);\n\n/**\n * @ngdoc directive\n * @name mdSubheader\n * @module material.components.subheader\n *\n * @restrict E\n *\n * @description\n * The `<md-subheader>` directive is a subheader for a section. By default it is sticky.\n * You can make it not sticky by applying the `md-no-sticky` class to the subheader.\n *\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-subheader>Online Friends</md-subheader>\n * </hljs>\n */\n\nfunction MdSubheaderDirective($mdSticky, $compile, $mdTheming) {\n  return {\n    restrict: 'E',\n    replace: true,\n    transclude: true,\n    template: \n      '<h2 class=\"md-subheader\">' +\n        '<div class=\"md-subheader-inner\">' +\n          '<span class=\"md-subheader-content\"></span>' +\n        '</div>' +\n      '</h2>',\n    compile: function(element, attr, transclude) {\n      return function postLink(scope, element, attr) {\n        $mdTheming(element);\n        var outerHTML = element[0].outerHTML;\n\n        function getContent(el) {\n          return angular.element(el[0].querySelector('.md-subheader-content'));\n        }\n\n        // Transclude the user-given contents of the subheader\n        // the conventional way.\n        transclude(scope, function(clone) {\n          getContent(element).append(clone);\n        });\n\n        // Create another clone, that uses the outer and inner contents\n        // of the element, that will be 'stickied' as the user scrolls.\n        if (!element.hasClass('md-no-sticky')) {\n          transclude(scope, function(clone) {\n            var stickyClone = $compile(angular.element(outerHTML))(scope);\n            getContent(stickyClone).append(clone);\n            $mdSticky(scope, element, stickyClone);\n          });\n        }\n      };\n    }\n  };\n}\nMdSubheaderDirective.$inject = [\"$mdSticky\", \"$compile\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * @ngdoc module\n * @name material.components.sticky\n * @description\n *\n * Sticky effects for md\n */\n\nangular.module('material.components.sticky', [\n  'material.core',\n  'material.components.content'\n])\n  .factory('$mdSticky', MdSticky);\n\n/*\n * @ngdoc service\n * @name $mdSticky\n * @module material.components.sticky\n *\n * @description\n * The `$mdSticky`service provides a mixin to make elements sticky.\n *\n * @returns A `$mdSticky` function that takes three arguments:\n *   - `scope`\n *   - `element`: The element that will be 'sticky'\n *   - `elementClone`: A clone of the element, that will be shown\n *     when the user starts scrolling past the original element.\n *     If not provided, it will use the result of `element.clone()`.\n */\n\nfunction MdSticky($document, $mdConstant, $compile, $$rAF, $mdUtil) {\n\n  var browserStickySupport = checkStickySupport();\n\n  /**\n   * Registers an element as sticky, used internally by directives to register themselves\n   */\n  return function registerStickyElement(scope, element, stickyClone) {\n    var contentCtrl = element.controller('mdContent');\n    if (!contentCtrl) return;\n\n    if (browserStickySupport) {\n      element.css({\n        position: browserStickySupport,\n        top: 0,\n        'z-index': 2\n      });\n    } else {\n      var $$sticky = contentCtrl.$element.data('$$sticky');\n      if (!$$sticky) {\n        $$sticky = setupSticky(contentCtrl);\n        contentCtrl.$element.data('$$sticky', $$sticky);\n      }\n\n      var deregister = $$sticky.add(element, stickyClone || element.clone());\n      scope.$on('$destroy', deregister);\n    }\n  };\n\n  function setupSticky(contentCtrl) {\n    var contentEl = contentCtrl.$element;\n\n    // Refresh elements is very expensive, so we use the debounced\n    // version when possible.\n    var debouncedRefreshElements = $$rAF.throttle(refreshElements);\n\n    // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,\n    // more reliable than `scroll` on android.\n    setupAugmentedScrollEvents(contentEl);\n    contentEl.on('$scrollstart', debouncedRefreshElements);\n    contentEl.on('$scroll', onScroll);\n\n    var self;\n    var stickyBaseoffset = contentEl.prop('offsetTop');\n    return self = {\n      prev: null,\n      current: null, //the currently stickied item\n      next: null,\n      items: [],\n      add: add,\n      refreshElements: refreshElements\n    };\n\n    /***************\n     * Public\n     ***************/\n    // Add an element and its sticky clone to this content's sticky collection\n    function add(element, stickyClone) {\n      stickyClone.addClass('md-sticky-clone');\n      stickyClone.css('top', stickyBaseoffset + 'px');\n\n      var item = {\n        element: element,\n        clone: stickyClone\n      };\n      self.items.push(item);\n\n      contentEl.parent().prepend(item.clone);\n\n      debouncedRefreshElements();\n\n      return function remove() {\n        self.items.forEach(function(item, index) {\n          if (item.element[0] === element[0]) {\n            self.items.splice(index, 1);\n            item.clone.remove();\n          }\n        });\n        debouncedRefreshElements();\n      };\n    }\n\n    function refreshElements() {\n      // Sort our collection of elements by their current position in the DOM.\n      // We need to do this because our elements' order of being added may not\n      // be the same as their order of display.\n      self.items.forEach(refreshPosition);\n      self.items = self.items.sort(function(a, b) {\n        return a.top < b.top ? -1 : 1;\n      });\n\n      // Find which item in the list should be active, \n      // based upon the content's current scroll position\n      var item;\n      var currentScrollTop = contentEl.prop('scrollTop');\n      for (var i = self.items.length - 1; i >= 0; i--) {\n        if (currentScrollTop > self.items[i].top) {\n          item = self.items[i];\n          break;\n        }\n      }\n      setCurrentItem(item);\n    }\n\n\n    /***************\n     * Private\n     ***************/\n\n    // Find the `top` of an item relative to the content element,\n    // and also the height.\n    function refreshPosition(item) {\n      // Find the top of an item by adding to the offsetHeight until we reach the \n      // content element.\n      var current = item.element[0];\n      item.top = 0;\n      item.left = 0;\n      while (current && current !== contentEl[0]) {\n        item.top += current.offsetTop;\n        item.left += current.offsetLeft;\n        current = current.offsetParent;\n      }\n      item.height = item.element.prop('offsetHeight');\n      item.clone.css('margin-left', item.left + 'px');\n      if ($mdUtil.floatingScrollbars()) {\n        item.clone.css('margin-right', '0');\n      }\n    }\n\n\n    // As we scroll, push in and select the correct sticky element.\n    function onScroll() {\n      var scrollTop = contentEl.prop('scrollTop');\n      var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);\n      onScroll.prevScrollTop = scrollTop;\n\n      // At the top?\n      if (scrollTop === 0) {\n        setCurrentItem(null);\n\n      // Going to next item?\n      } else if (isScrollingDown && self.next) {\n        if (self.next.top - scrollTop <= 0) {\n          // Sticky the next item if we've scrolled past its position.\n          setCurrentItem(self.next);\n        } else if (self.current) {\n          // Push the current item up when we're almost at the next item.\n          if (self.next.top - scrollTop <= self.next.height) {\n            translate(self.current, self.next.top - self.next.height - scrollTop);\n          } else {\n            translate(self.current, null);\n          }\n        }\n        \n      // Scrolling up with a current sticky item?\n      } else if (!isScrollingDown && self.current) {\n        if (scrollTop < self.current.top) {\n          // Sticky the previous item if we've scrolled up past\n          // the original position of the currently stickied item.\n          setCurrentItem(self.prev);\n        }\n        // Scrolling up, and just bumping into the item above (just set to current)?\n        // If we have a next item bumping into the current item, translate\n        // the current item up from the top as it scrolls into view.\n        if (self.current && self.next) {\n          if (scrollTop >= self.next.top - self.current.height) {\n            translate(self.current, self.next.top - scrollTop - self.current.height);\n          } else {\n            translate(self.current, null);\n          }\n        }\n      }\n    }\n     \n   function setCurrentItem(item) {\n     if (self.current === item) return;\n     // Deactivate currently active item\n     if (self.current) {\n       translate(self.current, null);\n       setStickyState(self.current, null);\n     }\n\n     // Activate new item if given\n     if (item) {\n       setStickyState(item, 'active');\n     }\n\n     self.current = item;\n     var index = self.items.indexOf(item);\n     // If index === -1, index + 1 = 0. It works out.\n     self.next = self.items[index + 1];\n     self.prev = self.items[index - 1];\n     setStickyState(self.next, 'next');\n     setStickyState(self.prev, 'prev');\n   }\n\n   function setStickyState(item, state) {\n     if (!item || item.state === state) return;\n     if (item.state) {\n       item.clone.attr('sticky-prev-state', item.state);\n       item.element.attr('sticky-prev-state', item.state);\n     }\n     item.clone.attr('sticky-state', state);\n     item.element.attr('sticky-state', state);\n     item.state = state;\n   }\n\n   function translate(item, amount) {\n     if (!item) return;\n     if (amount === null || amount === undefined) {\n       if (item.translateY) {\n         item.translateY = null;\n         item.clone.css($mdConstant.CSS.TRANSFORM, '');\n       }\n     } else {\n       item.translateY = amount;\n       item.clone.css(\n         $mdConstant.CSS.TRANSFORM, \n         'translate3d(' + item.left + 'px,' + amount + 'px,0)'\n       );\n     }\n   }\n  }\n\n  // Function to check for browser sticky support\n  function checkStickySupport($el) {\n    var stickyProp;\n    var testEl = angular.element('<div>');\n    $document[0].body.appendChild(testEl[0]);\n\n    var stickyProps = ['sticky', '-webkit-sticky'];\n    for (var i = 0; i < stickyProps.length; ++i) {\n      testEl.css({position: stickyProps[i], top: 0, 'z-index': 2});\n      if (testEl.css('position') == stickyProps[i]) {\n        stickyProp = stickyProps[i];\n        break;\n      }\n    }\n    testEl.remove();\n    return stickyProp;\n  }\n\n  // Android 4.4 don't accurately give scroll events.\n  // To fix this problem, we setup a fake scroll event. We say:\n  // > If a scroll or touchmove event has happened in the last DELAY milliseconds, \n  //   then send a `$scroll` event every animationFrame.\n  // Additionally, we add $scrollstart and $scrollend events.\n  function setupAugmentedScrollEvents(element) {\n    var SCROLL_END_DELAY = 200;\n    var isScrolling;\n    var lastScrollTime;\n    element.on('scroll touchmove', function() {\n      if (!isScrolling) {\n        isScrolling = true;\n        $$rAF(loopScrollEvent);\n        element.triggerHandler('$scrollstart');\n      }\n      element.triggerHandler('$scroll');\n      lastScrollTime = +$mdUtil.now();\n    });\n\n    function loopScrollEvent() {\n      if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {\n        isScrolling = false;\n        element.triggerHandler('$scrollend');\n      } else {\n        element.triggerHandler('$scroll');\n        $$rAF(loopScrollEvent);\n      }\n    }\n  }\n\n}\nMdSticky.$inject = [\"$document\", \"$mdConstant\", \"$compile\", \"$$rAF\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.swipe\n * @description Swipe module!\n */\n/**\n * @ngdoc directive\n * @module material.components.swipe\n * @name mdSwipeLeft\n *\n * @restrict A\n *\n * @description\n * The md-swipe-left directives allows you to specify custom behavior when an element is swiped\n * left.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div md-swipe-left=\"onSwipeLeft()\">Swipe me left!</div>\n * </hljs>\n */\n/**\n * @ngdoc directive\n * @module material.components.swipe\n * @name mdSwipeRight\n *\n * @restrict A\n *\n * @description\n * The md-swipe-right directives allows you to specify custom behavior when an element is swiped\n * right.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div md-swipe-right=\"onSwipeRight()\">Swipe me right!</div>\n * </hljs>\n */\n\nangular.module('material.components.swipe', ['material.core'])\n    .directive('mdSwipeLeft', getDirective('SwipeLeft'))\n    .directive('mdSwipeRight', getDirective('SwipeRight'));\n\nfunction getDirective(name) {\n  var directiveName = 'md' + name;\n  var eventName = '$md.' + name.toLowerCase();\n\n    DirectiveFactory.$inject = [\"$parse\"];\n  return DirectiveFactory;\n\n  /* @ngInject */\n  function DirectiveFactory($parse) {\n      return { restrict: 'A', link: postLink };\n      function postLink(scope, element, attr) {\n        var fn = $parse(attr[directiveName]);\n        element.on(eventName, function(ev) {\n          scope.$apply(function() { fn(scope, { $event: ev }); });\n        });\n      }\n    }\n}\n\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @private\n * @ngdoc module\n * @name material.components.switch\n */\n\nangular.module('material.components.switch', [\n  'material.core',\n  'material.components.checkbox'\n])\n  .directive('mdSwitch', MdSwitch);\n\n/**\n * @private\n * @ngdoc directive\n * @module material.components.switch\n * @name mdSwitch\n * @restrict E\n *\n * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the switch is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.\n * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-switch ng-model=\"isActive\" aria-label=\"Finished?\">\n *   Finished ?\n * </md-switch>\n *\n * <md-switch md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n *   No Ink Effects\n * </md-switch>\n *\n * <md-switch ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n *   Disabled\n * </md-switch>\n *\n * </hljs>\n */\nfunction MdSwitch(mdCheckboxDirective, $mdTheming, $mdUtil, $document, $mdConstant, $parse, $$rAF, $mdGesture) {\n  var checkboxDirective = mdCheckboxDirective[0];\n\n  return {\n    restrict: 'E',\n    priority:210, // Run before ngAria\n    transclude: true,\n    template:\n      '<div class=\"md-container\">' +\n        '<div class=\"md-bar\"></div>' +\n        '<div class=\"md-thumb-container\">' +\n          '<div class=\"md-thumb\" md-ink-ripple md-ink-ripple-checkbox></div>' +\n        '</div>'+\n      '</div>' +\n      '<div ng-transclude class=\"md-label\">' +\n      '</div>',\n    require: '?ngModel',\n    compile: compile\n  };\n\n  function compile(element, attr) {\n    var checkboxLink = checkboxDirective.compile(element, attr);\n    // no transition on initial load\n    element.addClass('md-dragging');\n\n    return function (scope, element, attr, ngModel) {\n      ngModel = ngModel || $mdUtil.fakeNgModel();\n      var disabledGetter = $parse(attr.ngDisabled);\n      var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));\n      var switchContainer = angular.element(element[0].querySelector('.md-container'));\n\n      // no transition on initial load\n      $$rAF(function() {\n        element.removeClass('md-dragging');\n      });\n\n      checkboxLink(scope, element, attr, ngModel);\n\n      if (angular.isDefined(attr.ngDisabled)) {\n        scope.$watch(disabledGetter, function(isDisabled) {\n          element.attr('tabindex', isDisabled ? -1 : 0);\n        });\n      }\n\n      // These events are triggered by setup drag\n      $mdGesture.register(switchContainer, 'drag');\n      switchContainer\n        .on('$md.dragstart', onDragStart)\n        .on('$md.drag', onDrag)\n        .on('$md.dragend', onDragEnd);\n\n      var drag;\n      function onDragStart(ev) {\n        // Don't go if ng-disabled===true\n        if (disabledGetter(scope)) return;\n        ev.stopPropagation();\n\n        element.addClass('md-dragging');\n        drag = {\n          width: thumbContainer.prop('offsetWidth')\n        };\n        element.removeClass('transition');\n      }\n\n      function onDrag(ev) {\n        if (!drag) return;\n        ev.stopPropagation();\n        ev.srcEvent && ev.srcEvent.preventDefault();\n\n        var percent = ev.pointer.distanceX / drag.width;\n\n        //if checked, start from right. else, start from left\n        var translate = ngModel.$viewValue ?  1 + percent : percent;\n        // Make sure the switch stays inside its bounds, 0-1%\n        translate = Math.max(0, Math.min(1, translate));\n\n        thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100*translate) + '%,0,0)');\n        drag.translate = translate;\n      }\n\n      function onDragEnd(ev) {\n        if (!drag) return;\n        ev.stopPropagation();\n\n        element.removeClass('md-dragging');\n        thumbContainer.css($mdConstant.CSS.TRANSFORM, '');\n\n        // We changed if there is no distance (this is a click a click),\n        // or if the drag distance is >50% of the total.\n        var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5;\n        if (isChanged) {\n          applyModelValue(!ngModel.$viewValue);\n        }\n        drag = null;\n      }\n\n      function applyModelValue(newValue) {\n        scope.$apply(function() {\n          ngModel.$setViewValue(newValue);\n          ngModel.$render();\n        });\n      }\n\n    };\n  }\n\n\n}\nMdSwitch.$inject = [\"mdCheckboxDirective\", \"$mdTheming\", \"$mdUtil\", \"$document\", \"$mdConstant\", \"$parse\", \"$$rAF\", \"$mdGesture\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.tabs\n * @description\n *\n *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.\n *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.\n *\n *  Features include support for:\n *\n *  - static or dynamic tabs,\n *  - responsive designs,\n *  - accessibility support (ARIA),\n *  - tab pagination,\n *  - external or internal tab content,\n *  - focus indicators and arrow-key navigations,\n *  - programmatic lookup and access to tab controllers, and\n *  - dynamic transitions through different tab contents.\n *\n */\n/*\n * @see js folder for tabs implementation\n */\nangular.module('material.components.tabs', [\n  'material.core',\n  'material.components.icon'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.toast\n * @description\n * Toast\n */\nangular.module('material.components.toast', [\n  'material.core',\n  'material.components.button'\n])\n  .directive('mdToast', MdToastDirective)\n  .provider('$mdToast', MdToastProvider);\n\nfunction MdToastDirective() {\n  return {\n    restrict: 'E'\n  };\n}\n\n/**\n * @ngdoc service\n * @name $mdToast\n * @module material.components.toast\n *\n * @description\n * `$mdToast` is a service to build a toast notification on any position\n * on the screen with an optional duration, and provides a simple promise API.\n *\n *\n * ## Restrictions on custom toasts\n * - The toast's template must have an outer `<md-toast>` element.\n * - For a toast action, use element with class `md-action`.\n * - Add the class `md-capsule` for curved corners.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div ng-controller=\"MyController\">\n *   <md-button ng-click=\"openToast()\">\n *     Open a Toast!\n *   </md-button>\n * </div>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * var app = angular.module('app', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdToast) {\n *   $scope.openToast = function($event) {\n *     $mdToast.show($mdToast.simple().content('Hello!'));\n *     // Could also do $mdToast.showSimple('Hello');\n *   };\n * });\n * </hljs>\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#showSimple\n * \n * @description\n * Convenience method which builds and shows a simple toast.\n *\n * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n * rejected with `$mdToast.cancel()`.\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#simple\n *\n * @description\n * Builds a preconfigured toast.\n *\n * @returns {obj} a `$mdToastPreset` with the chainable configuration methods:\n *\n * - $mdToastPreset#content(string) - sets toast content to string\n * - $mdToastPreset#action(string) - adds an action button, which resolves the promise returned from `show()` if clicked.\n * - $mdToastPreset#highlightAction(boolean) - sets action button to be highlighted\n * - $mdToastPreset#capsule(boolean) - adds 'md-capsule' class to the toast (curved corners)\n * - $mdToastPreset#theme(boolean) - sets the theme on the toast to theme (default is `$mdThemingProvider`'s default theme)\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#updateContent\n * \n * @description\n * Updates the content of an existing toast. Useful for updating things like counts, etc.\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#build\n *\n * @description\n * Creates a custom `$mdToastPreset` that you can configure.\n *\n * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#show\n *\n * @description Shows the toast.\n *\n * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`\n * and `build()`, or an options object with the following properties:\n *\n *   - `templateUrl` - `{string=}`: The url of an html template file that will\n *     be used as the content of the toast. Restrictions: the template must\n *     have an outer `md-toast` element.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n *     template string.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n *     This scope will be destroyed when the toast is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay\n *     active before automatically closing.  Set to 0 or false to have the toast stay open until\n *     closed manually. Default: 3000.\n *   - `position` - `{string=}`: Where to place the toast. Available: any combination\n *     of 'bottom', 'left', 'top', 'right', 'fit'. Default: 'bottom left'.\n *   - `controller` - `{string=}`: The controller to associate with this toast.\n *     The controller will be injected the local `$hideToast`, which is a function\n *     used to hide the toast.\n *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n *     be used as names of values to inject into the controller. For example,\n *     `locals: {three: 3}` would inject `three` into the controller with the value\n *     of 3.\n *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in. These values will not be available until after initialization.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n *     and the toast will not open until the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending\n *     to the root element of the application.\n *\n * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n * rejected with `$mdToast.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#hide\n *\n * @description\n * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.\n *\n * @param {*=} response An argument for the resolved promise.\n *\n * @returns {promise} a promise that is called when the existing element is removed from the DOM\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#cancel\n *\n * @description\n * Hide the existing toast and reject the promise returned from\n * `$mdToast.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n *\n * @returns {promise} a promise that is called when the existing element is removed from the DOM\n *\n */\n\nfunction MdToastProvider($$interimElementProvider) {\n  var activeToastContent;\n  var $mdToast = $$interimElementProvider('$mdToast')\n    .setDefaults({\n      methods: ['position', 'hideDelay', 'capsule' ],\n      options: toastDefaultOptions\n    })\n    .addPreset('simple', {\n      argOption: 'content',\n      methods: ['content', 'action', 'highlightAction', 'theme', 'parent'],\n      options: /* @ngInject */ [\"$mdToast\", \"$mdTheming\", function($mdToast, $mdTheming) {\n        var opts = {\n          template: [\n            '<md-toast md-theme=\"{{ toast.theme }}\" ng-class=\"{\\'md-capsule\\': toast.capsule}\">',\n              '<span flex>{{ toast.content }}</span>',\n              '<md-button class=\"md-action\" ng-if=\"toast.action\" ng-click=\"toast.resolve()\" ng-class=\"{\\'md-highlight\\': toast.highlightAction}\">',\n                '{{ toast.action }}',\n              '</md-button>',\n            '</md-toast>'\n          ].join(''),\n          controller: /* @ngInject */ [\"$scope\", function mdToastCtrl($scope) {\n            var self = this;\n            $scope.$watch(function() { return activeToastContent; }, function() {\n              self.content = activeToastContent;\n            });\n            this.resolve = function() {\n              $mdToast.hide();\n            };\n          }],\n          theme: $mdTheming.defaultTheme(),\n          controllerAs: 'toast',\n          bindToController: true\n        };\n        return opts;\n      }]\n    })\n    .addMethod('updateContent', function(newContent) {\n      activeToastContent = newContent;\n    });\n\n  toastDefaultOptions.$inject = [\"$timeout\", \"$animate\", \"$mdToast\", \"$mdUtil\"];\n    return $mdToast;\n\n  /* @ngInject */\n  function toastDefaultOptions($timeout, $animate, $mdToast, $mdUtil) {\n    return {\n      onShow: onShow,\n      onRemove: onRemove,\n      position: 'bottom left',\n      themable: true,\n      hideDelay: 3000\n    };\n\n    function onShow(scope, element, options) {\n      element = $mdUtil.extractElementByName(element, 'md-toast');\n\n      // 'top left' -> 'md-top md-left'\n      activeToastContent = options.content;\n      element.addClass(options.position.split(' ').map(function(pos) {\n        return 'md-' + pos;\n      }).join(' '));\n      options.parent.addClass(toastOpenClass(options.position));\n\n      options.onSwipe = function(ev, gesture) {\n        //Add swipeleft/swiperight class to element so it can animate correctly\n        element.addClass('md-' + ev.type.replace('$md.',''));\n        $timeout($mdToast.cancel);\n      };\n      element.on('$md.swipeleft $md.swiperight', options.onSwipe);\n      return $animate.enter(element, options.parent);\n    }\n\n    function onRemove(scope, element, options) {\n      element.off('$md.swipeleft $md.swiperight', options.onSwipe);\n      options.parent.removeClass(toastOpenClass(options.position));\n      return $animate.leave(element);\n    }\n\n    function toastOpenClass(position) {\n      return 'md-toast-open-' +\n        (position.indexOf('top') > -1 ? 'top' : 'bottom');\n    }\n  }\n\n}\nMdToastProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.toolbar\n */\nangular.module('material.components.toolbar', [\n  'material.core',\n  'material.components.content'\n])\n  .directive('mdToolbar', mdToolbarDirective);\n\n/**\n * @ngdoc directive\n * @name mdToolbar\n * @module material.components.toolbar\n * @restrict E\n * @description\n * `md-toolbar` is used to place a toolbar in your app.\n *\n * Toolbars are usually used above a content area to display the title of the\n * current page, and show relevant action buttons for that page.\n *\n * You can change the height of the toolbar by adding either the\n * `md-medium-tall` or `md-tall` class to the toolbar.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div layout=\"column\" layout-fill>\n *   <md-toolbar>\n *\n *     <div class=\"md-toolbar-tools\">\n *       <span>My App's Title</span>\n *\n *       <!-- fill up the space between left and right area -->\n *       <span flex></span>\n *\n *       <md-button>\n *         Right Bar Button\n *       </md-button>\n *     </div>\n *\n *   </md-toolbar>\n *   <md-content>\n *     Hello!\n *   </md-content>\n * </div>\n * </hljs>\n *\n * @param {boolean=} md-scroll-shrink Whether the header should shrink away as\n * the user scrolls down, and reveal itself as the user scrolls up.\n * Note: for scrollShrink to work, the toolbar must be a sibling of a\n * `md-content` element, placed before it. See the scroll shrink demo.\n *\n *\n * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's\n * shrinking by. For example, if 0.25 is given then the toolbar will shrink\n * at one fourth the rate at which the user scrolls down. Default 0.5.\n */\nfunction mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate, $timeout) {\n\n  return {\n    restrict: 'E',\n    controller: angular.noop,\n    link: function(scope, element, attr) {\n      $mdTheming(element);\n\n      if (angular.isDefined(attr.mdScrollShrink)) {\n        setupScrollShrink();\n      }\n\n      function setupScrollShrink() {\n        // Current \"y\" position of scroll\n        var y = 0;\n        // Store the last scroll top position\n        var prevScrollTop = 0;\n\n        var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;\n\n        var toolbarHeight;\n        var contentElement;\n\n        var debouncedContentScroll = $$rAF.throttle(onContentScroll);\n        var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);\n\n        // Wait for $mdContentLoaded event from mdContent directive.\n        // If the mdContent element is a sibling of our toolbar, hook it up\n        // to scroll events.\n        scope.$on('$mdContentLoaded', onMdContentLoad);\n\n        function onMdContentLoad($event, newContentEl) {\n          // Toolbar and content must be siblings\n          if (element.parent()[0] === newContentEl.parent()[0]) {\n            // unhook old content event listener if exists\n            if (contentElement) {\n              contentElement.off('scroll', debouncedContentScroll);\n            }\n\n            newContentEl.on('scroll', debouncedContentScroll);\n            newContentEl.attr('scroll-shrink', 'true');\n\n            contentElement = newContentEl;\n            $$rAF(updateToolbarHeight);\n          }\n        }\n\n        function updateToolbarHeight() {\n          toolbarHeight = element.prop('offsetHeight');\n          // Add a negative margin-top the size of the toolbar to the content el.\n          // The content will start transformed down the toolbarHeight amount,\n          // so everything looks normal.\n          //\n          // As the user scrolls down, the content will be transformed up slowly\n          // to put the content underneath where the toolbar was.\n          var margin =  (-toolbarHeight * shrinkSpeedFactor) + 'px';\n          contentElement.css('margin-top', margin);\n          contentElement.css('margin-bottom', margin);\n\n          onContentScroll();\n        }\n\n        function onContentScroll(e) {\n          var scrollTop = e ? e.target.scrollTop : prevScrollTop;\n\n          debouncedUpdateHeight();\n\n          y = Math.min(\n            toolbarHeight / shrinkSpeedFactor,\n            Math.max(0, y + scrollTop - prevScrollTop)\n          );\n\n          element.css(\n            $mdConstant.CSS.TRANSFORM,\n            'translate3d(0,' + (-y * shrinkSpeedFactor) + 'px,0)'\n          );\n          contentElement.css(\n            $mdConstant.CSS.TRANSFORM,\n            'translate3d(0,' + ((toolbarHeight - y) * shrinkSpeedFactor) + 'px,0)'\n          );\n\n          prevScrollTop = scrollTop;\n\n            if (element.hasClass('md-whiteframe-z1')) {\n              if (!y) {\n                $timeout(function () { $animate.removeClass(element, 'md-whiteframe-z1'); });\n              }\n            } else {\n              if (y) {\n                $timeout(function () { $animate.addClass(element, 'md-whiteframe-z1'); });\n              }\n            }\n        }\n\n      }\n\n    }\n  };\n\n}\nmdToolbarDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdUtil\", \"$mdTheming\", \"$animate\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.tooltip\n */\nangular\n    .module('material.components.tooltip', [ 'material.core' ])\n    .directive('mdTooltip', MdTooltipDirective);\n\n/**\n * @ngdoc directive\n * @name mdTooltip\n * @module material.components.tooltip\n * @description\n * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).\n *\n * Place a `<md-tooltip>` as a child of the element it describes.\n *\n * A tooltip will activate when the user focuses, hovers over, or touches the parent.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-button class=\"md-fab md-accent\" aria-label=\"Play\">\n *   <md-tooltip>\n *     Play Music\n *   </md-tooltip>\n *   <md-icon icon=\"img/icons/ic_play_arrow_24px.svg\"></md-icon>\n * </md-button>\n * </hljs>\n *\n * @param {expression=} md-visible Boolean bound to whether the tooltip is\n * currently visible.\n * @param {number=} md-delay How many milliseconds to wait to show the tooltip after the user focuses, hovers, or touches the parent. Defaults to 400ms.\n * @param {string=} md-direction Which direction would you like the tooltip to go?  Supports left, right, top, and bottom.  Defaults to bottom.\n * @param {boolean=} md-autohide If present or provided with a boolean value, the tooltip will hide on mouse leave, regardless of focus\n */\nfunction MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement,\n                            $animate, $q) {\n\n  var TOOLTIP_SHOW_DELAY = 300;\n  var TOOLTIP_WINDOW_EDGE_SPACE = 8;\n\n  return {\n    restrict: 'E',\n    transclude: true,\n    priority:210, // Before ngAria\n    template: '\\\n        <div class=\"md-background\"></div>\\\n        <div class=\"md-content\" ng-transclude></div>',\n    scope: {\n      visible: '=?mdVisible',\n      delay: '=?mdDelay',\n      autohide: '=?mdAutohide'\n    },\n    link: postLink\n  };\n\n  function postLink(scope, element, attr) {\n\n    $mdTheming(element);\n\n    var parent        = getParentWithPointerEvents(),\n        background    = angular.element(element[0].getElementsByClassName('md-background')[0]),\n        content       = angular.element(element[0].getElementsByClassName('md-content')[0]),\n        direction     = attr.mdDirection,\n        current       = getNearestContentElement(),\n        tooltipParent = angular.element(current || document.body),\n        debouncedOnResize = $$rAF.throttle(function () { if (scope.visible) positionTooltip(); });\n\n    return init();\n\n    function init () {\n      setDefaults();\n      manipulateElement();\n      bindEvents();\n      configureWatchers();\n      addAriaLabel();\n    }\n\n    function setDefaults () {\n      if (!angular.isDefined(attr.mdDelay)) scope.delay = TOOLTIP_SHOW_DELAY;\n    }\n\n    function configureWatchers () {\n      scope.$on('$destroy', function() {\n        scope.visible = false;\n        element.remove();\n        angular.element($window).off('resize', debouncedOnResize);\n      });\n      scope.$watch('visible', function (isVisible) {\n        if (isVisible) showTooltip();\n        else hideTooltip();\n      });\n    }\n\n    function addAriaLabel () {\n      if (!parent.attr('aria-label') && !parent.text().trim()) {\n        parent.attr('aria-label', element.text().trim());\n      }\n    }\n\n    function manipulateElement () {\n      element.detach();\n      element.attr('role', 'tooltip');\n    }\n\n    function getParentWithPointerEvents () {\n      var parent = element.parent();\n      while (parent && $window.getComputedStyle(parent[0])['pointer-events'] == 'none') {\n        parent = parent.parent();\n      }\n      return parent;\n    }\n\n     function getNearestContentElement () {\n       var current = element.parent()[0];\n       // Look for the nearest parent md-content, stopping at the rootElement.\n       while (current && current !== $rootElement[0] && current !== document.body) {\n         current = current.parentNode;\n       }\n       return current;\n     }\n\n    function hasComputedStyleValue(key, value) {\n        // Check if we should show it or not...\n        var computedStyles = $window.getComputedStyle(element[0]);\n        return angular.isDefined(computedStyles[key]) && (computedStyles[key] == value);\n    }\n\n    function bindEvents () {\n      var mouseActive = false;\n      var enterHandler = function() {\n        if (!hasComputedStyleValue('pointer-events','none')) {\n          setVisible(true);\n        }\n      };\n      var leaveHandler = function () {\n        var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');\n        if (autohide || mouseActive || ($document[0].activeElement !== parent[0]) ) {\n          setVisible(false);\n        }\n        mouseActive = false;\n      };\n\n      // to avoid `synthetic clicks` we listen to mousedown instead of `click`\n      parent.on('mousedown', function() { mouseActive = true; });\n      parent.on('focus mouseenter touchstart', enterHandler );\n      parent.on('blur mouseleave touchend touchcancel', leaveHandler );\n\n\n      angular.element($window).on('resize', debouncedOnResize);\n    }\n\n    function setVisible (value) {\n      setVisible.value = !!value;\n      if (!setVisible.queued) {\n        if (value) {\n          setVisible.queued = true;\n          $timeout(function() {\n            scope.visible = setVisible.value;\n            setVisible.queued = false;\n          }, scope.delay);\n        } else {\n          $timeout(function() { scope.visible = false; });\n        }\n      }\n    }\n\n    function showTooltip() {\n      // Insert the element before positioning it, so we can get the position\n      // and check if we should display it\n      tooltipParent.append(element);\n\n      // Check if we should display it or not.\n      // This handles hide-* and show-* along with any user defined css\n      if ( hasComputedStyleValue('display','none') ) {\n        scope.visible = false;\n        element.detach();\n        return;\n      }\n\n      positionTooltip();\n      angular.forEach([element, background, content], function (element) {\n        $animate.addClass(element, 'md-show');\n      });\n    }\n\n    function hideTooltip() {\n      $q.all([\n        $animate.removeClass(content, 'md-show'),\n        $animate.removeClass(background, 'md-show'),\n        $animate.removeClass(element, 'md-show')\n      ]).then(function () {\n        if (!scope.visible) element.detach();\n      });\n    }\n\n    function positionTooltip() {\n      var tipRect = $mdUtil.offsetRect(element, tooltipParent);\n      var parentRect = $mdUtil.offsetRect(parent, tooltipParent);\n      var newPosition = getPosition(direction);\n\n      // If the user provided a direction, just nudge the tooltip onto the screen\n      // Otherwise, recalculate based on 'top' since default is 'bottom'\n      if (direction) {\n        newPosition = fitInParent(newPosition);\n      } else if (newPosition.top > element.prop('offsetParent').scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {\n        newPosition = fitInParent(getPosition('top'));\n      }\n\n      element.css({top: newPosition.top + 'px', left: newPosition.left + 'px'});\n\n      positionBackground();\n\n      function positionBackground () {\n        var size = direction === 'left' || direction === 'right'\n              ? Math.sqrt(Math.pow(tipRect.width, 2) + Math.pow(tipRect.height / 2, 2)) * 2\n              : Math.sqrt(Math.pow(tipRect.width / 2, 2) + Math.pow(tipRect.height, 2)) * 2,\n            position = direction === 'left' ? { left: 100, top: 50 }\n              : direction === 'right' ? { left: 0, top: 50 }\n              : direction === 'top' ? { left: 50, top: 100 }\n              : { left: 50, top: 0 };\n        background.css({\n          width: size + 'px',\n          height: size + 'px',\n          left: position.left + '%',\n          top: position.top + '%'\n        });\n      }\n\n      function fitInParent (pos) {\n        var newPosition = { left: pos.left, top: pos.top };\n        newPosition.left = Math.min( newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.left = Math.max( newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.top  = Math.min( newPosition.top,  tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.top  = Math.max( newPosition.top,  TOOLTIP_WINDOW_EDGE_SPACE );\n        return newPosition;\n      }\n\n      function getPosition (dir) {\n        return dir === 'left'\n          ? { left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,\n              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n          : dir === 'right'\n          ? { left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,\n              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n          : dir === 'top'\n          ? { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n              top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE }\n          : { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n              top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE };\n      }\n    }\n\n  }\n\n}\nMdTooltipDirective.$inject = [\"$timeout\", \"$window\", \"$$rAF\", \"$document\", \"$mdUtil\", \"$mdTheming\", \"$rootElement\", \"$animate\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.whiteframe\n */\nangular.module('material.components.whiteframe', []);\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .controller('MdAutocompleteCtrl', MdAutocompleteCtrl);\n\nvar ITEM_HEIGHT = 41,\n    MAX_HEIGHT = 5.5 * ITEM_HEIGHT,\n    MENU_PADDING = 8;\n\nfunction MdAutocompleteCtrl ($scope, $element, $mdUtil, $mdConstant, $timeout, $mdTheming, $window,\n                             $animate, $rootElement, $attrs) {\n  //-- private variables\n  var ctrl      = this,\n      itemParts = $scope.itemsExpr.split(/ in /i),\n      itemExpr  = itemParts[1],\n      elements  = null,\n      promise   = null,\n      cache     = {},\n      noBlur    = false,\n      selectedItemWatchers = [],\n      hasFocus  = false,\n      lastCount = 0;\n\n  //-- public variables with handlers\n  defineProperty('hidden', handleHiddenChange, true);\n\n  //-- public variables\n  ctrl.scope      = $scope;\n  ctrl.parent     = $scope.$parent;\n  ctrl.itemName   = itemParts[0];\n  ctrl.matches    = [];\n  ctrl.loading    = false;\n  ctrl.hidden     = true;\n  ctrl.index      = null;\n  ctrl.messages   = [];\n  ctrl.id         = $mdUtil.nextUid();\n  ctrl.isDisabled = null;\n  ctrl.isRequired = null;\n\n  //-- public methods\n  ctrl.keydown    = keydown;\n  ctrl.blur       = blur;\n  ctrl.focus      = focus;\n  ctrl.clear      = clearValue;\n  ctrl.select     = select;\n  ctrl.listEnter  = onListEnter;\n  ctrl.listLeave  = onListLeave;\n  ctrl.mouseUp    = onMouseup;\n  ctrl.getCurrentDisplayValue         = getCurrentDisplayValue;\n  ctrl.registerSelectedItemWatcher    = registerSelectedItemWatcher;\n  ctrl.unregisterSelectedItemWatcher  = unregisterSelectedItemWatcher;\n\n  return init();\n\n  //-- initialization methods\n\n  /**\n   * Initialize the controller, setup watchers, gather elements\n   */\n  function init () {\n    $mdUtil.initOptionalProperties($scope, $attrs, { searchText: null, selectedItem: null } );\n    $mdTheming($element);\n    configureWatchers();\n    $timeout(function () {\n      gatherElements();\n      focusElement();\n      moveDropdown();\n    });\n  }\n\n  /**\n   * Calculates the dropdown's position and applies the new styles to the menu element\n   * @returns {*}\n   */\n  function positionDropdown () {\n    if (!elements) return $timeout(positionDropdown, 0, false);\n    var hrect  = elements.wrap.getBoundingClientRect(),\n        vrect  = elements.snap.getBoundingClientRect(),\n        root   = elements.root.getBoundingClientRect(),\n        top    = vrect.bottom - root.top,\n        bot    = root.bottom - vrect.top,\n        left   = hrect.left - root.left,\n        width  = hrect.width,\n        styles = {\n          left:     left + 'px',\n          minWidth: width + 'px',\n          maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'\n        };\n    if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {\n      styles.top = 'auto';\n      styles.bottom = bot + 'px';\n      styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';\n    } else {\n      styles.top = top + 'px';\n      styles.bottom = 'auto';\n      styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom - hrect.bottom - MENU_PADDING) + 'px';\n    }\n    elements.$.ul.css(styles);\n    $timeout(correctHorizontalAlignment, 0, false);\n\n    /**\n     * Makes sure that the menu doesn't go off of the screen on either side.\n     */\n    function correctHorizontalAlignment () {\n      var dropdown = elements.ul.getBoundingClientRect(),\n          styles   = {};\n      if (dropdown.right > root.right - MENU_PADDING) {\n        styles.left = (hrect.right - dropdown.width) + 'px';\n      }\n      elements.$.ul.css(styles);\n    }\n  }\n\n  /**\n   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.\n   */\n  function moveDropdown () {\n    if (!elements.$.root.length) return;\n    $mdTheming(elements.$.ul);\n    elements.$.ul.detach();\n    elements.$.root.append(elements.$.ul);\n    if ($animate.pin) $animate.pin(elements.$.ul, $rootElement);\n  }\n\n  /**\n   * Sends focus to the input element.\n   */\n  function focusElement () {\n    if ($scope.autofocus) elements.input.focus();\n  }\n\n  /**\n   * Sets up any watchers used by autocomplete\n   */\n  function configureWatchers () {\n    var wait = parseInt($scope.delay, 10) || 0;\n    $attrs.$observe('disabled', function (value) { ctrl.isDisabled = value; });\n    $attrs.$observe('required', function (value) { ctrl.isRequired = value !== null; });\n    $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);\n    registerSelectedItemWatcher(selectedItemChange);\n    $scope.$watch('selectedItem', handleSelectedItemChange);\n    angular.element($window).on('resize', positionDropdown);\n    $scope.$on('$destroy', cleanup);\n  }\n\n  /**\n   * Removes any events or leftover elements created by this controller\n   */\n  function cleanup () {\n    angular.element($window).off('resize', positionDropdown);\n    elements.$.ul.remove();\n  }\n\n  /**\n   * Gathers all of the elements needed for this controller\n   */\n  function gatherElements () {\n    elements = {\n      main:  $element[0],\n      ul:    $element.find('ul')[0],\n      input: $element.find('input')[0],\n      wrap:  $element.find('md-autocomplete-wrap')[0],\n      root:  document.body\n    };\n    elements.li = elements.ul.getElementsByTagName('li');\n    elements.snap = getSnapTarget();\n    elements.$ = getAngularElements(elements);\n  }\n\n  /**\n   * Finds the element that the menu will base its position on\n   * @returns {*}\n   */\n  function getSnapTarget () {\n    for (var element = $element; element.length; element = element.parent()) {\n      if (angular.isDefined(element.attr('md-autocomplete-snap'))) return element[0];\n    }\n    return elements.wrap;\n  }\n\n  /**\n   * Gathers angular-wrapped versions of each element\n   * @param elements\n   * @returns {{}}\n   */\n  function getAngularElements (elements) {\n    var obj = {};\n    for (var key in elements) {\n      obj[key] = angular.element(elements[key]);\n    }\n    return obj;\n  }\n\n  //-- event/change handlers\n\n  /**\n   * Handles changes to the `hidden` property.\n   * @param hidden\n   * @param oldHidden\n   */\n  function handleHiddenChange (hidden, oldHidden) {\n    if (!hidden && oldHidden) positionDropdown();\n    if (!hidden) {\n      if (elements) $timeout(function () { $mdUtil.disableScrollAround(elements.ul); }, 0, false);\n    } else {\n      $mdUtil.enableScrolling();\n    }\n  }\n\n  /**\n   * When the user mouses over the dropdown menu, ignore blur events.\n   */\n  function onListEnter () {\n    noBlur = true;\n  }\n\n  /**\n   * When the user's mouse leaves the menu, blur events may hide the menu again.\n   */\n  function onListLeave () {\n    noBlur = false;\n    if (!hasFocus) ctrl.hidden = true;\n  }\n\n  /**\n   * When the mouse button is released, send focus back to the input field.\n   */\n  function onMouseup () {\n    elements.input.focus();\n  }\n\n  /**\n   * Handles changes to the selected item.\n   * @param selectedItem\n   * @param previousSelectedItem\n   */\n  function selectedItemChange (selectedItem, previousSelectedItem) {\n    if (selectedItem) {\n      $scope.searchText = getDisplayValue(selectedItem);\n    }\n    if ($scope.itemChange && selectedItem !== previousSelectedItem)\n      $scope.itemChange(getItemScope(selectedItem));\n  }\n\n  /**\n   * Calls any external watchers listening for the selected item.  Used in conjunction with\n   * `registerSelectedItemWatcher`.\n   * @param selectedItem\n   * @param previousSelectedItem\n   */\n  function handleSelectedItemChange(selectedItem, previousSelectedItem) {\n    for (var i = 0; i < selectedItemWatchers.length; ++i) {\n      selectedItemWatchers[i](selectedItem, previousSelectedItem);\n    }\n  }\n\n  /**\n   * Register a function to be called when the selected item changes.\n   * @param cb\n   */\n  function registerSelectedItemWatcher(cb) {\n    if (selectedItemWatchers.indexOf(cb) == -1) {\n      selectedItemWatchers.push(cb);\n    }\n  }\n\n  /**\n   * Unregister a function previously registered for selected item changes.\n   * @param cb\n   */\n  function unregisterSelectedItemWatcher(cb) {\n    var i = selectedItemWatchers.indexOf(cb);\n    if (i != -1) {\n      selectedItemWatchers.splice(i, 1);\n    }\n  }\n\n  /**\n   * Handles changes to the searchText property.\n   * @param searchText\n   * @param previousSearchText\n   */\n  function handleSearchText (searchText, previousSearchText) {\n    ctrl.index = getDefaultIndex();\n    //-- do nothing on init\n    if (searchText === previousSearchText) return;\n    //-- clear selected item if search text no longer matches it\n    if (searchText !== getDisplayValue($scope.selectedItem)) $scope.selectedItem = null;\n    else return;\n    //-- trigger change event if available\n    if ($scope.textChange && searchText !== previousSearchText)\n      $scope.textChange(getItemScope($scope.selectedItem));\n    //-- cancel results if search text is not long enough\n    if (!isMinLengthMet()) {\n      ctrl.loading = false;\n      ctrl.matches = [];\n      ctrl.hidden = shouldHide();\n      updateMessages();\n    } else {\n      handleQuery();\n    }\n  }\n\n  /**\n   * Handles input blur event, determines if the dropdown should hide.\n   */\n  function blur () {\n    hasFocus = false;\n    if (!noBlur) ctrl.hidden = true;\n  }\n\n  /**\n   * Handles input focus event, determines if the dropdown should show.\n   */\n  function focus () {\n    hasFocus = true;\n    //-- if searchText is null, let's force it to be a string\n    if (!angular.isString($scope.searchText)) $scope.searchText = '';\n    if ($scope.minLength > 0) return;\n    ctrl.hidden = shouldHide();\n    if (!ctrl.hidden) handleQuery();\n  }\n\n  /**\n   * Handles keyboard input.\n   * @param event\n   */\n  function keydown (event) {\n    switch (event.keyCode) {\n      case $mdConstant.KEY_CODE.DOWN_ARROW:\n        if (ctrl.loading) return;\n        event.preventDefault();\n        ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);\n        updateScroll();\n        updateMessages();\n        break;\n      case $mdConstant.KEY_CODE.UP_ARROW:\n        if (ctrl.loading) return;\n        event.preventDefault();\n        ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);\n        updateScroll();\n        updateMessages();\n        break;\n      case $mdConstant.KEY_CODE.TAB:\n      case $mdConstant.KEY_CODE.ENTER:\n        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;\n        event.preventDefault();\n        select(ctrl.index);\n        break;\n      case $mdConstant.KEY_CODE.ESCAPE:\n        ctrl.matches = [];\n        ctrl.hidden = true;\n        ctrl.index = getDefaultIndex();\n        break;\n      default:\n    }\n  }\n\n  //-- getters\n\n  /**\n   * Returns the minimum length needed to display the dropdown.\n   * @returns {*}\n   */\n  function getMinLength () {\n    return angular.isNumber($scope.minLength) ? $scope.minLength : 1;\n  }\n\n  /**\n   * Returns the display value for an item.\n   * @param item\n   * @returns {*}\n   */\n  function getDisplayValue (item) {\n    return (item && $scope.itemText) ? $scope.itemText(getItemScope(item)) : item;\n  }\n\n  /**\n   * Returns the locals object for compiling item templates.\n   * @param item\n   * @returns {{}}\n   */\n  function getItemScope (item) {\n    if (!item) return;\n    var locals = {};\n    if (ctrl.itemName) locals[ctrl.itemName] = item;\n    return locals;\n  }\n\n  /**\n   * Returns the default index based on whether or not autoselect is enabled.\n   * @returns {number}\n   */\n  function getDefaultIndex () {\n    return $scope.autoselect ? 0 : -1;\n  }\n\n  /**\n   * Determines if the menu should be hidden.\n   * @returns {boolean}\n   */\n  function shouldHide () {\n    if (!isMinLengthMet()) return true;\n  }\n\n  /**\n   * Returns the display value of the current item.\n   * @returns {*}\n   */\n  function getCurrentDisplayValue () {\n    return getDisplayValue(ctrl.matches[ctrl.index]);\n  }\n\n  /**\n   * Determines if the minimum length is met by the search text.\n   * @returns {*}\n   */\n  function isMinLengthMet () {\n    return angular.isDefined($scope.searchText) && $scope.searchText.length >= getMinLength();\n  }\n\n  //-- actions\n\n  /**\n   * Defines a public property with a handler and a default value.\n   * @param key\n   * @param handler\n   * @param value\n   */\n  function defineProperty (key, handler, value) {\n    Object.defineProperty(ctrl, key, {\n      get: function () { return value; },\n      set: function (newValue) {\n        var oldValue = value;\n        value = newValue;\n        handler(newValue, oldValue);\n      }\n    });\n  }\n\n  /**\n   * Selects the item at the given index.\n   * @param index\n   */\n  function select (index) {\n    $scope.selectedItem = ctrl.matches[index];\n    ctrl.hidden = true;\n    ctrl.index = 0;\n    ctrl.matches = [];\n    //-- force form to update state for validation\n    $timeout(function () {\n      elements.$.input.controller('ngModel').$setViewValue(getDisplayValue($scope.selectedItem) ||\n          $scope.searchText);\n      ctrl.hidden = true;\n    });\n  }\n\n  /**\n   * Clears the searchText value and selected item.\n   */\n  function clearValue () {\n    $scope.searchText = '';\n    select(-1);\n\n    // Per http://www.w3schools.com/jsref/event_oninput.asp\n    var eventObj = document.createEvent('CustomEvent');\n    eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});\n    elements.input.dispatchEvent(eventObj);\n\n    elements.input.focus();\n  }\n\n  /**\n   * Fetches the results for the provided search text.\n   * @param searchText\n   */\n  function fetchResults (searchText) {\n    var items = $scope.$parent.$eval(itemExpr),\n        term = searchText.toLowerCase();\n    if (angular.isArray(items)) {\n      handleResults(items);\n    } else if (items) {\n      ctrl.loading = true;\n      if (items.success) items.success(handleResults);\n      if (items.then)    items.then(handleResults);\n      if (items.error)   items.error(function () { ctrl.loading = false; });\n    }\n    function handleResults (matches) {\n      cache[term] = matches;\n      if (searchText !== $scope.searchText) return; //-- just cache the results if old request\n      ctrl.loading = false;\n      promise = null;\n      ctrl.matches = matches;\n      ctrl.hidden = shouldHide();\n      updateMessages();\n      positionDropdown();\n    }\n  }\n\n  /**\n   * Updates the ARIA messages\n   */\n  function updateMessages () {\n    ctrl.messages = [ getCountMessage(), getCurrentDisplayValue() ];\n  }\n\n  /**\n   * Returns the ARIA message for how many results match the current query.\n   * @returns {*}\n   */\n  function getCountMessage () {\n    if (lastCount === ctrl.matches.length) return '';\n    lastCount = ctrl.matches.length;\n    switch (ctrl.matches.length) {\n      case 0:  return 'There are no matches available.';\n      case 1:  return 'There is 1 match available.';\n      default: return 'There are ' + ctrl.matches.length + ' matches available.';\n    }\n  }\n\n  /**\n   * Makes sure that the focused element is within view.\n   */\n  function updateScroll () {\n    if (!elements.li[ctrl.index]) return;\n    var li  = elements.li[ctrl.index],\n        top = li.offsetTop,\n        bot = top + li.offsetHeight,\n        hgt = elements.ul.clientHeight;\n    if (top < elements.ul.scrollTop) {\n      elements.ul.scrollTop = top;\n    } else if (bot > elements.ul.scrollTop + hgt) {\n      elements.ul.scrollTop = bot - hgt;\n    }\n  }\n\n  /**\n   * Starts the query to gather the results for the current searchText.  Attempts to return cached\n   * results first, then forwards the process to `fetchResults` if necessary.\n   */\n  function handleQuery () {\n    var searchText = $scope.searchText,\n        term = searchText.toLowerCase();\n    //-- cancel promise if a promise is in progress\n    if (promise && promise.cancel) {\n      promise.cancel();\n      promise = null;\n    }\n    //-- if results are cached, pull in cached results\n    if (!$scope.noCache && cache[term]) {\n      ctrl.matches = cache[term];\n      updateMessages();\n    } else {\n      fetchResults(searchText);\n    }\n    if (hasFocus) ctrl.hidden = shouldHide();\n  }\n\n}\nMdAutocompleteCtrl.$inject = [\"$scope\", \"$element\", \"$mdUtil\", \"$mdConstant\", \"$timeout\", \"$mdTheming\", \"$window\", \"$animate\", \"$rootElement\", \"$attrs\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocomplete', MdAutocomplete);\n\n/**\n * @ngdoc directive\n * @name mdAutocomplete\n * @module material.components.autocomplete\n *\n * @description\n * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a custom query.\n * This component allows you to provide real-time suggestions as the user types in the input area.\n *\n * To start, you will need to specify the required parameters and provide a template for your results.\n * The content inside `md-autocomplete` will be treated as a template.\n *\n * In more complex cases, you may want to include other content such as a message to display when\n * no matches were found.  You can do this by wrapping your template in `md-item-template` and adding\n * a tag for `md-not-found`.  An example of this is shown below.\n * ### Validation\n *\n * You can use `ng-messages` to include validation the same way that you would normally validate;\n * however, if you want to replicate a standard input with a floating label, you will have to do the\n * following:\n *\n * - Make sure that your template is wrapped in `md-item-template`\n * - Add your `ng-messages` code inside of `md-autocomplete`\n * - Add your validation properties to `md-autocomplete` (ie. `required`)\n * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)\n *\n * There is an example below of how this should look.\n *\n *\n * @param {expression} md-items An expression in the format of `item in items` to iterate over matches for your search.\n * @param {expression=} md-selected-item-change An expression to be run each time a new item is selected\n * @param {expression=} md-search-text-change An expression to be run each time the search text updates\n * @param {string=} md-search-text A model to bind the search query text to\n * @param {object=} md-selected-item A model to bind the selected item to\n * @param {string=} md-item-text An expression that will convert your object to a single string.\n * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete\n * @param {boolean=} ng-disabled Determines whether or not to disable the input field\n * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will make suggestions\n * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking for results\n * @param {boolean=} md-autofocus If true, will immediately focus the input element\n * @param {boolean=} md-autoselect If true, the first item will be selected by default\n * @param {string=} md-menu-class This will be applied to the dropdown menu for styling\n * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in `md-input-container`\n *\n * @usage\n * ###Basic Example\n * <hljs lang=\"html\">\n *   <md-autocomplete\n *       md-selected-item=\"selectedItem\"\n *       md-search-text=\"searchText\"\n *       md-items=\"item in getMatches(searchText)\"\n *       md-item-text=\"item.display\">\n *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *   </md-autocomplete>\n * </hljs>\n *\n * ###Example with \"not found\" message\n * <hljs lang=\"html\">\n * <md-autocomplete\n *     md-selected-item=\"selectedItem\"\n *     md-search-text=\"searchText\"\n *     md-items=\"item in getMatches(searchText)\"\n *     md-item-text=\"item.display\">\n *   <md-item-template>\n *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *   </md-item-template>\n *   <md-not-found>\n *     No matches found.\n *   </md-not-found>\n * </md-autocomplete>\n * </hljs>\n *\n * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n * parts that make up our component.\n *\n * ### Example with validation\n * <hljs lang=\"html\">\n * <form name=\"autocompleteForm\">\n *   <md-autocomplete\n *       required\n *       input-name=\"autocomplete\"\n *       md-selected-item=\"selectedItem\"\n *       md-search-text=\"searchText\"\n *       md-items=\"item in getMatches(searchText)\"\n *       md-item-text=\"item.display\">\n *     <md-item-template>\n *       <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *     </md-item-template>\n *     <div ng-messages=\"autocompleteForm.autocomplete.$error\">\n *       <div ng-message=\"required\">This field is required</div>\n *     </div>\n *   </md-autocomplete>\n * </form>\n * </hljs>\n *\n * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n * parts that make up our component.\n */\n\nfunction MdAutocomplete ($mdTheming, $mdUtil) {\n  return {\n    controller:   'MdAutocompleteCtrl',\n    controllerAs: '$mdAutocompleteCtrl',\n    scope:        {\n      inputName:      '@mdInputName',\n      inputMinlength: '@mdInputMinlength',\n      inputMaxlength: '@mdInputMaxlength',\n      searchText:     '=?mdSearchText',\n      selectedItem:   '=?mdSelectedItem',\n      itemsExpr:      '@mdItems',\n      itemText:       '&mdItemText',\n      placeholder:    '@placeholder',\n      noCache:        '=?mdNoCache',\n      itemChange:     '&?mdSelectedItemChange',\n      textChange:     '&?mdSearchTextChange',\n      minLength:      '=?mdMinLength',\n      delay:          '=?mdDelay',\n      autofocus:      '=?mdAutofocus',\n      floatingLabel:  '@?mdFloatingLabel',\n      autoselect:     '=?mdAutoselect',\n      menuClass:      '@?mdMenuClass'\n    },\n    template: function (element, attr) {\n      var noItemsTemplate = getNoItemsTemplate(),\n          itemTemplate = getItemTemplate(),\n          leftover = element.html();\n      return '\\\n        <md-autocomplete-wrap\\\n            layout=\"row\"\\\n            ng-class=\"{ \\'md-whiteframe-z1\\': !floatingLabel }\"\\\n            role=\"listbox\">\\\n          ' + getInputElement() + '\\\n          <md-progress-linear\\\n              ng-if=\"$mdAutocompleteCtrl.loading\"\\\n              md-mode=\"indeterminate\"></md-progress-linear>\\\n          <ul role=\"presentation\"\\\n              class=\"md-autocomplete-suggestions md-whiteframe-z1 {{menuClass || \\'\\'}}\"\\\n              id=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n              ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n              ng-mouseenter=\"$mdAutocompleteCtrl.listEnter()\"\\\n              ng-mouseleave=\"$mdAutocompleteCtrl.listLeave()\"\\\n              ng-mouseup=\"$mdAutocompleteCtrl.mouseUp()\">\\\n            <li ng-repeat=\"(index, item) in $mdAutocompleteCtrl.matches\"\\\n                ng-class=\"{ selected: index === $mdAutocompleteCtrl.index }\"\\\n                ng-click=\"$mdAutocompleteCtrl.select(index)\"\\\n                md-autocomplete-list-item=\"$mdAutocompleteCtrl.itemName\">\\\n                ' + itemTemplate + '\\\n            </li>\\\n            ' + noItemsTemplate + '\\\n          </ul>\\\n        </md-autocomplete-wrap>\\\n        <aria-status\\\n            class=\"md-visually-hidden\"\\\n            role=\"status\"\\\n            aria-live=\"assertive\">\\\n          <p ng-repeat=\"message in $mdAutocompleteCtrl.messages\" ng-if=\"message\">{{message}}</p>\\\n        </aria-status>';\n\n      function getItemTemplate() {\n        var templateTag = element.find('md-item-template').remove(),\n            html = templateTag.length ? templateTag.html() : element.html();\n        if (!templateTag.length) element.empty();\n        return html;\n      }\n\n      function getNoItemsTemplate() {\n        var templateTag = element.find('md-not-found').remove(),\n            template = templateTag.length ? templateTag.html() : '';\n        return template\n            ? '<li ng-if=\"!$mdAutocompleteCtrl.matches.length && !$mdAutocompleteCtrl.loading\\\n                         && !$mdAutocompleteCtrl.hidden\"\\\n                         ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n                         md-autocomplete-parent-scope>' + template + '</li>'\n            : '';\n\n      }\n\n      function getInputElement() {\n        if (attr.mdFloatingLabel) {\n          return '\\\n            <md-input-container flex ng-if=\"floatingLabel\">\\\n              <label>{{floatingLabel}}</label>\\\n              <input type=\"search\"\\\n                  id=\"fl-input-{{$mdAutocompleteCtrl.id}}\"\\\n                  name=\"{{inputName}}\"\\\n                  autocomplete=\"off\"\\\n                  ng-required=\"isRequired\"\\\n                  ng-minlength=\"inputMinlength\"\\\n                  ng-maxlength=\"inputMaxlength\"\\\n                  ng-disabled=\"$mdAutocompleteCtrl.isDisabled\"\\\n                  ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n                  ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n                  ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n                  ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n                  aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n                  aria-label=\"{{floatingLabel}}\"\\\n                  aria-autocomplete=\"list\"\\\n                  aria-haspopup=\"true\"\\\n                  aria-activedescendant=\"\"\\\n                  aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>\\\n              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\\\n            </md-input-container>';\n        } else {\n          return '\\\n            <input flex type=\"search\"\\\n                id=\"input-{{$mdAutocompleteCtrl.id}}\"\\\n                name=\"{{inputName}}\"\\\n                ng-if=\"!floatingLabel\"\\\n                autocomplete=\"off\"\\\n                ng-required=\"isRequired\"\\\n                ng-disabled=\"$mdAutocompleteCtrl.isDisabled\"\\\n                ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n                ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n                ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n                ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n                placeholder=\"{{placeholder}}\"\\\n                aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n                aria-label=\"{{placeholder}}\"\\\n                aria-autocomplete=\"list\"\\\n                aria-haspopup=\"true\"\\\n                aria-activedescendant=\"\"\\\n                aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>\\\n            <button\\\n                type=\"button\"\\\n                tabindex=\"-1\"\\\n                ng-if=\"$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled\"\\\n                ng-click=\"$mdAutocompleteCtrl.clear()\">\\\n              <md-icon md-svg-icon=\"md-close\"></md-icon>\\\n              <span class=\"md-visually-hidden\">Clear</span>\\\n            </button>\\\n                ';\n        }\n      }\n    }\n  };\n}\nMdAutocomplete.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .controller('MdHighlightCtrl', MdHighlightCtrl);\n\nfunction MdHighlightCtrl ($scope, $element, $interpolate) {\n  this.init = init;\n\n  return init();\n\n  function init (term) {\n    var unsafeText = $interpolate($element.html())($scope),\n        text = angular.element('<div>').text(unsafeText).html(),\n        flags = $element.attr('md-highlight-flags') || '',\n        watcher = $scope.$watch(term, function (term) {\n          var regex = getRegExp(term, flags),\n              html = text.replace(regex, '<span class=\"highlight\">$&</span>');\n          $element.html(html);\n        });\n    $element.on('$destroy', function () { watcher(); });\n  }\n\n  function sanitize (term) {\n    if (!term) return term;\n    return term.replace(/[\\\\\\^\\$\\*\\+\\?\\.\\(\\)\\|\\{\\}\\[\\]]/g, '\\\\$&');\n  }\n\n  function getRegExp (text, flags) {\n    var str = '';\n    if (flags.indexOf('^') >= 1) str += '^';\n    str += text;\n    if (flags.indexOf('$') >= 1) str += '$';\n    return new RegExp(sanitize(str), flags.replace(/[\\$\\^]/g, ''));\n  }\n}\nMdHighlightCtrl.$inject = [\"$scope\", \"$element\", \"$interpolate\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdHighlightText', MdHighlight);\n\n/**\n * @ngdoc directive\n * @name mdHighlightText\n * @module material.components.autocomplete\n *\n * @description\n * The `md-highlight-text` directive allows you to specify text that should be highlighted within\n * an element.  Highlighted text will be wrapped in `<span class=\"highlight\"></span>` which can\n * be styled through CSS.  Please note that child elements may not be used with this directive.\n *\n * @param {string} md-highlight-text A model to be searched for\n * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).\n *    #### **Supported flags**:\n *    - `g`: Find all matches within the provided text\n *    - `i`: Ignore case when searching for matches\n *    - `$`: Only match if the text ends with the search term\n *    - `^`: Only match if the text begins with the search term\n *\n * @usage\n * <hljs lang=\"html\">\n * <input placeholder=\"Enter a search term...\" ng-model=\"searchTerm\" type=\"text\" />\n * <ul>\n *   <li ng-repeat=\"result in results\" md-highlight-text=\"searchTerm\">\n *     {{result.text}}\n *   </li>\n * </ul>\n * </hljs>\n */\n\nfunction MdHighlight () {\n  return {\n    terminal: true,\n    scope: false,\n    controller: 'MdHighlightCtrl',\n    link: function (scope, element, attr, ctrl) {\n      ctrl.init(attr.mdHighlightText);\n    }\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocompleteListItem', MdAutocompleteListItem);\n\nfunction MdAutocompleteListItem ($compile, $mdUtil) {\n  return {\n    terminal: true,\n    link: postLink,\n    scope: false\n  };\n  function postLink (scope, element, attr) {\n    var ctrl     = scope.$parent.$mdAutocompleteCtrl,\n        newScope = ctrl.parent.$new(false, ctrl.parent),\n        itemName = ctrl.scope.$eval(attr.mdAutocompleteListItem);\n    newScope[itemName] = scope.item;\n    $compile(element.contents())(newScope);\n    element.attr({\n      role: 'option',\n      id: 'item_' + $mdUtil.nextUid()\n    });\n  }\n}\nMdAutocompleteListItem.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocompleteParentScope', MdAutocompleteParentScope);\n\nfunction MdAutocompleteParentScope ($compile, $mdUtil) {\n  return {\n    restrict: 'A',\n    terminal: true,\n    link: postLink,\n    scope: false\n  };\n  function postLink (scope, element, attr) {\n    var ctrl     = scope.$parent.$mdAutocompleteCtrl;\n    $compile(element.contents())(ctrl.parent);\n    if (attr.hasOwnProperty('mdAutocompleteReplace')) {\n      element.after(element.contents());\n      element.remove();\n    }\n  }\n}\nMdAutocompleteParentScope.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChip', MdChip);\n\n/**\n * @ngdoc directive\n * @name mdChip\n * @module material.components.chips\n *\n * @description\n * `<md-chip>` is a component used within `<md-chips>` and is responsible for rendering individual\n * chips.\n *\n *\n * @usage\n * <hljs lang=\"html\">\n *   <md-chip>{{$chip}}</md-chip>\n * </hljs>\n *\n */\n\n// This hint text is hidden within a chip but used by screen readers to\n// inform the user how they can interact with a chip.\nvar DELETE_HINT_TEMPLATE = '\\\n    <span ng-if=\"!$mdChipsCtrl.readonly\" class=\"md-visually-hidden\">\\\n      {{$mdChipsCtrl.deleteHint}}\\\n    </span>';\n\n/**\n * MDChip Directive Definition\n *\n * @param $mdTheming\n * @param $mdInkRipple\n * @ngInject\n */\nfunction MdChip($mdTheming) {\n  return {\n    restrict: 'E',\n    require: '^?mdChips',\n    compile:  compile\n  };\n\n  function compile(element, attr) {\n    element.append(DELETE_HINT_TEMPLATE);\n    return function postLink(scope, element, attr, ctrl) {\n      element.addClass('md-chip');\n      $mdTheming(element);\n\n      if (ctrl) angular.element(element[0].querySelector('.md-chip-content'))\n          .on('blur', function () {\n            ctrl.selectedChip = -1;\n          });\n    };\n  }\n}\nMdChip.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChipRemove', MdChipRemove);\n\n/**\n * @ngdoc directive\n * @name mdChipRemove\n * @module material.components.chips\n *\n * @description\n * `<md-chip-remove>`\n * Designates an element to be used as the delete button for a chip. This\n * element is passed as a child of the `md-chips` element.\n *\n * @usage\n * <hljs lang=\"html\">\n *   <md-chips><button md-chip-remove>DEL</button></md-chips>\n * </hljs>\n */\n\n\n/**\n * MdChipRemove Directive Definition.\n * \n * @param $compile\n * @param $timeout\n * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}\n * @constructor\n */\nfunction MdChipRemove ($timeout) {\n  return {\n    restrict: 'A',\n    require: '^mdChips',\n    scope: false,\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrl) {\n    element.on('click', function(event) {\n      scope.$apply(function() {\n        ctrl.removeChip(scope.$$replacedScope.$index);\n      });\n    });\n\n    // Child elements aren't available until after a $timeout tick as they are hidden by an\n    // `ng-if`. see http://goo.gl/zIWfuw\n    $timeout(function() {\n      element.attr({ tabindex: -1, ariaHidden: true });\n      element.find('button').attr('tabindex', '-1');\n    });\n  }\n}\nMdChipRemove.$inject = [\"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChipTransclude', MdChipTransclude);\n\nfunction MdChipTransclude ($compile, $mdUtil) {\n  return {\n    restrict: 'EA',\n    terminal: true,\n    link: link,\n    scope: false\n  };\n  function link (scope, element, attr) {\n    var ctrl = scope.$parent.$mdChipsCtrl,\n        newScope = ctrl.parent.$new(false, ctrl.parent);\n    newScope.$$replacedScope = scope;\n    newScope.$chip = scope.$chip;\n    newScope.$mdChipsCtrl = ctrl;\n    element.html(ctrl.$scope.$eval(attr.mdChipTransclude));\n    $compile(element.contents())(newScope);\n  }\n}\nMdChipTransclude.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .controller('MdChipsCtrl', MdChipsCtrl);\n\n/**\n * Controller for the MdChips component. Responsible for adding to and\n * removing from the list of chips, marking chips as selected, and binding to\n * the models of various input components.\n *\n * @param $scope\n * @param $mdConstant\n * @param $log\n * @param $element\n * @constructor\n */\nfunction MdChipsCtrl ($scope, $mdConstant, $log, $element, $timeout) {\n  /** @type {$timeout} **/\n  this.$timeout = $timeout;\n\n  /** @type {Object} */\n  this.$mdConstant = $mdConstant;\n\n  /** @type {angular.$scope} */\n  this.$scope = $scope;\n\n  /** @type {angular.$scope} */\n  this.parent = $scope.$parent;\n\n  /** @type {$log} */\n  this.$log = $log;\n\n  /** @type {$element} */\n  this.$element = $element;\n\n  /** @type {angular.NgModelController} */\n  this.ngModelCtrl = null;\n\n  /** @type {angular.NgModelController} */\n  this.userInputNgModelCtrl = null;\n\n  /** @type {Element} */\n  this.userInputElement = null;\n\n  /** @type {Array.<Object>} */\n  this.items = [];\n\n  /** @type {number} */\n  this.selectedChip = -1;\n\n\n  /**\n   * Hidden hint text for how to delete a chip. Used to give context to screen readers.\n   * @type {string}\n   */\n  this.deleteHint = 'Press delete to remove this chip.';\n\n  /**\n   * Hidden label for the delete button. Used to give context to screen readers.\n   * @type {string}\n   */\n  this.deleteButtonLabel = 'Remove';\n\n  /**\n   * Model used by the input element.\n   * @type {string}\n   */\n  this.chipBuffer = '';\n\n  /**\n   * Whether to use the mdOnAppend expression to transform the chip buffer\n   * before appending it to the list.\n   * @type {boolean}\n   */\n  this.useMdOnAppend = false;\n}\nMdChipsCtrl.$inject = [\"$scope\", \"$mdConstant\", \"$log\", \"$element\", \"$timeout\"];\n\n/**\n * Handles the keydown event on the input element: <enter> appends the\n * buffer to the chip list, while backspace removes the last chip in the list\n * if the current buffer is empty.\n * @param event\n */\nMdChipsCtrl.prototype.inputKeydown = function(event) {\n  var chipBuffer = this.getChipBuffer();\n  switch (event.keyCode) {\n    case this.$mdConstant.KEY_CODE.ENTER:\n      if (this.$scope.requireMatch || !chipBuffer) break;\n      event.preventDefault();\n      this.appendChip(chipBuffer);\n      this.resetChipBuffer();\n      break;\n    case this.$mdConstant.KEY_CODE.BACKSPACE:\n      if (chipBuffer) break;\n      event.stopPropagation();\n      if (this.items.length) this.selectAndFocusChipSafe(this.items.length - 1);\n      break;\n  }\n};\n\n/**\n * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow\n * keys switch which chips is active\n * @param event\n */\nMdChipsCtrl.prototype.chipKeydown = function (event) {\n  if (this.getChipBuffer()) return;\n  switch (event.keyCode) {\n    case this.$mdConstant.KEY_CODE.BACKSPACE:\n    case this.$mdConstant.KEY_CODE.DELETE:\n      if (this.selectedChip < 0) return;\n      event.preventDefault();\n      this.removeAndSelectAdjacentChip(this.selectedChip);\n      break;\n    case this.$mdConstant.KEY_CODE.LEFT_ARROW:\n      event.preventDefault();\n      if (this.selectedChip < 0) this.selectedChip = this.items.length;\n      if (this.items.length) this.selectAndFocusChipSafe(this.selectedChip - 1);\n      break;\n    case this.$mdConstant.KEY_CODE.RIGHT_ARROW:\n      event.preventDefault();\n      this.selectAndFocusChipSafe(this.selectedChip + 1);\n      break;\n    case this.$mdConstant.KEY_CODE.ESCAPE:\n    case this.$mdConstant.KEY_CODE.TAB:\n      if (this.selectedChip < 0) return;\n      event.preventDefault();\n      this.onFocus();\n      break;\n  }\n};\n\n/**\n * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`\n * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used\n * always.\n */\nMdChipsCtrl.prototype.getPlaceholder = function() {\n  // Allow `secondary-placeholder` to be blank.\n  var useSecondary = (this.items.length &&\n      (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));\n  return useSecondary ? this.placeholder : this.secondaryPlaceholder;\n};\n\n/**\n * Removes chip at {@code index} and selects the adjacent chip.\n * @param index\n */\nMdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {\n  var selIndex = this.getAdjacentChipIndex(index);\n  this.removeChip(index);\n  this.$timeout(angular.bind(this, function () {\n      this.selectAndFocusChipSafe(selIndex);\n  }));\n};\n\n/**\n * Sets the selected chip index to -1.\n */\nMdChipsCtrl.prototype.resetSelectedChip = function() {\n  this.selectedChip = -1;\n};\n\n/**\n * Gets the index of an adjacent chip to select after deletion. Adjacency is\n * determined as the next chip in the list, unless the target chip is the\n * last in the list, then it is the chip immediately preceding the target. If\n * there is only one item in the list, -1 is returned (select none).\n * The number returned is the index to select AFTER the target has been\n * removed.\n * If the current chip is not selected, then -1 is returned to select none.\n */\nMdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {\n  var len = this.items.length - 1;\n  return (len == 0) ? -1 :\n      (index == len) ? index -1 : index;\n};\n\n/**\n * Append the contents of the buffer to the chip list. This method will first\n * call out to the md-on-append method, if provided\n * @param newChip\n */\nMdChipsCtrl.prototype.appendChip = function(newChip) {\n  if (this.items.indexOf(newChip) + 1) return;\n  if (this.useMdOnAppend && this.mdOnAppend) {\n    newChip = this.mdOnAppend({'$chip': newChip});\n  }\n  this.items.push(newChip);\n};\n\n/**\n * Sets whether to use the md-on-append expression. This expression is\n * bound to scope and controller in {@code MdChipsDirective} as\n * {@code mdOnAppend}. Due to the nature of directive scope bindings, the\n * controller cannot know on its own/from the scope whether an expression was\n * actually provided.\n */\nMdChipsCtrl.prototype.useMdOnAppendExpression = function() {\n  this.useMdOnAppend = true;\n};\n\n/**\n * Gets the input buffer. The input buffer can be the model bound to the\n * default input item {@code this.chipBuffer}, the {@code selectedItem}\n * model of an {@code md-autocomplete}, or, through some magic, the model\n * bound to any inpput or text area element found within a\n * {@code md-input-container} element.\n * @return {Object|string}\n */\nMdChipsCtrl.prototype.getChipBuffer = function() {\n  return !this.userInputElement ? this.chipBuffer :\n      this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue :\n          this.userInputElement[0].value;\n};\n\n/**\n * Resets the input buffer for either the internal input or user provided input element.\n */\nMdChipsCtrl.prototype.resetChipBuffer = function() {\n  if (this.userInputElement) {\n    if (this.userInputNgModelCtrl) {\n      this.userInputNgModelCtrl.$setViewValue('');\n      this.userInputNgModelCtrl.$render();\n    } else {\n      this.userInputElement[0].value = '';\n    }\n  } else {\n    this.chipBuffer = '';\n  }\n};\n\n/**\n * Removes the chip at the given index.\n * @param index\n */\nMdChipsCtrl.prototype.removeChip = function(index) {\n  this.items.splice(index, 1);\n};\n\nMdChipsCtrl.prototype.removeChipAndFocusInput = function (index) {\n  this.removeChip(index);\n  this.onFocus();\n};\n/**\n * Selects the chip at `index`,\n * @param index\n */\nMdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {\n  if (!this.items.length) {\n    this.selectChip(-1);\n    this.onFocus();\n    return;\n  }\n  if (index === this.items.length) return this.onFocus();\n  index = Math.max(index, 0);\n  index = Math.min(index, this.items.length - 1);\n  this.selectChip(index);\n  this.focusChip(index);\n};\n\n/**\n * Marks the chip at the given index as selected.\n * @param index\n */\nMdChipsCtrl.prototype.selectChip = function(index) {\n  if (index >= -1 && index <= this.items.length) {\n    this.selectedChip = index;\n  } else {\n    this.$log.warn('Selected Chip index out of bounds; ignoring.');\n  }\n};\n\n/**\n * Selects the chip at `index` and gives it focus.\n * @param index\n */\nMdChipsCtrl.prototype.selectAndFocusChip = function(index) {\n  this.selectChip(index);\n  if (index != -1) {\n    this.focusChip(index);\n  }\n};\n\n/**\n * Call `focus()` on the chip at `index`\n */\nMdChipsCtrl.prototype.focusChip = function(index) {\n  this.$element[0].querySelector('md-chip[index=\"' + index + '\"] .md-chip-content').focus();\n};\n\n/**\n * Configures the required interactions with the ngModel Controller.\n * Specifically, set {@code this.items} to the {@code NgModelCtrl#$viewVale}.\n * @param ngModelCtrl\n */\nMdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {\n  this.ngModelCtrl = ngModelCtrl;\n\n  var self = this;\n  ngModelCtrl.$render = function() {\n    // model is updated. do something.\n    self.items = self.ngModelCtrl.$viewValue;\n  };\n};\n\nMdChipsCtrl.prototype.onFocus = function () {\n  var input = this.$element[0].querySelector('input');\n  input && input.focus();\n  this.resetSelectedChip();\n};\n\nMdChipsCtrl.prototype.onInputFocus = function () {\n  this.inputHasFocus = true;\n  this.resetSelectedChip();\n};\n\nMdChipsCtrl.prototype.onInputBlur = function () {\n  this.inputHasFocus = false;\n};\n\n/**\n * Configure event bindings on a user-provided input element.\n * @param inputElement\n */\nMdChipsCtrl.prototype.configureUserInput = function(inputElement) {\n  this.userInputElement = inputElement;\n\n  // Find the NgModelCtrl for the input element\n  var ngModelCtrl = inputElement.controller('ngModel');\n  // `.controller` will look in the parent as well.\n  if (ngModelCtrl != this.ngModelCtrl) {\n    this.userInputNgModelCtrl = ngModelCtrl;\n  }\n\n  // Bind to keydown and focus events of input\n  var scope = this.$scope;\n  var ctrl = this;\n  inputElement\n      .attr({ tabindex: 0 })\n      .on('keydown', function(event) { scope.$apply( angular.bind(ctrl, function() { ctrl.inputKeydown(event); })) })\n      .on('focus', angular.bind(ctrl, ctrl.onInputFocus))\n      .on('blur', angular.bind(ctrl, ctrl.onInputBlur));\n};\n\nMdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {\n\n  ctrl.registerSelectedItemWatcher(angular.bind(this, function (item) {\n    if (item) {\n      this.appendChip(item);\n      this.resetChipBuffer();\n    }\n  }));\n\n  this.$element.find('input')\n      .on('focus',angular.bind(this, this.onInputFocus) )\n      .on('blur', angular.bind(this, this.onInputBlur) );\n};\n\nMdChipsCtrl.prototype.hasFocus = function () {\n  return this.inputHasFocus || this.selectedChip >= 0;\n};\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n      .module('material.components.chips')\n      .directive('mdChips', MdChips);\n\n  /**\n   * @ngdoc directive\n   * @name mdChips\n   * @module material.components.chips\n   *\n   * @description\n   * `<md-chips>` is an input component for building lists of strings or objects. The list items are\n   * displayed as 'chips'. This component can make use of an `<input>` element or an\n   * `<md-autocomplete>` element.\n   *\n   * <strong>Custom `<md-chip-template>` template</strong>\n   * A custom template may be provided to render the content of each chip. This is achieved by\n   * specifying an `<md-chip-template>` element as a child of `<md-chips>`. Note: Any attributes on\n   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The\n   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing\n   * the chip object and its index in the list of chips, respectively.\n   * To override the chip delete control, include an element (ideally a button) with the attribute\n   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element\n   * is also placed as a sibling to the chip content (on which there are also click listeners) to\n   * avoid a nested ng-click situation.\n   *\n   * <h3> Pending Features </h3>\n   * <ul style=\"padding-left:20px;\">\n   *\n   *   <ul>Style\n   *     <li>Colours for hover, press states (ripple?).</li>\n   *   </ul>\n   *\n   *   <ul>List Manipulation\n   *     <li>delete item via DEL or backspace keys when selected</li>\n   *   </ul>\n   *\n   *   <ul>Validation\n   *     <li>de-dupe values (or support duplicates, but fix the ng-repeat duplicate key issue)</li>\n   *     <li>allow a validation callback</li>\n   *     <li>hilighting style for invalid chips</li>\n   *   </ul>\n   *\n   *   <ul>Item mutation\n   *     <li>Support `\n   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double\n   *       click?\n   *     </li>\n   *   </ul>\n   *\n   *   <ul>Truncation and Disambiguation (?)\n   *     <li>Truncate chip text where possible, but do not truncate entries such that two are\n   *     indistinguishable.</li>\n   *   </ul>\n   *\n   *   <ul>Drag and Drop\n   *     <li>Drag and drop chips between related `<md-chips>` elements.\n   *     </li>\n   *   </ul>\n   * </ul>\n   *\n   *  <span style=\"font-size:.8em;text-align:center\">\n   *    Warning: This component is a WORK IN PROGRESS. If you use it now,\n   *    it will probably break on you in the future.\n   *  </span>\n   *\n   * @param {string=|object=} ng-model A model to bind the list of items to\n   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n   *    displayed when there is at least on item in the list\n   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding\n   *    the input and delete buttons\n   * @param {expression} md-on-append An expression expected to convert the input string into an\n   *    object when adding a chip.\n   * @param {string=} delete-hint A string read by screen readers instructing users that pressing\n   *    the delete key will remove the chip.\n   * @param {string=} delete-button-label A label for the delete button. Also hidden and read by\n   *    screen readers.\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   *   <md-chips\n   *       ng-model=\"myItems\"\n   *       placeholder=\"Add an item\"\n   *       readonly=\"isReadOnly\">\n   *   </md-chips>\n   * </hljs>\n   *\n   */\n\n\n  var MD_CHIPS_TEMPLATE = '\\\n      <md-chips-wrap\\\n          ng-if=\"!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0\"\\\n          ng-keydown=\"$mdChipsCtrl.chipKeydown($event)\"\\\n          ng-class=\"{ \\'md-focused\\': $mdChipsCtrl.hasFocus() }\"\\\n          class=\"md-chips\">\\\n        <md-chip ng-repeat=\"$chip in $mdChipsCtrl.items\"\\\n            index=\"{{$index}}\"\\\n            ng-class=\"{\\'md-focused\\': $mdChipsCtrl.selectedChip == $index}\">\\\n          <div class=\"md-chip-content\"\\\n              tabindex=\"-1\"\\\n              aria-hidden=\"true\"\\\n              ng-focus=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)\"\\\n              md-chip-transclude=\"$mdChipsCtrl.chipContentsTemplate\"></div>\\\n          <div class=\"md-chip-remove-container\"\\\n              md-chip-transclude=\"$mdChipsCtrl.chipRemoveTemplate\"></div>\\\n        </md-chip>\\\n        <div ng-if=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl\"\\\n            class=\"md-chip-input-container\"\\\n            md-chip-transclude=\"$mdChipsCtrl.chipInputTemplate\"></div>\\\n        </div>\\\n      </md-chips-wrap>';\n\n  var CHIP_INPUT_TEMPLATE = '\\\n        <input\\\n            tabindex=\"0\"\\\n            placeholder=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n            aria-label=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n            ng-model=\"$mdChipsCtrl.chipBuffer\"\\\n            ng-focus=\"$mdChipsCtrl.onInputFocus()\"\\\n            ng-blur=\"$mdChipsCtrl.onInputBlur()\"\\\n            ng-keydown=\"$mdChipsCtrl.inputKeydown($event)\">';\n\n  var CHIP_DEFAULT_TEMPLATE = '\\\n      <span>{{$chip}}</span>';\n\n  var CHIP_REMOVE_TEMPLATE = '\\\n      <button\\\n          class=\"md-chip-remove\"\\\n          ng-if=\"!$mdChipsCtrl.readonly\"\\\n          ng-click=\"$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)\"\\\n          type=\"button\"\\\n          aria-hidden=\"true\"\\\n          tabindex=\"-1\">\\\n        <md-icon md-svg-icon=\"md-close\"></md-icon>\\\n        <span class=\"md-visually-hidden\">\\\n          {{$mdChipsCtrl.deleteButtonLabel}}\\\n        </span>\\\n      </button>';\n\n  /**\n   * MDChips Directive Definition\n   */\n  function MdChips ($mdTheming, $mdUtil, $compile, $log, $timeout) {\n    return {\n      template: function(element, attrs) {\n        // Clone the element into an attribute. By prepending the attribute\n        // name with '$', Angular won't write it into the DOM. The cloned\n        // element propagates to the link function via the attrs argument,\n        // where various contained-elements can be consumed.\n        var content = attrs['$mdUserTemplate'] = element.clone();\n        return MD_CHIPS_TEMPLATE;\n      },\n      require: ['mdChips'],\n      restrict: 'E',\n      controller: 'MdChipsCtrl',\n      controllerAs: '$mdChipsCtrl',\n      bindToController: true,\n      compile: compile,\n      scope: {\n        readonly: '=readonly',\n        placeholder: '@',\n        secondaryPlaceholder: '@',\n        mdOnAppend: '&',\n        deleteHint: '@',\n        deleteButtonLabel: '@',\n        requireMatch: '=?mdRequireMatch'\n      }\n    };\n\n    /**\n     * Builds the final template for `md-chips` and returns the postLink function.\n     *\n     * Building the template involves 3 key components:\n     * static chips\n     * chip template\n     * input control\n     *\n     * If no `ng-model` is provided, only the static chip work needs to be done.\n     *\n     * If no user-passed `md-chip-template` exists, the default template is used. This resulting\n     * template is appended to the chip content element.\n     *\n     * The remove button may be overridden by passing an element with an md-chip-remove attribute.\n     *\n     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for\n     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.\n     * If no user input is provided, a default one is appended to the input container node in the\n     * template.\n     *\n     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for\n     * transclusion in the `postLink` function.\n     *\n     *\n     * @param element\n     * @param attr\n     * @returns {Function}\n     */\n    function compile(element, attr) {\n      // Grab the user template from attr and reset the attribute to null.\n      var userTemplate = attr['$mdUserTemplate'];\n      attr['$mdUserTemplate'] = null;\n\n      // Set the chip remove, chip contents and chip input templates. The link function will put\n      // them on the scope for transclusion later.\n      var chipRemoveTemplate   = getTemplateByQuery('md-chips>*[md-chip-remove]') || CHIP_REMOVE_TEMPLATE,\n          chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || CHIP_DEFAULT_TEMPLATE,\n          chipInputTemplate    = getTemplateByQuery('md-chips>md-autocomplete')\n              || getTemplateByQuery('md-chips>input')\n              || CHIP_INPUT_TEMPLATE,\n          staticChips = userTemplate.find('md-chip');\n\n      // Warn of malformed template. See #2545\n      if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {\n        $log.warn('invalid placement of md-chip-remove within md-chip-template.');\n      }\n\n      function getTemplateByQuery (query) {\n        if (!attr.ngModel) return;\n        var element = userTemplate[0].querySelector(query);\n        return element && element.outerHTML;\n      }\n\n      /**\n       * Configures controller and transcludes.\n       */\n      return function postLink(scope, element, attrs, controllers) {\n\n        $mdUtil.initOptionalProperties(scope, attr);\n\n        $mdTheming(element);\n        var mdChipsCtrl = controllers[0];\n        mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;\n        mdChipsCtrl.chipRemoveTemplate   = chipRemoveTemplate;\n        mdChipsCtrl.chipInputTemplate    = chipInputTemplate;\n\n        element\n            .attr({ ariaHidden: true, tabindex: -1 })\n            .on('focus', function () { mdChipsCtrl.onFocus(); });\n\n        if (attr.ngModel) {\n          mdChipsCtrl.configureNgModel(element.controller('ngModel'));\n\n          // If an `md-on-append` attribute was set, tell the controller to use the expression\n          // when appending chips.\n          if (attrs.mdOnAppend) mdChipsCtrl.useMdOnAppendExpression();\n\n          // The md-autocomplete and input elements won't be compiled until after this directive\n          // is complete (due to their nested nature). Wait a tick before looking for them to\n          // configure the controller.\n          if (chipInputTemplate != CHIP_INPUT_TEMPLATE) {\n            $timeout(function() {\n              if (chipInputTemplate.indexOf('<md-autocomplete') === 0)\n                mdChipsCtrl\n                    .configureAutocomplete(element.find('md-autocomplete')\n                        .controller('mdAutocomplete'));\n              mdChipsCtrl.configureUserInput(element.find('input'));\n            });\n          }\n        }\n\n        // Compile with the parent's scope and prepend any static chips to the wrapper.\n        if (staticChips.length > 0) {\n          var compiledStaticChips = $compile(staticChips)(scope.$parent);\n          $timeout(function() { element.find('md-chips-wrap').prepend(compiledStaticChips); });\n        }\n      };\n    }\n  }\n  MdChips.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\", \"$log\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .controller('MdContactChipsCtrl', MdContactChipsCtrl);\n\n\n\n/**\n * Controller for the MdContactChips component\n * @constructor\n */\nfunction MdContactChipsCtrl () {\n  /** @type {Object} */\n  this.selectedItem = null;\n\n  /** @type {string} */\n  this.searchText = '';\n}\n\n\nMdContactChipsCtrl.prototype.queryContact = function(searchText) {\n  var results = this.contactQuery({'$query': searchText});\n  return this.filterSelected ?\n      results.filter(angular.bind(this, this.filterSelectedContacts)) : results;\n};\n\n\nMdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {\n  return this.contacts.indexOf(contact) == -1;\n};\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n      .module('material.components.chips')\n      .directive('mdContactChips', MdContactChips);\n\n  /**\n   * @ngdoc directive\n   * @name mdContactChips\n   * @module material.components.chips\n   *\n   * @description\n   * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an\n   *    `md-autocomplete` element. The component allows the caller to supply a query expression\n   *    which returns  a list of possible contacts. The user can select one of these and add it to\n   *    the list of chips.\n   *\n   * @param {string=|object=} ng-model A model to bind the list of items to\n   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n   *    displayed when there is at least on item in the list\n   * @param {expression} md-contacts An expression expected to return contacts matching the search\n   *    test, `$query`.\n   * @param {string} md-contact-name The field name of the contact object representing the\n   *    contact's name.\n   * @param {string} md-contact-email The field name of the contact object representing the\n   *    contact's email address.\n   * @param {string} md-contact-image The field name of the contact object representing the\n   *    contact's image.\n   *\n   *\n   * // The following attribute has been removed but may come back.\n   * @param {expression=} filter-selected Whether to filter selected contacts from the list of\n   *    suggestions shown in the autocomplete.\n   *\n   *\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   *   <md-contact-chips\n   *       ng-model=\"ctrl.contacts\"\n   *       md-contacts=\"ctrl.querySearch($query)\"\n   *       md-contact-name=\"name\"\n   *       md-contact-image=\"image\"\n   *       md-contact-email=\"email\"\n   *       placeholder=\"To\">\n   *   </md-contact-chips>\n   * </hljs>\n   *\n   */\n\n\n  var MD_CONTACT_CHIPS_TEMPLATE = '\\\n      <md-chips class=\"md-contact-chips\"\\\n          ng-model=\"$mdContactChipsCtrl.contacts\"\\\n          md-require-match=\"$mdContactChipsCtrl.requireMatch\"\\\n          md-autocomplete-snap>\\\n          <md-autocomplete\\\n              md-menu-class=\"md-contact-chips-suggestions\"\\\n              md-selected-item=\"$mdContactChipsCtrl.selectedItem\"\\\n              md-search-text=\"$mdContactChipsCtrl.searchText\"\\\n              md-items=\"item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)\"\\\n              md-item-text=\"$mdContactChipsCtrl.mdContactName\"\\\n              md-no-cache=\"true\"\\\n              md-autoselect\\\n              placeholder=\"{{$mdContactChipsCtrl.contacts.length == 0 ?\\\n                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}\">\\\n            <div class=\"md-contact-suggestion\">\\\n              <img \\\n                  ng-src=\"{{item[$mdContactChipsCtrl.contactImage]}}\"\\\n                  alt=\"{{item[$mdContactChipsCtrl.contactName]}}\" />\\\n              <span class=\"md-contact-name\" md-highlight-text=\"$mdContactChipsCtrl.searchText\">\\\n                {{item[$mdContactChipsCtrl.contactName]}}\\\n              </span>\\\n              <span class=\"md-contact-email\" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\\\n            </div>\\\n          </md-autocomplete>\\\n          <md-chip-template>\\\n            <div class=\"md-contact-avatar\">\\\n              <img \\\n                  ng-src=\"{{$chip[$mdContactChipsCtrl.contactImage]}}\"\\\n                  alt=\"{{$chip[$mdContactChipsCtrl.contactName]}}\" />\\\n            </div>\\\n            <div class=\"md-contact-name\">\\\n              {{$chip[$mdContactChipsCtrl.contactName]}}\\\n            </div>\\\n          </md-chip-template>\\\n      </md-chips>';\n\n\n  /**\n   * MDContactChips Directive Definition\n   *\n   * @param $mdTheming\n   * @returns {*}\n   * @ngInject\n   */\n  function MdContactChips ($mdTheming, $mdUtil) {\n    return {\n      template: function(element, attrs) {\n        return MD_CONTACT_CHIPS_TEMPLATE;\n      },\n      restrict: 'E',\n      controller: 'MdContactChipsCtrl',\n      controllerAs: '$mdContactChipsCtrl',\n      bindToController: true,\n      compile: compile,\n      scope: {\n        contactQuery: '&mdContacts',\n        placeholder: '@',\n        secondaryPlaceholder: '@',\n        contactName: '@mdContactName',\n        contactImage: '@mdContactImage',\n        contactEmail: '@mdContactEmail',\n        contacts: '=ngModel',\n        requireMatch: '=?mdRequireMatch'\n      }\n    };\n\n    function compile(element, attr) {\n      return function postLink(scope, element, attrs, controllers) {\n\n        $mdUtil.initOptionalProperties(scope, attr);\n        $mdTheming(element);\n\n        element.attr('tabindex', '-1');\n      };\n    }\n  }\n  MdContactChips.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc directive\n * @name mdTab\n * @module material.components.tabs\n *\n * @restrict E\n *\n * @description\n * Use the `<md-tab>` a nested directive used within `<md-tabs>` to specify a tab with a **label** and optional *view content*.\n *\n * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specify more\n * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested\n * markup of the `<md-tab>` is used as the tab header markup.\n *\n * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the `<md-tab-body>` tag.  This\n * is to define a clear separation between the tab content and the tab label.\n *\n * If a tab **label** has been identified, then any **non-**`<md-tab-label>` markup\n * will be considered tab content and will be transcluded to the internal `<div class=\"md-tabs-content\">` container.\n *\n * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is\n * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can\n * be initiated via data binding changes, programmatic invocation, or user gestures.\n *\n * @param {string=} label Optional attribute to specify a simple string as the tab label\n * @param {boolean=} disabled If present, disabled tab selection.\n * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.\n * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.\n *\n *\n * @usage\n *\n * <hljs lang=\"html\">\n * <md-tab label=\"\" disabled=\"\" md-on-select=\"\" md-on-deselect=\"\" >\n *   <h3>My Tab content</h3>\n * </md-tab>\n *\n * <md-tab >\n *   <md-tab-label>\n *     <h3>My Tab content</h3>\n *   </md-tab-label>\n *   <md-tab-body>\n *     <p>\n *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,\n *       totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae\n *       dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,\n *       sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.\n *     </p>\n *   </md-tab-body>\n * </md-tab>\n * </hljs>\n *\n */\nangular\n    .module('material.components.tabs')\n    .directive('mdTab', MdTab);\n\nfunction MdTab () {\n  return {\n    require: '^?mdTabs',\n    terminal: true,\n    template: function (element, attr) {\n      var label = getLabel(),\n          body  = getTemplate();\n      return '' +\n          '<md-tab-label>' + label + '</md-tab-label>' +\n          '<md-tab-body>' + body + '</md-tab-body>';\n      function getLabel () {\n        return getLabelElement() || getLabelAttribute() || getElementContents();\n        function getLabelAttribute () { return attr.label; }\n        function getLabelElement () {\n          var label = element.find('md-tab-label').eq(0);\n          if (label.length) return label.remove().html();\n        }\n        function getElementContents () {\n          var html = element.html();\n          element.empty();\n          return html;\n        }\n      }\n      function getTemplate () {\n        var content = element.find('md-tab-body').eq(0),\n            template = content.length ? content.html() : attr.label ? element.html() : '';\n        if (content.length) content.remove();\n        else if (attr.label) element.empty();\n        return template;\n      }\n    },\n    scope: {\n      active:   '=?mdActive',\n      disabled: '=?ngDisabled',\n      select:   '&?mdOnSelect',\n      deselect: '&?mdOnDeselect'\n    },\n    link: postLink\n  };\n\n  function postLink (scope, element, attr, ctrl) {\n    if (!ctrl) return;\n    var tabs = element.parent()[0].getElementsByTagName('md-tab'),\n        index = Array.prototype.indexOf.call(tabs, element[0]),\n        body = element.find('md-tab-body').eq(0).remove(),\n        label = element.find('md-tab-label').eq(0).remove(),\n        data = ctrl.insertTab({\n          scope:    scope,\n          parent:   scope.$parent,\n          index:    index,\n          element:  element,\n          template: body.html(),\n          label:    label.html()\n        }, index);\n\n    scope.select   = scope.select   || angular.noop;\n    scope.deselect = scope.deselect || angular.noop;\n\n    scope.$watch('active', function (active) { if (active) ctrl.select(data.getIndex()); });\n    scope.$watch('disabled', function () { ctrl.refreshIndex(); });\n    scope.$watch(\n        function () {\n          return Array.prototype.indexOf.call(tabs, element[0]);\n        },\n        function (newIndex) {\n          data.index = newIndex;\n          ctrl.updateTabOrder();\n        }\n    );\n    scope.$on('$destroy', function () { ctrl.removeTab(data); });\n\n  }\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTabItem', MdTabItem);\n\nfunction MdTabItem () {\n  return {\n    require: '^?mdTabs',\n    link: function link (scope, element, attr, ctrl) {\n      if (!ctrl) return;\n      ctrl.attachRipple(scope, element);\n    }\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTabLabel', MdTabLabel);\n\nfunction MdTabLabel () {\n  return { terminal: true };\n}\n\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.components.tabs')\n    .directive('mdTabScroll', MdTabScroll);\n\nfunction MdTabScroll ($parse) {\n  return {\n    restrict: 'A',\n    compile: function ($element, attr) {\n      var fn = $parse(attr.mdTabScroll, null, true);\n      return function ngEventHandler (scope, element) {\n        element.on('mousewheel', function (event) {\n          scope.$apply(function () { fn(scope, { $event: event }); });\n        });\n      };\n    }\n  }\n}\nMdTabScroll.$inject = [\"$parse\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .controller('MdTabsController', MdTabsController);\n\n/**\n * @ngInject\n */\nfunction MdTabsController ($scope, $element, $window, $timeout, $mdConstant, $mdTabInkRipple,\n                           $mdUtil, $animate, $attrs, $compile, $mdTheming) {\n  //-- define private properties\n  var ctrl       = this,\n      locked     = false,\n      elements   = getElements(),\n      queue      = [],\n      destroyed  = false,\n      loaded     = false;\n\n  //-- define public properties with change handlers\n  defineProperty('focusIndex', handleFocusIndexChange, $scope.selectedIndex || 0);\n  defineProperty('offsetLeft', handleOffsetChange, 0);\n  defineProperty('hasContent', handleHasContent, false);\n\n  //-- define public properties\n  ctrl.scope = $scope;\n  ctrl.parent = $scope.$parent;\n  ctrl.tabs = [];\n  ctrl.lastSelectedIndex = null;\n  ctrl.hasFocus = false;\n  ctrl.lastClick = true;\n  ctrl.shouldPaginate = false;\n  ctrl.shouldCenterTabs = shouldCenterTabs();\n\n  //-- define public methods\n  ctrl.redirectFocus = redirectFocus;\n  ctrl.attachRipple = attachRipple;\n  ctrl.shouldStretchTabs = shouldStretchTabs;\n  ctrl.insertTab = insertTab;\n  ctrl.removeTab = removeTab;\n  ctrl.select = select;\n  ctrl.scroll = scroll;\n  ctrl.nextPage = nextPage;\n  ctrl.previousPage = previousPage;\n  ctrl.keydown = keydown;\n  ctrl.canPageForward = canPageForward;\n  ctrl.canPageBack = canPageBack;\n  ctrl.refreshIndex = refreshIndex;\n  ctrl.incrementSelectedIndex = incrementSelectedIndex;\n  ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);\n  ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);\n\n  init();\n\n  /**\n   * Perform initialization for the controller, setup events and watcher(s)\n   */\n  function init () {\n    $scope.selectedIndex = $scope.selectedIndex || 0;\n    compileTemplate();\n    configureWatchers();\n    bindEvents();\n    $mdTheming($element);\n    $timeout(function () {\n      updateHeightFromContent();\n      adjustOffset();\n      updatePagination();\n      ctrl.tabs[$scope.selectedIndex] && ctrl.tabs[$scope.selectedIndex].scope.select();\n      loaded = true;\n    });\n  }\n\n  function compileTemplate () {\n    var template = $attrs.$mdTabsTemplate,\n        element  = angular.element(elements.data);\n    element.html(template);\n    $compile(element.contents())(ctrl.parent);\n    delete $attrs.$mdTabsTemplate;\n  }\n\n  function bindEvents () {\n    angular.element($window).on('resize', handleWindowResize);\n    angular.element(elements.paging).on('DOMSubtreeModified', ctrl.updateInkBarStyles);\n    angular.element(elements.paging).on('DOMSubtreeModified', updatePagination);\n  }\n\n  function configureWatchers () {\n    $mdUtil.initOptionalProperties($scope, $attrs);\n    $attrs.$observe('mdNoBar', function (value) { $scope.noInkBar = angular.isDefined(value); });\n    $scope.$watch('selectedIndex', handleSelectedIndexChange);\n    $scope.$watch('dynamicHeight', function (value) {\n      if (value) $element.addClass('md-dynamic-height');\n      else $element.removeClass('md-dynamic-height');\n    });\n    $scope.$on('$destroy', cleanup);\n  }\n\n  /**\n   * Remove any events defined by this controller\n   */\n  function cleanup () {\n    destroyed = true;\n    angular.element($window).off('resize', handleWindowResize);\n    angular.element(elements.paging).off('DOMSubtreeModified', ctrl.updateInkBarStyles);\n    angular.element(elements.paging).off('DOMSubtreeModified', updatePagination);\n  }\n\n  //-- Change handlers\n\n  /**\n   * Add/remove the `md-no-tab-content` class depending on `ctrl.hasContent`\n   * @param hasContent\n   */\n  function handleHasContent (hasContent) {\n    $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');\n  }\n\n  /**\n   * Apply ctrl.offsetLeft to the paging element when it changes\n   * @param left\n   */\n  function handleOffsetChange (left) {\n    var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';\n    angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');\n    $scope.$broadcast('$mdTabsPaginationChanged');\n  }\n\n  /**\n   * Update the UI whenever `ctrl.focusIndex` is updated\n   * @param newIndex\n   * @param oldIndex\n   */\n  function handleFocusIndexChange (newIndex, oldIndex) {\n    if (newIndex === oldIndex) return;\n    if (!elements.tabs[newIndex]) return;\n    adjustOffset();\n    redirectFocus();\n  }\n\n  /**\n   * Update the UI whenever the selected index changes. Calls user-defined select/deselect methods.\n   * @param newValue\n   * @param oldValue\n   */\n  function handleSelectedIndexChange (newValue, oldValue) {\n    if (newValue === oldValue) return;\n\n    $scope.selectedIndex = getNearestSafeIndex(newValue);\n    ctrl.lastSelectedIndex = oldValue;\n    ctrl.updateInkBarStyles();\n    updateHeightFromContent();\n    adjustOffset(newValue);\n    $scope.$broadcast('$mdTabsChanged');\n    ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();\n    ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();\n  }\n\n  /**\n   * Queues up a call to `handleWindowResize` when a resize occurs while the tabs component is\n   * hidden.\n   */\n  function handleResizeWhenVisible () {\n    //-- if there is already a watcher waiting for resize, do nothing\n    if (handleResizeWhenVisible.watcher) return;\n    //-- otherwise, we will abuse the $watch function to check for visible\n    handleResizeWhenVisible.watcher = $scope.$watch(function () {\n      //-- since we are checking for DOM size, we use $timeout to wait for after the DOM updates\n      $timeout(function () {\n        //-- if the watcher has already run (ie. multiple digests in one cycle), do nothing\n        if (!handleResizeWhenVisible.watcher) return;\n\n        if ($element.prop('offsetParent')) {\n          handleResizeWhenVisible.watcher();\n          handleResizeWhenVisible.watcher = null;\n\n          //-- we have to trigger our own $apply so that the DOM bindings will update\n          handleWindowResize();\n        }\n      }, 0, false);\n    });\n  }\n\n  //-- Event handlers / actions\n\n  /**\n   * Handle user keyboard interactions\n   * @param event\n   */\n  function keydown (event) {\n    switch (event.keyCode) {\n      case $mdConstant.KEY_CODE.LEFT_ARROW:\n        event.preventDefault();\n        incrementSelectedIndex(-1, true);\n        break;\n      case $mdConstant.KEY_CODE.RIGHT_ARROW:\n        event.preventDefault();\n        incrementSelectedIndex(1, true);\n        break;\n      case $mdConstant.KEY_CODE.SPACE:\n      case $mdConstant.KEY_CODE.ENTER:\n        event.preventDefault();\n        if (!locked) $scope.selectedIndex = ctrl.focusIndex;\n        break;\n    }\n    ctrl.lastClick = false;\n  }\n\n  /**\n   * Update the selected index and trigger a click event on the original `md-tab` element in order\n   * to fire user-added click events.\n   * @param index\n   */\n  function select (index) {\n    if (!locked) ctrl.focusIndex = $scope.selectedIndex = index;\n    ctrl.lastClick = true;\n    ctrl.tabs[index].element.triggerHandler('click');\n  }\n\n  /**\n   * When pagination is on, this makes sure the selected index is in view.\n   * @param event\n   */\n  function scroll (event) {\n    if (!ctrl.shouldPaginate) return;\n    event.preventDefault();\n    ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);\n  }\n\n  /**\n   * Slides the tabs over approximately one page forward.\n   */\n  function nextPage () {\n    var viewportWidth = elements.canvas.clientWidth,\n        totalWidth = viewportWidth + ctrl.offsetLeft,\n        i, tab;\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      if (tab.offsetLeft + tab.offsetWidth > totalWidth) break;\n    }\n    ctrl.offsetLeft = fixOffset(tab.offsetLeft);\n  }\n\n  /**\n   * Slides the tabs over approximately one page backward.\n   */\n  function previousPage () {\n    var i, tab;\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft) break;\n    }\n    ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);\n  }\n\n  /**\n   * Update size calculations when the window is resized.\n   */\n  function handleWindowResize () {\n    $scope.$apply(function () {\n      ctrl.lastSelectedIndex = $scope.selectedIndex;\n      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n      $timeout(ctrl.updateInkBarStyles, 0, false);\n      $timeout(updatePagination);\n    });\n  }\n\n  /**\n   * Remove a tab from the data and select the nearest valid tab.\n   * @param tabData\n   */\n  function removeTab (tabData) {\n    var selectedIndex = $scope.selectedIndex,\n        tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];\n    refreshIndex();\n    //-- when removing a tab, if the selected index did not change, we have to manually trigger the\n    //   tab select/deselect events\n    if ($scope.selectedIndex === selectedIndex && !destroyed) {\n      tab.scope.deselect();\n      ctrl.tabs[$scope.selectedIndex] && ctrl.tabs[$scope.selectedIndex].scope.select();\n    }\n    $timeout(function () {\n      updatePagination();\n      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n    });\n  }\n\n  /**\n   * Create an entry in the tabs array for a new tab at the specified index.\n   * @param tabData\n   * @param index\n   * @returns {*}\n   */\n  function insertTab (tabData, index) {\n    var proto = {\n          getIndex: function () { return ctrl.tabs.indexOf(tab); },\n          isActive: function () { return this.getIndex() === $scope.selectedIndex; },\n          isLeft:   function () { return this.getIndex() < $scope.selectedIndex; },\n          isRight:  function () { return this.getIndex() > $scope.selectedIndex; },\n          shouldRender: function () { return !$scope.noDisconnect || this.isActive(); },\n          hasFocus: function () { return !ctrl.lastClick\n              && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex; },\n          id:       $mdUtil.nextUid()\n        },\n        tab = angular.extend(proto, tabData);\n    if (angular.isDefined(index)) {\n      ctrl.tabs.splice(index, 0, tab);\n    } else {\n      ctrl.tabs.push(tab);\n    }\n    processQueue();\n    updateHasContent();\n    //-- if autoselect is enabled, select the newly added tab\n    if (loaded && $scope.autoselect) $timeout(function () { select(ctrl.tabs.indexOf(tab)); });\n    $timeout(updatePagination);\n    return tab;\n  }\n\n  //-- Getter methods\n\n  /**\n   * Gathers references to all of the DOM elements used by this controller.\n   * @returns {{}}\n   */\n  function getElements () {\n    var elements      = {};\n\n    //-- gather tab bar elements\n    elements.wrapper  = $element[0].getElementsByTagName('md-tabs-wrapper')[0];\n    elements.data     = $element[0].getElementsByTagName('md-tab-data')[0];\n    elements.canvas   = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];\n    elements.paging   = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];\n    elements.tabs     = elements.paging.getElementsByTagName('md-tab-item');\n    elements.dummies  = elements.canvas.getElementsByTagName('md-dummy-tab');\n    elements.inkBar   = elements.paging.getElementsByTagName('md-ink-bar')[0];\n\n    //-- gather tab content elements\n    elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];\n    elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');\n\n    return elements;\n  }\n\n  /**\n   * Determines whether or not the left pagination arrow should be enabled.\n   * @returns {boolean}\n   */\n  function canPageBack () {\n    return ctrl.offsetLeft > 0;\n  }\n\n  /**\n   * Determines whether or not the right pagination arrow should be enabled.\n   * @returns {*|boolean}\n   */\n  function canPageForward () {\n    var lastTab = elements.tabs[elements.tabs.length - 1];\n    return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth +\n        ctrl.offsetLeft;\n  }\n\n  /**\n   * Determines if the UI should stretch the tabs to fill the available space.\n   * @returns {*}\n   */\n  function shouldStretchTabs () {\n    switch ($scope.stretchTabs) {\n      case 'always': return true;\n      case 'never':  return false;\n      default:       return !ctrl.shouldPaginate\n          && $window.matchMedia('(max-width: 600px)').matches;\n    }\n  }\n\n  /**\n   * Determines if the tabs should appear centered.\n   * @returns {string|boolean}\n   */\n  function shouldCenterTabs () {\n    return $scope.centerTabs && !ctrl.shouldPaginate;\n  }\n\n  /**\n   * Determines if pagination is necessary to display the tabs within the available space.\n   * @returns {boolean}\n   */\n  function shouldPaginate () {\n    if ($scope.noPagination || !loaded) return false;\n    var canvasWidth = $element.prop('clientWidth');\n    angular.forEach(elements.dummies, function (tab) { canvasWidth -= tab.offsetWidth; });\n    return canvasWidth < 0;\n  }\n\n  /**\n   * Finds the nearest tab index that is available.  This is primarily used for when the active\n   * tab is removed.\n   * @param newIndex\n   * @returns {*}\n   */\n  function getNearestSafeIndex(newIndex) {\n    var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),\n        i, tab;\n    for (i = 0; i <= maxOffset; i++) {\n      tab = ctrl.tabs[newIndex + i];\n      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n      tab = ctrl.tabs[newIndex - i];\n      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n    }\n    return newIndex;\n  }\n\n  //-- Utility methods\n\n  /**\n   * Defines a property using a getter and setter in order to trigger a change handler without\n   * using `$watch` to observe changes.\n   * @param key\n   * @param handler\n   * @param value\n   */\n  function defineProperty (key, handler, value) {\n    Object.defineProperty(ctrl, key, {\n      get: function () { return value; },\n      set: function (newValue) {\n        var oldValue = value;\n        value = newValue;\n        handler(newValue, oldValue);\n      }\n    });\n  }\n\n  /**\n   * Updates whether or not pagination should be displayed.\n   */\n  function updatePagination () {\n    ctrl.shouldPaginate = shouldPaginate();\n    ctrl.shouldCenterTabs = shouldCenterTabs();\n    $timeout(function () {\n      adjustOffset($scope.selectedIndex);\n    });\n  }\n\n  /**\n   * Re-orders the tabs and updates the selected and focus indexes to their new positions.\n   * This is triggered by `tabDirective.js` when the user's tabs have been re-ordered.\n   */\n  function updateTabOrder () {\n    var selectedItem = ctrl.tabs[$scope.selectedIndex],\n        focusItem = ctrl.tabs[ctrl.focusIndex];\n    ctrl.tabs = ctrl.tabs.sort(function (a, b) {\n      return a.index - b.index;\n    });\n    $scope.selectedIndex = ctrl.tabs.indexOf(selectedItem);\n    ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);\n  }\n\n  /**\n   * This moves the selected or focus index left or right.  This is used by the keydown handler.\n   * @param inc\n   */\n  function incrementSelectedIndex (inc) {\n    var newIndex,\n        index = ctrl.focusIndex;\n    for (newIndex = index + inc;\n         ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled;\n         newIndex += inc) {}\n    if (ctrl.tabs[newIndex]) {\n      ctrl.focusIndex = newIndex;\n    }\n  }\n\n  /**\n   * This is used to forward focus to dummy elements.  This method is necessary to avoid aniation\n   * issues when attempting to focus an item that is out of view.\n   */\n  function redirectFocus () {\n    elements.dummies[ctrl.focusIndex].focus();\n  }\n\n  /**\n   * Forces the pagination to move the focused tab into view.\n   */\n  function adjustOffset (index) {\n    if (ctrl.shouldCenterTabs) return;\n    if (index == null) index = ctrl.focusIndex;\n    var tab = elements.tabs[index],\n        left = tab.offsetLeft,\n        right = tab.offsetWidth + left;\n    ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth));\n    ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));\n  }\n\n  /**\n   * Iterates through all queued functions and clears the queue.  This is used for functions that\n   * are called before the UI is ready, such as size calculations.\n   */\n  function processQueue () {\n    queue.forEach(function (func) { $timeout(func); });\n    queue = [];\n  }\n\n  /**\n   * Determines if the tab content area is needed.\n   */\n  function updateHasContent () {\n    var hasContent = false;\n    angular.forEach(ctrl.tabs, function (tab) {\n      if (tab.template) hasContent = true;\n    });\n    ctrl.hasContent = hasContent;\n  }\n\n  /**\n   * Moves the indexes to their nearest valid values.\n   */\n  function refreshIndex () {\n    $scope.selectedIndex = getNearestSafeIndex($scope.selectedIndex);\n    ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);\n  }\n\n  /**\n   * Calculates the content height of the current tab.\n   * @returns {*}\n   */\n  function updateHeightFromContent () {\n    if (!$scope.dynamicHeight) return $element.css('height', '');\n    if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);\n    var tabContent    = elements.contents[$scope.selectedIndex],\n        contentHeight = tabContent ? tabContent.offsetHeight : 0,\n        tabsHeight    = elements.wrapper.offsetHeight,\n        newHeight     = contentHeight + tabsHeight,\n        currentHeight = $element.prop('clientHeight');\n    if (currentHeight === newHeight) return;\n    locked = true;\n    $animate\n        .animate(\n          $element,\n          { height: currentHeight + 'px' },\n          { height: newHeight + 'px'}\n        )\n        .then(function () {\n          $element.css('height', '');\n          locked = false;\n        });\n  }\n\n  /**\n   * Repositions the ink bar to the selected tab.\n   * @returns {*}\n   */\n  function updateInkBarStyles () {\n    if (!elements.tabs[$scope.selectedIndex]) return;\n    if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);\n    //-- if the element is not visible, we will not be able to calculate sizes until it is\n    //-- we should treat that as a resize event rather than just updating the ink bar\n    if (!$element.prop('offsetParent')) return handleResizeWhenVisible();\n    var index = $scope.selectedIndex,\n        totalWidth = elements.paging.offsetWidth,\n        tab = elements.tabs[index],\n        left = tab.offsetLeft,\n        right = totalWidth - left - tab.offsetWidth;\n    updateInkBarClassName();\n    angular.element(elements.inkBar).css({ left: left + 'px', right: right + 'px' });\n  }\n\n  /**\n   * Adds left/right classes so that the ink bar will animate properly.\n   */\n  function updateInkBarClassName () {\n    var newIndex = $scope.selectedIndex,\n        oldIndex = ctrl.lastSelectedIndex,\n        ink = angular.element(elements.inkBar);\n    if (!angular.isNumber(oldIndex)) return;\n    if (newIndex < oldIndex) {\n      ink.addClass('md-left').removeClass('md-right');\n    } else if (newIndex > oldIndex) {\n      ink.addClass('md-right').removeClass('md-left');\n    }\n  }\n\n  /**\n   * Takes an offset value and makes sure that it is within the min/max allowed values.\n   * @param value\n   * @returns {*}\n   */\n  function fixOffset (value) {\n    if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;\n    var lastTab = elements.tabs[elements.tabs.length - 1],\n        totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;\n    value = Math.max(0, value);\n    value = Math.min(totalWidth - elements.canvas.clientWidth, value);\n    return value;\n  }\n\n  /**\n   * Attaches a ripple to the tab item element.\n   * @param scope\n   * @param element\n   */\n  function attachRipple (scope, element) {\n    var options = { colorElement: angular.element(elements.inkBar) };\n    $mdTabInkRipple.attach(scope, element, options);\n  }\n}\nMdTabsController.$inject = [\"$scope\", \"$element\", \"$window\", \"$timeout\", \"$mdConstant\", \"$mdTabInkRipple\", \"$mdUtil\", \"$animate\", \"$attrs\", \"$compile\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc directive\n * @name mdTabs\n * @module material.components.tabs\n *\n * @restrict E\n *\n * @description\n * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.\n * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view\n * content that will be associated with each tab button.\n *\n * Below is the markup for its simplest usage:\n *\n *  <hljs lang=\"html\">\n *  <md-tabs>\n *    <md-tab label=\"Tab #1\"></md-tab>\n *    <md-tab label=\"Tab #2\"></md-tab>\n *    <md-tab label=\"Tab #3\"></md-tab>\n *  </md-tabs>\n *  </hljs>\n *\n * Tabs supports three (3) usage scenarios:\n *\n *  1. Tabs (buttons only)\n *  2. Tabs with internal view content\n *  3. Tabs with external view content\n *\n * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.\n * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.\n * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.\n *\n * Additional features also include:\n *\n * *  Content can include any markup.\n * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.\n *\n * ### Explanation of tab stretching\n *\n * Initially, tabs will have an inherent size.  This size will either be defined by how much space is needed to accommodate their text or set by the user through CSS.  Calculations will be based on this size.\n *\n * On mobile devices, tabs will be expanded to fill the available horizontal space.  When this happens, all tabs will become the same size.\n *\n * On desktops, by default, stretching will never occur.\n *\n * This default behavior can be overridden through the `md-stretch-tabs` attribute.  Here is a table showing when stretching will occur:\n *\n * `md-stretch-tabs` | mobile    | desktop\n * ------------------|-----------|--------\n * `auto`            | stretched | ---\n * `always`          | stretched | stretched\n * `never`           | ---       | ---\n *\n * @param {integer=} md-selected Index of the active/selected tab\n * @param {boolean=} md-no-ink If present, disables ink ripple effects.\n * @param {boolean=} md-no-bar If present, disables the selection ink bar.\n * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`; default is `top`\n * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`, `always`, or `never`; default is `auto`\n * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the contents of the selected tab\n * @param {boolean=} md-center-tabs When enabled, tabs will be centered provided there is no need for pagination\n * @param {boolean=} md-no-pagination When enabled, pagination will remain off\n * @param {boolean=} md-swipe-content When enabled, swipe gestures will be enabled for the content area to jump between tabs\n * @param {boolean=} md-no-disconnect If your tab content has background tasks (ie. event listeners), you will want to include this to prevent the scope from being disconnected\n * @param {boolean=} md-autoselect When present, any tabs added after the initial load will be automatically selected\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-tabs md-selected=\"selectedIndex\" >\n *   <img ng-src=\"img/angular.png\" class=\"centered\">\n *   <md-tab\n *       ng-repeat=\"tab in tabs | orderBy:predicate:reversed\"\n *       md-on-select=\"onTabSelected(tab)\"\n *       md-on-deselect=\"announceDeselected(tab)\"\n *       ng-disabled=\"tab.disabled\">\n *     <md-tab-label>\n *       {{tab.title}}\n *       <img src=\"img/removeTab.png\" ng-click=\"removeTab(tab)\" class=\"delete\">\n *     </md-tab-label>\n *     <md-tab-body>\n *       {{tab.content}}\n *     </md-tab-body>\n *   </md-tab>\n * </md-tabs>\n * </hljs>\n *\n */\nangular\n    .module('material.components.tabs')\n    .directive('mdTabs', MdTabs);\n\nfunction MdTabs ($mdTheming, $mdUtil, $compile) {\n  return {\n    scope: {\n      noPagination:  '=?mdNoPagination',\n      dynamicHeight: '=?mdDynamicHeight',\n      centerTabs:    '=?mdCenterTabs',\n      selectedIndex: '=?mdSelected',\n      stretchTabs:   '@?mdStretchTabs',\n      swipeContent:  '=?mdSwipeContent',\n      noDisconnect:  '=?mdNoDisconnect',\n      autoselect:    '=?mdAutoselect'\n    },\n    template: function (element, attr) {\n      attr[\"$mdTabsTemplate\"] = element.html();\n      return '\\\n        <md-tabs-wrapper ng-class=\"{ \\'md-stretch-tabs\\': $mdTabsCtrl.shouldStretchTabs() }\">\\\n          <md-tab-data></md-tab-data>\\\n          <md-prev-button\\\n              tabindex=\"-1\"\\\n              role=\"button\"\\\n              aria-label=\"Previous Page\"\\\n              aria-disabled=\"{{!$mdTabsCtrl.canPageBack()}}\"\\\n              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageBack() }\"\\\n              ng-if=\"$mdTabsCtrl.shouldPaginate\"\\\n              ng-click=\"$mdTabsCtrl.previousPage()\">\\\n            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n          </md-prev-button>\\\n          <md-next-button\\\n              tabindex=\"-1\"\\\n              role=\"button\"\\\n              aria-label=\"Next Page\"\\\n              aria-disabled=\"{{!$mdTabsCtrl.canPageForward()}}\"\\\n              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageForward() }\"\\\n              ng-if=\"$mdTabsCtrl.shouldPaginate\"\\\n              ng-click=\"$mdTabsCtrl.nextPage()\">\\\n            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n          </md-next-button>\\\n          <md-tabs-canvas\\\n              tabindex=\"0\"\\\n              aria-activedescendant=\"tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}\"\\\n              ng-focus=\"$mdTabsCtrl.redirectFocus()\"\\\n              ng-class=\"{\\\n                  \\'md-paginated\\': $mdTabsCtrl.shouldPaginate,\\\n                  \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs\\\n              }\"\\\n              ng-keydown=\"$mdTabsCtrl.keydown($event)\"\\\n              role=\"tablist\">\\\n            <md-pagination-wrapper\\\n                ng-class=\"{ \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs }\"\\\n                md-tab-scroll=\"$mdTabsCtrl.scroll($event)\">\\\n              <md-tab-item\\\n                  tabindex=\"-1\"\\\n                  class=\"md-tab\"\\\n                  style=\"max-width: {{ tabWidth ? tabWidth + \\'px\\' : \\'none\\' }}\"\\\n                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n                  role=\"tab\"\\\n                  aria-controls=\"tab-content-{{tab.id}}\"\\\n                  aria-selected=\"{{tab.isActive()}}\"\\\n                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n                  ng-click=\"$mdTabsCtrl.select(tab.getIndex())\"\\\n                  ng-class=\"{\\\n                      \\'md-active\\':    tab.isActive(),\\\n                      \\'md-focused\\':   tab.hasFocus(),\\\n                      \\'md-disabled\\':  tab.scope.disabled\\\n                  }\"\\\n                  ng-disabled=\"tab.scope.disabled\"\\\n                  md-swipe-left=\"$mdTabsCtrl.nextPage()\"\\\n                  md-swipe-right=\"$mdTabsCtrl.previousPage()\"\\\n                  md-template=\"tab.label\"\\\n                  md-scope=\"tab.parent\"></md-tab-item>\\\n              <md-ink-bar ng-hide=\"noInkBar\"></md-ink-bar>\\\n            </md-pagination-wrapper>\\\n            <div class=\"md-visually-hidden md-dummy-wrapper\">\\\n              <md-dummy-tab\\\n                  class=\"md-tab\"\\\n                  tabindex=\"-1\"\\\n                  id=\"tab-item-{{tab.id}}\"\\\n                  role=\"tab\"\\\n                  aria-controls=\"tab-content-{{tab.id}}\"\\\n                  aria-selected=\"{{tab.isActive()}}\"\\\n                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n                  ng-focus=\"$mdTabsCtrl.hasFocus = true\"\\\n                  ng-blur=\"$mdTabsCtrl.hasFocus = false\"\\\n                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n                  md-template=\"tab.label\"\\\n                  md-scope=\"tab.parent\"></md-dummy-tab>\\\n            </div>\\\n          </md-tabs-canvas>\\\n        </md-tabs-wrapper>\\\n        <md-tabs-content-wrapper ng-show=\"$mdTabsCtrl.hasContent\">\\\n          <md-tab-content\\\n              id=\"tab-content-{{tab.id}}\"\\\n              role=\"tabpanel\"\\\n              aria-labelledby=\"tab-item-{{tab.id}}\"\\\n              md-swipe-left=\"swipeContent && $mdTabsCtrl.incrementSelectedIndex(1)\"\\\n              md-swipe-right=\"swipeContent && $mdTabsCtrl.incrementSelectedIndex(-1)\"\\\n              ng-if=\"$mdTabsCtrl.hasContent\"\\\n              ng-repeat=\"(index, tab) in $mdTabsCtrl.tabs\"\\\n              md-connected-if=\"tab.isActive()\"\\\n              ng-class=\"{\\\n                \\'md-no-transition\\': $mdTabsCtrl.lastSelectedIndex == null,\\\n                \\'md-active\\':        tab.isActive(),\\\n                \\'md-left\\':          tab.isLeft(),\\\n                \\'md-right\\':         tab.isRight(),\\\n                \\'md-no-scroll\\':     dynamicHeight\\\n              }\">\\\n            <div\\\n                md-template=\"tab.template\"\\\n                md-scope=\"tab.parent\"\\\n                ng-if=\"tab.shouldRender()\"></div>\\\n          </md-tab-content>\\\n        </md-tabs-content-wrapper>\\\n      ';\n    },\n    controller: 'MdTabsController',\n    controllerAs: '$mdTabsCtrl'\n  };\n}\nMdTabs.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTemplate', MdTemplate);\n\nfunction MdTemplate ($compile, $mdUtil, $timeout) {\n  return {\n    restrict: 'A',\n    link: link,\n    scope: {\n      template: '=mdTemplate',\n      compileScope: '=mdScope',\n      connected: '=?mdConnectedIf'\n    },\n    require: '^?mdTabs'\n  };\n  function link (scope, element, attr, ctrl) {\n    if (!ctrl) return;\n    var compileScope = scope.compileScope.$new();\n    element.html(scope.template);\n    $compile(element.contents())(compileScope);\n    return $timeout(handleScope);\n    function handleScope () {\n      scope.$watch('connected', function (value) { value === false ? disconnect() : reconnect(); });\n      scope.$on('$destroy', reconnect);\n    }\n    function disconnect () {\n      if (ctrl.scope.noDisconnect) return;\n      $mdUtil.disconnectScope(compileScope);\n    }\n    function reconnect () {\n      if (ctrl.scope.noDisconnect) return;\n      $mdUtil.reconnectScope(compileScope);\n    }\n  }\n}\nMdTemplate.$inject = [\"$compile\", \"$mdUtil\", \"$timeout\"];\n\n})();\n(function(){ \nangular.module(\"material.core\").constant(\"$MD_THEME_CSS\", \"/* mixin definition ; sets LTR and RTL within the same style call */md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop.md-opaque.md-THEME_NAME-theme {  background-color: '{{foreground-4-0.5}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }a.md-button.md-THEME_NAME-theme, .md-button.md-THEME_NAME-theme {  border-radius: 3px; }  a.md-button.md-THEME_NAME-theme:not([disabled]):hover, .md-button.md-THEME_NAME-theme:not([disabled]):hover {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme:not([disabled]).md-focused {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover, .md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {    background-color: transparent; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab md-icon, .md-button.md-THEME_NAME-theme.md-fab md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-icon-button, .md-button.md-THEME_NAME-theme.md-icon-button {    border-radius: 50%; }  a.md-button.md-THEME_NAME-theme.md-primary, .md-button.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab, .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {      color: '{{primary-contrast}}';      background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {        color: '{{primary-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {        background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {        background-color: '{{primary-600}}'; }    a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {      color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-raised, .md-button.md-THEME_NAME-theme.md-raised {    color: '{{background-contrast}}';    background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon {      color: '{{background-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {      background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {      background-color: '{{background-200}}'; }  a.md-button.md-THEME_NAME-theme.md-warn, .md-button.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab, .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {      color: '{{warn-contrast}}';      background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {        color: '{{warn-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {        background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {        background-color: '{{warn-700}}'; }    a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {      color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent, .md-button.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab, .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {      color: '{{accent-contrast}}';      background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {        color: '{{accent-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {        background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {        background-color: '{{accent-700}}'; }    a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {      color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled], .md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-accent[disabled], .md-button.md-THEME_NAME-theme.md-warn[disabled] {    color: '{{foreground-3}}';    cursor: not-allowed; }    a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon, .md-button.md-THEME_NAME-theme[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {      color: '{{foreground-3}}'; }  a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {    background-color: '{{foreground-4}}'; }  a.md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme[disabled] {    background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label, md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages, md-input-container.md-THEME_NAME-theme [ng-message], md-input-container.md-THEME_NAME-theme [data-ng-message], md-input-container.md-THEME_NAME-theme [x-ng-message] {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled], [disabled] md-input-container.md-THEME_NAME-theme .md-input {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, '{{foreground-3}}' 0%, '{{foreground-3}}' 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, '{{foreground-3}}' 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-list.md-THEME_NAME-theme md-list-item button {  background-color: '{{background-color}}'; }  md-list.md-THEME_NAME-theme md-list-item button.md-button:not([disabled]):hover {    background-color: '{{background-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient('{{warn-100}}' 0%, '{{warn-100}}' 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient('{{accent-100}}' 0%, '{{accent-100}}' 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled], md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked:not([disabled]).md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-label {  color: '{{warn-500}}' !important;  border-bottom-color: '{{warn-500}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label.md-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-label {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-label {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-label {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-label.md-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme .md-select-label {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-label.md-placeholder {    color: '{{foreground-2}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  border-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled] {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme .md-button {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-background {    background-color: '{{foreground-2}}'; }\"); \n})();\n\n\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-material/angular-material.js\n ** module id = 6\n ** module chunks = 0\n **/","// Should already be required, here for clarity\nrequire('angular');\n\n// Load Angular and dependent libs\nrequire('angular-animate');\nrequire('angular-aria');\n\n// Now load Angular Material\nrequire('./angular-material');\n\n// Export namespace\nmodule.exports = 'ngMaterial';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/angular-material/index.js\n ** module id = 7\n ** module chunks = 0\n **/","// some versions of angular don't export the angular module properly,\n// so we get it from window in this case.\nvar angular = require('angular');\nif (!angular.version) {\n  angular = window.angular;\n}\nmodule.exports = angular;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./angular-fix/index.js\n **/","import angular from './angular-fix';\nimport formly from 'angular-formly';\nimport ngMaterial from 'angular-material';\n\n// manipulators\nimport mdInputContainerFlexManipulator from './run/mdInputContainerFlexManipulator';\n\n// types\nimport checkbox from './types/checkbox';\nimport input from './types/input';\nimport multiCheckbox from './types/multiCheckbox';\nimport radio from './types/radio';\nimport select from './types/select';\nimport textarea from './types/textarea';\n\n// wrappers\nimport mdLabel from './wrappers/mdLabel';\nimport mdInputContainer from './wrappers/mdInputContainer';\n\nconst ngModuleName = 'formlyMaterial';\nconst ngModule = angular.module(ngModuleName, [formly, ngMaterial]);\nngModule.constant(\n  'formlyMaterialApiCheck',\n  require('api-check')({\n    output: {\n      prefix: 'angular-formly-material'\n    }\n  })\n);\nngModule.constant('formlyMaterialVersion', VERSION);\n\nexport default ngModuleName;\n\nconst configFns = [\n  checkbox, input, multiCheckbox, radio,\n  select, textarea, mdLabel, mdInputContainer\n];\n\nangular.forEach(configFns, configFn => angular.config(configFn));\n\nconst runFns = [\n  mdInputContainerFlexManipulator\n];\n\nangular.forEach(runFns, runFn => angular.run(runFn));\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.common.js\n **/","export default addMdInputContainerFlexManipulator;\n\n// @ngInject\nfunction addMdInputContainerFlexManipulator(formlyConfig) {\n  formlyConfig.templateManipulators.postWrapper.push(function mdInputContainerFlex(template, options, scope) {\n    if (angular.isDefined(options.templateOptions.flex)) {\n      const el = angular.element(`<div>${template}</div>`);\n      const mdInputContainer = el[0].querySelector('md-input-container');\n      if (mdInputContainer) {\n        mdInputContainer.setAttribute('flex', options.templateOptions.flex);\n        return el;\n      } else {\n        return template;\n      }\n    } else {\n      return template;\n    }\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./run/mdInputContainerFlexManipulator.js\n **/","export default addCheckboxType;\n\n// @ngInject\nfunction addCheckboxType(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setType({\n    name: 'checkbox',\n    template: require('./checkbox.html'),\n    wrapper: ['bootstrapHasError'],\n    apiCheck: {\n      templateOptions: c.shape({\n        label: c.string\n      })\n    },\n    apiCheckInstance: c\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/checkbox.js\n **/","export default addInputType;\n\n// @ngInject\nfunction addInputType(formlyConfigProvider) {\n  formlyConfigProvider.setType({\n    name: 'input',\n    template: '<input ng-model=\"model[options.key]\">',\n    wrapper: ['materialLabel', 'mdInputContainer'],\n    defaultOptions: {\n      ngModelAttrs: {\n        mdMaxlength: {\n          bound: 'md-maxlength'\n        }\n      }\n    }\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/input.js\n **/","export default addCheckboxType;\n\n// @ngInject\nfunction addCheckboxType(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setType({\n    name: 'multiCheckbox',\n    template: require('./multiCheckbox.html'),\n    wrapper: ['materialLabel', 'bootstrapHasError'],\n    defaultOptions: {\n      noFormControl: false\n    },\n    apiCheck: {\n      templateOptions: c.shape({\n        options: c.arrayOf(c.object),\n        labelProp: c.string.optional,\n        valueProp: c.string.optional\n      })\n    },\n    apiCheckInstance: c,\n    controller: /* @ngInject */ function($scope) {\n      const to = $scope.to;\n      const opts = $scope.options;\n      $scope.multiCheckbox = {\n        checked: [],\n        change: setModel\n      };\n\n      // initialize the checkboxes check property\n      const modelValue = $scope.model[opts.key];\n      if (angular.isArray(modelValue)) {\n        const valueProp = to.valueProp || 'value';\n        angular.forEach(to.options, function(v, index) {\n          $scope.multiCheckbox.checked[index] = modelValue.indexOf(v[valueProp]) !== -1;\n        });\n      }\n\n      function setModel() {\n        $scope.model[opts.key] = [];\n        angular.forEach($scope.multiCheckbox.checked, (checkbox, index) => {\n          if (checkbox) {\n            $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n          }\n        });\n      }\n    }\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/multiCheckbox.js\n **/","export default addRadioType;\n\n// @ngInject\nfunction addRadioType(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setType({\n    name: 'radio',\n    template: require('./radio.html'),\n    wrapper: ['materialLabel', 'bootstrapHasError'],\n    defaultOptions: {\n      noFormControl: false\n    },\n    apiCheck: {\n      templateOptions: c.shape({\n        options: c.arrayOf(c.object),\n        labelProp: c.string.optional,\n        valueProp: c.string.optional\n      })\n    },\n    apiCheckInstance: c\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/radio.js\n **/","export default addSelectType;\n// @ngInject\nfunction addSelectType(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setType({\n    name: 'select',\n    template: require('./select.html'),\n    wrapper: ['materialLabel', 'bootstrapHasError'],\n    apiCheck: {\n      templateOptions: c.shape({\n        options: c.arrayOf(c.object),\n        labelProp: c.string.optional,\n        valueProp: c.string.optional,\n        groupProp: c.string.optional\n      })\n    },\n    apiCheckInstance: c\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/select.js\n **/","export default addTextareaType;\n\n// @ngInject\nfunction addTextareaType(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setType({\n    name: 'textarea',\n    template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n    wrapper: ['materialLabel', 'bootstrapHasError'],\n    defaultOptions: {\n      ngModelAttrs: {\n        rows: {attribute: 'rows'},\n        cols: {attribute: 'cols'}\n      }\n    },\n    apiCheck: {\n      templateOptions: c.shape({\n        rows: c.number.optional,\n        cols: c.number.optional\n      })\n    },\n    apiCheckInstance: c\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./types/textarea.js\n **/","export default addMdInputContainerWrapper;\n\n// @ngInject\nfunction addMdInputContainerWrapper(formlyConfigProvider) {\n  formlyConfigProvider.setWrapper({\n    name: 'mdInputContainer',\n    template: `<md-input-container><formly-transclude></formly-transclude></md-input-container>`\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./wrappers/mdInputContainer.js\n **/","export default addMdLabelWrapper;\n\n// @ngInject\nfunction addMdLabelWrapper(formlyConfigProvider, formlyMaterialApiCheck) {\n  const c = formlyMaterialApiCheck;\n  formlyConfigProvider.setWrapper({\n    name: 'mdLabel',\n    template: require('./mdLabel.html'),\n    apiCheck: {\n      templateOptions: c.shape({\n        label: c.string,\n        required: c.bool.optional\n      })\n    },\n    apiCheckInstance: c\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./wrappers/mdLabel.js\n **/","module.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./types/checkbox.html\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./types/multiCheckbox.html\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./types/radio.html\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = \"<select class=\\\"form-control\\\"\\n        ng-model=\\\"model[options.key]\\\"\\n        ng-options=\\\"option[to.valueProp || 'value'] as option[to.labelProp || 'name'] group by option[to.groupProp || 'group'] for option in to.options\\\">\\n</select>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./types/select.html\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = \"<label for=\\\"{{id}}\\\" class=\\\"control-label\\\">\\n  {{to.label}}\\n  {{to.required ? '*' : ''}}\\n</label>\\n<formly-transclude></formly-transclude>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wrappers/mdLabel.html\n ** module id = 23\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"apiCheck\",\"amd\":\"api-check\",\"commonjs\":\"api-check\",\"commonjs2\":\"api-check\"}\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_25__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"ngFormly\",\"amd\":\"angular-formly\",\"commonjs\":\"angular-formly\",\"commonjs2\":\"angular-formly\"}\n ** module id = 25\n ** module chunks = 0\n **/"],"sourceRoot":""}